# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'username': 'bbehjachib',
                'password': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'username': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'avatarUrl': 'bgeecijdgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'isAdmin': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'resetToken': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeysT'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by resetTokenExpiresAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['resetTokenExpiresAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Player]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Player.prisma().query_raw(
            'SELECT * FROM Player WHERE id = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Player
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Player.prisma().query_first(
            'SELECT * FROM Player WHERE ea_id = $1',
            'bgehebiafc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerCreateInput,
        include: Optional[types.PlayerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Player record.

        Parameters
        ----------
        data
            Player record data
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The created Player record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Player record from just the required fields
        player = await Player.prisma().create(
            data={
                # data to create a Player record
                'id': 'bghffegacj',
                'ea_id': 'bhghchehcc',
                'name': 'dcgchcbbf',
                'activeSystem': enums.System.PS,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Player records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Player record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Player.prisma().create_many(
            data=[
                {
                    # data to create a Player record
                    'id': 'bdedcabahc',
                    'ea_id': 'ghfhiafcb',
                    'name': 'heejgedji',
                    'activeSystem': enums.System.PS,
                },
                {
                    # data to create a Player record
                    'id': 'bjgjgibgbf',
                    'ea_id': 'bbbgbhfjge',
                    'name': 'igbehcbab',
                    'activeSystem': enums.System.PS,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerWhereUniqueInput,
        include: Optional[types.PlayerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Player record.

        Parameters
        ----------
        where
            Player filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The deleted Player record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        player = await Player.prisma().delete(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerWhereUniqueInput,
        include: Optional[types.PlayerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Player record.

        Parameters
        ----------
        where
            Player filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The found Player record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        player = await Player.prisma().find_unique(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerWhereUniqueInput,
        include: Optional[types.PlayerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Player record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Player filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The found Player record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        player = await Player.prisma().find_unique_or_raise(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
        include: Optional[types.PlayerInclude] = None,
        order: Optional[Union[types.PlayerOrderByInput, List[types.PlayerOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Player records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Player records returned
        skip
            Ignore the first N results
        where
            Player filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Player model
        order
            Order the returned Player records by any field
        distinct
            Filter Player records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Player]
            The list of all Player records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Player records
        players = await Player.prisma().find_many(take=10)

        # find the first 5 Player records ordered by the name field
        players = await Player.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
        include: Optional[types.PlayerInclude] = None,
        order: Optional[Union[types.PlayerOrderByInput, List[types.PlayerOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Player record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Player filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Player model
        order
            Order the returned Player records by any field
        distinct
            Filter Player records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Player
            The first Player record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Player record ordered by the activeSystem field
        player = await Player.prisma().find_first(
            skip=1,
            order={
                'activeSystem': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
        include: Optional[types.PlayerInclude] = None,
        order: Optional[Union[types.PlayerOrderByInput, List[types.PlayerOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Player record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Player filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Player model
        order
            Order the returned Player records by any field
        distinct
            Filter Player records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Player
            The first Player record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Player record ordered by the createdAt field
        player = await Player.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerUpdateInput,
        where: types.PlayerWhereUniqueInput,
        include: Optional[types.PlayerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Player record.

        Parameters
        ----------
        data
            Player record data specifying what to update
        where
            Player filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The updated Player record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        player = await Player.prisma().update(
            where={
                'id': 'bigibebcib',
            },
            data={
                # data to update the Player record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerWhereUniqueInput,
        data: types.PlayerUpsertInput,
        include: Optional[types.PlayerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Player filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Player model

        Returns
        -------
        prisma.models.Player
            The created or updated Player record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        player = await Player.prisma().upsert(
            where={
                'id': 'bigaiehgcc',
            },
            data={
                'create': {
                    'id': 'bigaiehgcc',
                    'ea_id': 'bbbgbhfjge',
                    'name': 'igbehcbab',
                    'activeSystem': enums.System.PS,
                },
                'update': {
                    'ea_id': 'bbbgbhfjge',
                    'name': 'igbehcbab',
                    'activeSystem': enums.System.PS,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerUpdateManyMutationInput,
        where: types.PlayerWhereInput,
    ) -> int:
        """Update multiple Player records

        Parameters
        ----------
        data
            Player data to update the selected Player records to
        where
            Filter to select the Player records to update

        Returns
        -------
        int
            The total number of Player records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Player records
        total = await Player.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Player records present in the database

        Parameters
        ----------
        select
            Select the Player fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Player filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Player.prisma().count()

        # results: prisma.types.PlayerCountAggregateOutput
        results = await Player.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
    ) -> types.PlayerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerWhereInput] = None,
        cursor: Optional[types.PlayerWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerCountAggregateOutput]:
        """Count the number of Player records present in the database

        Parameters
        ----------
        select
            Select the Player fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Player filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Player.prisma().count()

        # results: prisma.types.PlayerCountAggregateOutput
        results = await Player.prisma().count(
            select={
                '_all': True,
                'ea_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerWhereInput] = None
    ) -> int:
        """Delete multiple Player records.

        Parameters
        ----------
        where
            Optional Player filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Player records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Player records
        total = await Player.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerAvgAggregateInput'] = None,
        sum: Optional['types.PlayerSumAggregateInput'] = None,
        min: Optional['types.PlayerMinAggregateInput'] = None,
        max: Optional['types.PlayerMaxAggregateInput'] = None,
        having: Optional['types.PlayerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerGroupByOutput']:
        """Group Player records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Player fields to group records by
        where
            Player filter to select records
        take
            Limit the maximum number of Player records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerGroupByOutput]
            A list of dictionaries representing the Player record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Player records by name values
        # and count how many records are in each group
        results = await Player.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GamertagHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GamertagHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GamertagHistory.prisma().query_raw(
            'SELECT * FROM GamertagHistory WHERE playerId = $1',
            'beeifcbebf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GamertagHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GamertagHistory.prisma().query_first(
            'SELECT * FROM GamertagHistory WHERE system = $1',
            enums.System.PS,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GamertagHistoryCreateInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new GamertagHistory record.

        Parameters
        ----------
        data
            GamertagHistory record data
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The created GamertagHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GamertagHistory record from just the required fields
        gamertaghistory = await GamertagHistory.prisma().create(
            data={
                # data to create a GamertagHistory record
                'playerId': 'bgcigfahea',
                'system': enums.System.PS,
                'gamertag': 'bcejgaggif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GamertagHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GamertagHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GamertagHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GamertagHistory.prisma().create_many(
            data=[
                {
                    # data to create a GamertagHistory record
                    'playerId': 'idfjadbcc',
                    'system': enums.System.PS,
                    'gamertag': 'hgdhbjhhj',
                },
                {
                    # data to create a GamertagHistory record
                    'playerId': 'ecjjjfbae',
                    'system': enums.System.PS,
                    'gamertag': 'bhhfibbigf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GamertagHistory record.

        Parameters
        ----------
        where
            GamertagHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The deleted GamertagHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().delete(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GamertagHistory record.

        Parameters
        ----------
        where
            GamertagHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The found GamertagHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().find_unique(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GamertagHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GamertagHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The found GamertagHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().find_unique_or_raise(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GamertagHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GamertagHistory records returned
        skip
            Ignore the first N results
        where
            GamertagHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GamertagHistory]
            The list of all GamertagHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GamertagHistory records
        gamertaghistorys = await GamertagHistory.prisma().find_many(take=10)

        # find the first 5 GamertagHistory records ordered by the gamertag field
        gamertaghistorys = await GamertagHistory.prisma().find_many(
            take=5,
            order={
                'gamertag': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GamertagHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GamertagHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GamertagHistory
            The first GamertagHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GamertagHistory record ordered by the createdAt field
        gamertaghistory = await GamertagHistory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GamertagHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GamertagHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GamertagHistory
            The first GamertagHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GamertagHistory record ordered by the updatedAt field
        gamertaghistory = await GamertagHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GamertagHistoryUpdateInput,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GamertagHistory record.

        Parameters
        ----------
        data
            GamertagHistory record data specifying what to update
        where
            GamertagHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The updated GamertagHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().update(
            where={
                # GamertagHistory where unique filter

            },
            data={
                # data to update the GamertagHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        data: types.GamertagHistoryUpsertInput,
        include: Optional[types.GamertagHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GamertagHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The created or updated GamertagHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().upsert(
            where={
                # GamertagHistory where unique filter
            },
            data={
                'create': {
                    # GamertagHistory data to be set if the record does not exist
                },
                'update': {
                    # GamertagHistory data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GamertagHistoryUpdateManyMutationInput,
        where: types.GamertagHistoryWhereInput,
    ) -> int:
        """Update multiple GamertagHistory records

        Parameters
        ----------
        data
            GamertagHistory data to update the selected GamertagHistory records to
        where
            Filter to select the GamertagHistory records to update

        Returns
        -------
        int
            The total number of GamertagHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GamertagHistory records
        total = await GamertagHistory.prisma().update_many(
            data={
                'verificationCode': 'ijdbeffgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GamertagHistory records present in the database

        Parameters
        ----------
        select
            Select the GamertagHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GamertagHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GamertagHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GamertagHistory.prisma().count()

        # results: prisma.types.GamertagHistoryCountAggregateOutput
        results = await GamertagHistory.prisma().count(
            select={
                '_all': True,
                'codeGeneratedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GamertagHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> types.GamertagHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GamertagHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.GamertagHistoryCountAggregateOutput]:
        """Count the number of GamertagHistory records present in the database

        Parameters
        ----------
        select
            Select the GamertagHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GamertagHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GamertagHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GamertagHistory.prisma().count()

        # results: prisma.types.GamertagHistoryCountAggregateOutput
        results = await GamertagHistory.prisma().count(
            select={
                '_all': True,
                'verificationStatus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GamertagHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GamertagHistoryWhereInput] = None
    ) -> int:
        """Delete multiple GamertagHistory records.

        Parameters
        ----------
        where
            Optional GamertagHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GamertagHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GamertagHistory records
        total = await GamertagHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GamertagHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.GamertagHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GamertagHistoryAvgAggregateInput'] = None,
        sum: Optional['types.GamertagHistorySumAggregateInput'] = None,
        min: Optional['types.GamertagHistoryMinAggregateInput'] = None,
        max: Optional['types.GamertagHistoryMaxAggregateInput'] = None,
        having: Optional['types.GamertagHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GamertagHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GamertagHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.GamertagHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.GamertagHistoryGroupByOutput']:
        """Group GamertagHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GamertagHistory fields to group records by
        where
            GamertagHistory filter to select records
        take
            Limit the maximum number of GamertagHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GamertagHistoryGroupByOutput]
            A list of dictionaries representing the GamertagHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GamertagHistory records by verifiedAt values
        # and count how many records are in each group
        results = await GamertagHistory.prisma().group_by(
            ['verifiedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Season]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Season.prisma().query_raw(
            'SELECT * FROM Season WHERE id = $1',
            'jjfeafhfj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Season
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Season.prisma().query_first(
            'SELECT * FROM Season WHERE seasonId = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SeasonCreateInput,
        include: Optional[types.SeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new Season record.

        Parameters
        ----------
        data
            Season record data
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The created Season record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Season record from just the required fields
        season = await Season.prisma().create(
            data={
                # data to create a Season record
                'seasonId': 'chbfcacbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Season records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Season record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Season.prisma().create_many(
            data=[
                {
                    # data to create a Season record
                    'seasonId': 'efggddide',
                },
                {
                    # data to create a Season record
                    'seasonId': 'caficfigfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Season record.

        Parameters
        ----------
        where
            Season filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The deleted Season record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().delete(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Season record.

        Parameters
        ----------
        where
            Season filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The found Season record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().find_unique(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Season record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Season filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The found Season record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().find_unique_or_raise(
            where={
                'id': 'bghfciaafe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Season records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Season records returned
        skip
            Ignore the first N results
        where
            Season filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Season]
            The list of all Season records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Season records
        seasons = await Season.prisma().find_many(take=10)

        # find the first 5 Season records ordered by the isLatest field
        seasons = await Season.prisma().find_many(
            take=5,
            order={
                'isLatest': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Season record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Season filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Season
            The first Season record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Season record ordered by the createdAt field
        season = await Season.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Season record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Season filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Season
            The first Season record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Season record ordered by the updatedAt field
        season = await Season.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SeasonUpdateInput,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Season record.

        Parameters
        ----------
        data
            Season record data specifying what to update
        where
            Season filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The updated Season record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        season = await Season.prisma().update(
            where={
                'id': 'bgchfhgceh',
            },
            data={
                # data to update the Season record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SeasonWhereUniqueInput,
        data: types.SeasonUpsertInput,
        include: Optional[types.SeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Season filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The created or updated Season record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().upsert(
            where={
                'id': 'cafeiaccbc',
            },
            data={
                'create': {
                    'id': 'cafeiaccbc',
                    'seasonId': 'caficfigfb',
                },
                'update': {
                    'seasonId': 'caficfigfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SeasonUpdateManyMutationInput,
        where: types.SeasonWhereInput,
    ) -> int:
        """Update multiple Season records

        Parameters
        ----------
        data
            Season data to update the selected Season records to
        where
            Filter to select the Season records to update

        Returns
        -------
        int
            The total number of Season records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Season records
        total = await Season.prisma().update_many(
            data={
                'id': 'gaddfhfh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Season records present in the database

        Parameters
        ----------
        select
            Select the Season fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Season filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Season.prisma().count()

        # results: prisma.types.SeasonCountAggregateOutput
        results = await Season.prisma().count(
            select={
                '_all': True,
                'seasonId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> types.SeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> Union[int, types.SeasonCountAggregateOutput]:
        """Count the number of Season records present in the database

        Parameters
        ----------
        select
            Select the Season fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Season filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Season.prisma().count()

        # results: prisma.types.SeasonCountAggregateOutput
        results = await Season.prisma().count(
            select={
                '_all': True,
                'isLatest': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SeasonWhereInput] = None
    ) -> int:
        """Delete multiple Season records.

        Parameters
        ----------
        where
            Optional Season filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Season records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Season records
        total = await Season.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SeasonScalarFieldKeysT'],
        *,
        where: Optional['types.SeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SeasonAvgAggregateInput'] = None,
        sum: Optional['types.SeasonSumAggregateInput'] = None,
        min: Optional['types.SeasonMinAggregateInput'] = None,
        max: Optional['types.SeasonMaxAggregateInput'] = None,
        having: Optional['types.SeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SeasonGroupByOutput']:
        """Group Season records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Season fields to group records by
        where
            Season filter to select records
        take
            Limit the maximum number of Season records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SeasonGroupByOutput]
            A list of dictionaries representing the Season record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Season records by createdAt values
        # and count how many records are in each group
        results = await Season.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TierActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tier]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tier.prisma().query_raw(
            'SELECT * FROM Tier WHERE id = $1',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tier
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tier.prisma().query_first(
            'SELECT * FROM Tier WHERE seasonId = $1',
            'bgcffadich',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TierCreateInput,
        include: Optional[types.TierInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tier record.

        Parameters
        ----------
        data
            Tier record data
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The created Tier record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tier record from just the required fields
        tier = await Tier.prisma().create(
            data={
                # data to create a Tier record
                'seasonId': 'fcbichhci',
                'leagueLevel': 1266032265,
                'name': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TierCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tier records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tier record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tier.prisma().create_many(
            data=[
                {
                    # data to create a Tier record
                    'seasonId': 'cafdaehjid',
                    'leagueLevel': 685333180,
                    'name': 'bchehecef',
                },
                {
                    # data to create a Tier record
                    'seasonId': 'jeijcbhfe',
                    'leagueLevel': 1964990155,
                    'name': 'bcciijbibg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TierWhereUniqueInput,
        include: Optional[types.TierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tier record.

        Parameters
        ----------
        where
            Tier filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The deleted Tier record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tier = await Tier.prisma().delete(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TierWhereUniqueInput,
        include: Optional[types.TierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tier record.

        Parameters
        ----------
        where
            Tier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The found Tier record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tier = await Tier.prisma().find_unique(
            where={
                'id': 'bccdfhdigc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TierWhereUniqueInput,
        include: Optional[types.TierInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tier record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The found Tier record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tier = await Tier.prisma().find_unique_or_raise(
            where={
                'id': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
        include: Optional[types.TierInclude] = None,
        order: Optional[Union[types.TierOrderByInput, List[types.TierOrderByInput]]] = None,
        distinct: Optional[List[types.TierScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tier records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tier records returned
        skip
            Ignore the first N results
        where
            Tier filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tier model
        order
            Order the returned Tier records by any field
        distinct
            Filter Tier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tier]
            The list of all Tier records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tier records
        tiers = await Tier.prisma().find_many(take=10)

        # find the first 5 Tier records ordered by the leagueLevel field
        tiers = await Tier.prisma().find_many(
            take=5,
            order={
                'leagueLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
        include: Optional[types.TierInclude] = None,
        order: Optional[Union[types.TierOrderByInput, List[types.TierOrderByInput]]] = None,
        distinct: Optional[List[types.TierScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tier record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tier model
        order
            Order the returned Tier records by any field
        distinct
            Filter Tier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tier
            The first Tier record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tier record ordered by the name field
        tier = await Tier.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
        include: Optional[types.TierInclude] = None,
        order: Optional[Union[types.TierOrderByInput, List[types.TierOrderByInput]]] = None,
        distinct: Optional[List[types.TierScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tier record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tier model
        order
            Order the returned Tier records by any field
        distinct
            Filter Tier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tier
            The first Tier record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tier record ordered by the salaryCap field
        tier = await Tier.prisma().find_first_or_raise(
            skip=1,
            order={
                'salaryCap': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TierUpdateInput,
        where: types.TierWhereUniqueInput,
        include: Optional[types.TierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tier record.

        Parameters
        ----------
        data
            Tier record data specifying what to update
        where
            Tier filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The updated Tier record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tier = await Tier.prisma().update(
            where={
                'id': 'bageiegghg',
            },
            data={
                # data to update the Tier record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TierWhereUniqueInput,
        data: types.TierUpsertInput,
        include: Optional[types.TierInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tier filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tier model

        Returns
        -------
        prisma.models.Tier
            The created or updated Tier record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tier = await Tier.prisma().upsert(
            where={
                'id': 'faidicegb',
            },
            data={
                'create': {
                    'id': 'faidicegb',
                    'seasonId': 'jeijcbhfe',
                    'leagueLevel': 1964990155,
                    'name': 'bcciijbibg',
                },
                'update': {
                    'seasonId': 'jeijcbhfe',
                    'leagueLevel': 1964990155,
                    'name': 'bcciijbibg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TierUpdateManyMutationInput,
        where: types.TierWhereInput,
    ) -> int:
        """Update multiple Tier records

        Parameters
        ----------
        data
            Tier data to update the selected Tier records to
        where
            Filter to select the Tier records to update

        Returns
        -------
        int
            The total number of Tier records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tier records
        total = await Tier.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tier records present in the database

        Parameters
        ----------
        select
            Select the Tier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tier.prisma().count()

        # results: prisma.types.TierCountAggregateOutput
        results = await Tier.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TierCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
    ) -> types.TierCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TierCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TierWhereInput] = None,
        cursor: Optional[types.TierWhereUniqueInput] = None,
    ) -> Union[int, types.TierCountAggregateOutput]:
        """Count the number of Tier records present in the database

        Parameters
        ----------
        select
            Select the Tier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tier.prisma().count()

        # results: prisma.types.TierCountAggregateOutput
        results = await Tier.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TierCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TierWhereInput] = None
    ) -> int:
        """Delete multiple Tier records.

        Parameters
        ----------
        where
            Optional Tier filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tier records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tier records
        total = await Tier.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TierScalarFieldKeysT'],
        *,
        where: Optional['types.TierWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TierAvgAggregateInput'] = None,
        sum: Optional['types.TierSumAggregateInput'] = None,
        min: Optional['types.TierMinAggregateInput'] = None,
        max: Optional['types.TierMaxAggregateInput'] = None,
        having: Optional['types.TierScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TierCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TierScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TierScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TierGroupByOutput']:
        """Group Tier records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tier fields to group records by
        where
            Tier filter to select records
        take
            Limit the maximum number of Tier records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TierGroupByOutput]
            A list of dictionaries representing the Tier record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tier records by seasonId values
        # and count how many records are in each group
        results = await Tier.prisma().group_by(
            ['seasonId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Team]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Team.prisma().query_raw(
            'SELECT * FROM Team WHERE id = $1',
            'bacecgfhbe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Team
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Team.prisma().query_first(
            'SELECT * FROM Team WHERE eaClubId = $1',
            'ihcahiead',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamCreateInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Create a new Team record.

        Parameters
        ----------
        data
            Team record data
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created Team record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Team record from just the required fields
        team = await Team.prisma().create(
            data={
                # data to create a Team record
                'eaClubId': 'biheheiajg',
                'eaClubName': 'jbgijghgb',
                'officialName': 'hgjcghfbi',
                'teamIdentifier': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Team records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Team record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Team.prisma().create_many(
            data=[
                {
                    # data to create a Team record
                    'eaClubId': 'jchciaee',
                    'eaClubName': 'deeificjd',
                    'officialName': 'bbcbhebbda',
                    'teamIdentifier': 'bejfijgcfb',
                },
                {
                    # data to create a Team record
                    'eaClubId': 'caifcbgii',
                    'eaClubName': 'igaibbfgj',
                    'officialName': 'bggajdcbbi',
                    'teamIdentifier': 'fcfhgbjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Team record.

        Parameters
        ----------
        where
            Team filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The deleted Team record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().delete(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Team record.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Team record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique_or_raise(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Team records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N results
        where
            Team filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Team]
            The list of all Team records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Team records
        teams = await Team.prisma().find_many(take=10)

        # find the first 5 Team records ordered by the eaClubName field
        teams = await Team.prisma().find_many(
            take=5,
            order={
                'eaClubName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Team record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the officialName field
        team = await Team.prisma().find_first(
            skip=1,
            order={
                'officialName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Team record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the teamIdentifier field
        team = await Team.prisma().find_first_or_raise(
            skip=1,
            order={
                'teamIdentifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamUpdateInput,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Team record.

        Parameters
        ----------
        data
            Team record data specifying what to update
        where
            Team filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The updated Team record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        team = await Team.prisma().update(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                # data to update the Team record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamWhereUniqueInput,
        data: types.TeamUpsertInput,
        include: Optional[types.TeamInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Team filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created or updated Team record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().upsert(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                'create': {
                    'id': 'bjafcgbffc',
                    'eaClubId': 'caifcbgii',
                    'eaClubName': 'igaibbfgj',
                    'officialName': 'bggajdcbbi',
                    'teamIdentifier': 'fcfhgbjed',
                },
                'update': {
                    'eaClubId': 'caifcbgii',
                    'eaClubName': 'igaibbfgj',
                    'officialName': 'bggajdcbbi',
                    'teamIdentifier': 'fcfhgbjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamUpdateManyMutationInput,
        where: types.TeamWhereInput,
    ) -> int:
        """Update multiple Team records

        Parameters
        ----------
        data
            Team data to update the selected Team records to
        where
            Filter to select the Team records to update

        Returns
        -------
        int
            The total number of Team records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Team records
        total = await Team.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> types.TeamCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> Union[int, types.TeamCountAggregateOutput]:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'nhlAffiliateId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamWhereInput] = None
    ) -> int:
        """Delete multiple Team records.

        Parameters
        ----------
        where
            Optional Team filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Team records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Team records
        total = await Team.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamScalarFieldKeysT'],
        *,
        where: Optional['types.TeamWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamAvgAggregateInput'] = None,
        sum: Optional['types.TeamSumAggregateInput'] = None,
        min: Optional['types.TeamMinAggregateInput'] = None,
        max: Optional['types.TeamMaxAggregateInput'] = None,
        having: Optional['types.TeamScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamGroupByOutput']:
        """Group Team records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Team fields to group records by
        where
            Team filter to select records
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamGroupByOutput]
            A list of dictionaries representing the Team record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Team records by ahlAffiliateId values
        # and count how many records are in each group
        results = await Team.prisma().group_by(
            ['ahlAffiliateId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TeamSeason.prisma().query_raw(
            'SELECT * FROM TeamSeason WHERE id = $1',
            'hihegjif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TeamSeason.prisma().query_first(
            'SELECT * FROM TeamSeason WHERE teamId = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamSeasonCreateInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamSeason record.

        Parameters
        ----------
        data
            TeamSeason record data
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The created TeamSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamSeason record from just the required fields
        teamseason = await TeamSeason.prisma().create(
            data={
                # data to create a TeamSeason record
                'teamId': 'ifgaaagff',
                'tierId': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TeamSeason.prisma().create_many(
            data=[
                {
                    # data to create a TeamSeason record
                    'teamId': 'bfhdbjjgfd',
                    'tierId': 'cabdjadaji',
                },
                {
                    # data to create a TeamSeason record
                    'teamId': 'faajgfadf',
                    'tierId': 'biaagcedjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamSeason record.

        Parameters
        ----------
        where
            TeamSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The deleted TeamSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().delete(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamSeason record.

        Parameters
        ----------
        where
            TeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The found TeamSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().find_unique(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The found TeamSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().find_unique_or_raise(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamSeason records returned
        skip
            Ignore the first N results
        where
            TeamSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamSeason]
            The list of all TeamSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamSeason records
        teamseasons = await TeamSeason.prisma().find_many(take=10)

        # find the first 5 TeamSeason records ordered by the tierId field
        teamseasons = await TeamSeason.prisma().find_many(
            take=5,
            order={
                'tierId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamSeason
            The first TeamSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamSeason record ordered by the forwardCount field
        teamseason = await TeamSeason.prisma().find_first(
            skip=1,
            order={
                'forwardCount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamSeason
            The first TeamSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamSeason record ordered by the defenseCount field
        teamseason = await TeamSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'defenseCount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamSeasonUpdateInput,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamSeason record.

        Parameters
        ----------
        data
            TeamSeason record data specifying what to update
        where
            TeamSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The updated TeamSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().update(
            where={
                'id': 'beehgcebbg',
            },
            data={
                # data to update the TeamSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        data: types.TeamSeasonUpsertInput,
        include: Optional[types.TeamSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The created or updated TeamSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().upsert(
            where={
                'id': 'bhdiaidiaf',
            },
            data={
                'create': {
                    'id': 'bhdiaidiaf',
                    'teamId': 'faajgfadf',
                    'tierId': 'biaagcedjc',
                },
                'update': {
                    'teamId': 'faajgfadf',
                    'tierId': 'biaagcedjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamSeasonUpdateManyMutationInput,
        where: types.TeamSeasonWhereInput,
    ) -> int:
        """Update multiple TeamSeason records

        Parameters
        ----------
        data
            TeamSeason data to update the selected TeamSeason records to
        where
            Filter to select the TeamSeason records to update

        Returns
        -------
        int
            The total number of TeamSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamSeason records
        total = await TeamSeason.prisma().update_many(
            data={
                'goalieCount': 340946258
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamSeason records present in the database

        Parameters
        ----------
        select
            Select the TeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamSeason.prisma().count()

        # results: prisma.types.TeamSeasonCountAggregateOutput
        results = await TeamSeason.prisma().count(
            select={
                '_all': True,
                'wins': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> types.TeamSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.TeamSeasonCountAggregateOutput]:
        """Count the number of TeamSeason records present in the database

        Parameters
        ----------
        select
            Select the TeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamSeason.prisma().count()

        # results: prisma.types.TeamSeasonCountAggregateOutput
        results = await TeamSeason.prisma().count(
            select={
                '_all': True,
                'losses': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamSeasonWhereInput] = None
    ) -> int:
        """Delete multiple TeamSeason records.

        Parameters
        ----------
        where
            Optional TeamSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamSeason records
        total = await TeamSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.TeamSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamSeasonAvgAggregateInput'] = None,
        sum: Optional['types.TeamSeasonSumAggregateInput'] = None,
        min: Optional['types.TeamSeasonMinAggregateInput'] = None,
        max: Optional['types.TeamSeasonMaxAggregateInput'] = None,
        having: Optional['types.TeamSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamSeasonGroupByOutput']:
        """Group TeamSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamSeason fields to group records by
        where
            TeamSeason filter to select records
        take
            Limit the maximum number of TeamSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamSeasonGroupByOutput]
            A list of dictionaries representing the TeamSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamSeason records by otLosses values
        # and count how many records are in each group
        results = await TeamSeason.prisma().group_by(
            ['otLosses'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerSeason.prisma().query_raw(
            'SELECT * FROM PlayerSeason WHERE id = $1',
            'gabahhhjf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerSeason.prisma().query_first(
            'SELECT * FROM PlayerSeason WHERE playerId = $1',
            'cjagadcjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerSeasonCreateInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerSeason record.

        Parameters
        ----------
        data
            PlayerSeason record data
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The created PlayerSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerSeason record from just the required fields
        playerseason = await PlayerSeason.prisma().create(
            data={
                # data to create a PlayerSeason record
                'playerId': 'bifficggej',
                'seasonId': 'bgbbaajbic',
                'contractId': 'eegghdhjb',
                'position': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerSeason.prisma().create_many(
            data=[
                {
                    # data to create a PlayerSeason record
                    'playerId': 'gdcgcgagj',
                    'seasonId': 'bhceabbgja',
                    'contractId': 'ehabfhegh',
                    'position': 'bcajcajjbc',
                },
                {
                    # data to create a PlayerSeason record
                    'playerId': 'bfdgheeegf',
                    'seasonId': 'ececbijji',
                    'contractId': 'cbcfgdcdhf',
                    'position': 'fdgjfbhia',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerSeason record.

        Parameters
        ----------
        where
            PlayerSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The deleted PlayerSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().delete(
            where={
                'id': 'jcehcdchh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerSeason record.

        Parameters
        ----------
        where
            PlayerSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The found PlayerSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().find_unique(
            where={
                'id': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The found PlayerSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().find_unique_or_raise(
            where={
                'id': 'bieiidcabj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerSeason records returned
        skip
            Ignore the first N results
        where
            PlayerSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerSeason]
            The list of all PlayerSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerSeason records
        playerseasons = await PlayerSeason.prisma().find_many(take=10)

        # find the first 5 PlayerSeason records ordered by the seasonId field
        playerseasons = await PlayerSeason.prisma().find_many(
            take=5,
            order={
                'seasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerSeason
            The first PlayerSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerSeason record ordered by the contractId field
        playerseason = await PlayerSeason.prisma().find_first(
            skip=1,
            order={
                'contractId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerSeason
            The first PlayerSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerSeason record ordered by the position field
        playerseason = await PlayerSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'position': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerSeasonUpdateInput,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerSeason record.

        Parameters
        ----------
        data
            PlayerSeason record data specifying what to update
        where
            PlayerSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The updated PlayerSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().update(
            where={
                'id': 'bjcbfcieaa',
            },
            data={
                # data to update the PlayerSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        data: types.PlayerSeasonUpsertInput,
        include: Optional[types.PlayerSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The created or updated PlayerSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().upsert(
            where={
                'id': 'cbaaechiej',
            },
            data={
                'create': {
                    'id': 'cbaaechiej',
                    'playerId': 'bfdgheeegf',
                    'seasonId': 'ececbijji',
                    'contractId': 'cbcfgdcdhf',
                    'position': 'fdgjfbhia',
                },
                'update': {
                    'playerId': 'bfdgheeegf',
                    'seasonId': 'ececbijji',
                    'contractId': 'cbcfgdcdhf',
                    'position': 'fdgjfbhia',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerSeasonUpdateManyMutationInput,
        where: types.PlayerSeasonWhereInput,
    ) -> int:
        """Update multiple PlayerSeason records

        Parameters
        ----------
        data
            PlayerSeason data to update the selected PlayerSeason records to
        where
            Filter to select the PlayerSeason records to update

        Returns
        -------
        int
            The total number of PlayerSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerSeason records
        total = await PlayerSeason.prisma().update_many(
            data={
                'gamesPlayed': 849140046
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerSeason.prisma().count()

        # results: prisma.types.PlayerSeasonCountAggregateOutput
        results = await PlayerSeason.prisma().count(
            select={
                '_all': True,
                'goals': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> types.PlayerSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerSeasonCountAggregateOutput]:
        """Count the number of PlayerSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerSeason.prisma().count()

        # results: prisma.types.PlayerSeasonCountAggregateOutput
        results = await PlayerSeason.prisma().count(
            select={
                '_all': True,
                'assists': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerSeasonWhereInput] = None
    ) -> int:
        """Delete multiple PlayerSeason records.

        Parameters
        ----------
        where
            Optional PlayerSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerSeason records
        total = await PlayerSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerSeasonAvgAggregateInput'] = None,
        sum: Optional['types.PlayerSeasonSumAggregateInput'] = None,
        min: Optional['types.PlayerSeasonMinAggregateInput'] = None,
        max: Optional['types.PlayerSeasonMaxAggregateInput'] = None,
        having: Optional['types.PlayerSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerSeasonGroupByOutput']:
        """Group PlayerSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerSeason fields to group records by
        where
            PlayerSeason filter to select records
        take
            Limit the maximum number of PlayerSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerSeasonGroupByOutput]
            A list of dictionaries representing the PlayerSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerSeason records by plusMinus values
        # and count how many records are in each group
        results = await PlayerSeason.prisma().group_by(
            ['plusMinus'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerTierHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerTierHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerTierHistory.prisma().query_raw(
            'SELECT * FROM PlayerTierHistory WHERE id = $1',
            'jcibfcbhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerTierHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerTierHistory.prisma().query_first(
            'SELECT * FROM PlayerTierHistory WHERE playerSeasonId = $1',
            'chdadcaga',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerTierHistoryCreateInput,
        include: Optional[types.PlayerTierHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerTierHistory record.

        Parameters
        ----------
        data
            PlayerTierHistory record data
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The created PlayerTierHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerTierHistory record from just the required fields
        playertierhistory = await PlayerTierHistory.prisma().create(
            data={
                # data to create a PlayerTierHistory record
                'playerSeasonId': 'jicieifbh',
                'tierId': 'fbahdheji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerTierHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerTierHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerTierHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerTierHistory.prisma().create_many(
            data=[
                {
                    # data to create a PlayerTierHistory record
                    'playerSeasonId': 'cbbheiicgh',
                    'tierId': 'beabjeejdg',
                },
                {
                    # data to create a PlayerTierHistory record
                    'playerSeasonId': 'bcjhgahffd',
                    'tierId': 'fbjeiiffa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerTierHistoryWhereUniqueInput,
        include: Optional[types.PlayerTierHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerTierHistory record.

        Parameters
        ----------
        where
            PlayerTierHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The deleted PlayerTierHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playertierhistory = await PlayerTierHistory.prisma().delete(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerTierHistoryWhereUniqueInput,
        include: Optional[types.PlayerTierHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerTierHistory record.

        Parameters
        ----------
        where
            PlayerTierHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The found PlayerTierHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playertierhistory = await PlayerTierHistory.prisma().find_unique(
            where={
                'id': 'bgjgecfejc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerTierHistoryWhereUniqueInput,
        include: Optional[types.PlayerTierHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerTierHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerTierHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The found PlayerTierHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playertierhistory = await PlayerTierHistory.prisma().find_unique_or_raise(
            where={
                'id': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerTierHistoryInclude] = None,
        order: Optional[Union[types.PlayerTierHistoryOrderByInput, List[types.PlayerTierHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTierHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerTierHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerTierHistory records returned
        skip
            Ignore the first N results
        where
            PlayerTierHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model
        order
            Order the returned PlayerTierHistory records by any field
        distinct
            Filter PlayerTierHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerTierHistory]
            The list of all PlayerTierHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerTierHistory records
        playertierhistorys = await PlayerTierHistory.prisma().find_many(take=10)

        # find the first 5 PlayerTierHistory records ordered by the tierId field
        playertierhistorys = await PlayerTierHistory.prisma().find_many(
            take=5,
            order={
                'tierId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerTierHistoryInclude] = None,
        order: Optional[Union[types.PlayerTierHistoryOrderByInput, List[types.PlayerTierHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTierHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerTierHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTierHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model
        order
            Order the returned PlayerTierHistory records by any field
        distinct
            Filter PlayerTierHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTierHistory
            The first PlayerTierHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTierHistory record ordered by the startDate field
        playertierhistory = await PlayerTierHistory.prisma().find_first(
            skip=1,
            order={
                'startDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerTierHistoryInclude] = None,
        order: Optional[Union[types.PlayerTierHistoryOrderByInput, List[types.PlayerTierHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTierHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerTierHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTierHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model
        order
            Order the returned PlayerTierHistory records by any field
        distinct
            Filter PlayerTierHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTierHistory
            The first PlayerTierHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTierHistory record ordered by the endDate field
        playertierhistory = await PlayerTierHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'endDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerTierHistoryUpdateInput,
        where: types.PlayerTierHistoryWhereUniqueInput,
        include: Optional[types.PlayerTierHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerTierHistory record.

        Parameters
        ----------
        data
            PlayerTierHistory record data specifying what to update
        where
            PlayerTierHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The updated PlayerTierHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playertierhistory = await PlayerTierHistory.prisma().update(
            where={
                'id': 'bacdaibgfa',
            },
            data={
                # data to update the PlayerTierHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerTierHistoryWhereUniqueInput,
        data: types.PlayerTierHistoryUpsertInput,
        include: Optional[types.PlayerTierHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerTierHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerTierHistory model

        Returns
        -------
        prisma.models.PlayerTierHistory
            The created or updated PlayerTierHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playertierhistory = await PlayerTierHistory.prisma().upsert(
            where={
                'id': 'dchgibach',
            },
            data={
                'create': {
                    'id': 'dchgibach',
                    'playerSeasonId': 'bcjhgahffd',
                    'tierId': 'fbjeiiffa',
                },
                'update': {
                    'playerSeasonId': 'bcjhgahffd',
                    'tierId': 'fbjeiiffa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerTierHistoryUpdateManyMutationInput,
        where: types.PlayerTierHistoryWhereInput,
    ) -> int:
        """Update multiple PlayerTierHistory records

        Parameters
        ----------
        data
            PlayerTierHistory data to update the selected PlayerTierHistory records to
        where
            Filter to select the PlayerTierHistory records to update

        Returns
        -------
        int
            The total number of PlayerTierHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerTierHistory records
        total = await PlayerTierHistory.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerTierHistory records present in the database

        Parameters
        ----------
        select
            Select the PlayerTierHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTierHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTierHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTierHistory.prisma().count()

        # results: prisma.types.PlayerTierHistoryCountAggregateOutput
        results = await PlayerTierHistory.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerTierHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
    ) -> types.PlayerTierHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerTierHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTierHistoryWhereInput] = None,
        cursor: Optional[types.PlayerTierHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerTierHistoryCountAggregateOutput]:
        """Count the number of PlayerTierHistory records present in the database

        Parameters
        ----------
        select
            Select the PlayerTierHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTierHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTierHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTierHistory.prisma().count()

        # results: prisma.types.PlayerTierHistoryCountAggregateOutput
        results = await PlayerTierHistory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerTierHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerTierHistoryWhereInput] = None
    ) -> int:
        """Delete multiple PlayerTierHistory records.

        Parameters
        ----------
        where
            Optional PlayerTierHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerTierHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerTierHistory records
        total = await PlayerTierHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerTierHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerTierHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerTierHistoryAvgAggregateInput'] = None,
        sum: Optional['types.PlayerTierHistorySumAggregateInput'] = None,
        min: Optional['types.PlayerTierHistoryMinAggregateInput'] = None,
        max: Optional['types.PlayerTierHistoryMaxAggregateInput'] = None,
        having: Optional['types.PlayerTierHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerTierHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerTierHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerTierHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerTierHistoryGroupByOutput']:
        """Group PlayerTierHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerTierHistory fields to group records by
        where
            PlayerTierHistory filter to select records
        take
            Limit the maximum number of PlayerTierHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerTierHistoryGroupByOutput]
            A list of dictionaries representing the PlayerTierHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerTierHistory records by playerSeasonId values
        # and count how many records are in each group
        results = await PlayerTierHistory.prisma().group_by(
            ['playerSeasonId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerTeamSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerTeamSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerTeamSeason.prisma().query_raw(
            'SELECT * FROM PlayerTeamSeason WHERE id = $1',
            'fchheijjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerTeamSeason.prisma().query_first(
            'SELECT * FROM PlayerTeamSeason WHERE playerSeasonId = $1',
            'cacjdfhejh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerTeamSeasonCreateInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerTeamSeason record.

        Parameters
        ----------
        data
            PlayerTeamSeason record data
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The created PlayerTeamSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerTeamSeason record from just the required fields
        playerteamseason = await PlayerTeamSeason.prisma().create(
            data={
                # data to create a PlayerTeamSeason record
                'playerSeasonId': 'bdbifjhbbi',
                'teamSeasonId': 'cbccbbcdfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerTeamSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerTeamSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerTeamSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerTeamSeason.prisma().create_many(
            data=[
                {
                    # data to create a PlayerTeamSeason record
                    'playerSeasonId': 'bacejedaca',
                    'teamSeasonId': 'bhbhdahfaj',
                },
                {
                    # data to create a PlayerTeamSeason record
                    'playerSeasonId': 'bfjibceaec',
                    'teamSeasonId': 'ibhgcdbgd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerTeamSeason record.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The deleted PlayerTeamSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().delete(
            where={
                'id': 'badaffhddg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerTeamSeason record.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The found PlayerTeamSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().find_unique(
            where={
                'id': 'bbdbfcfihd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerTeamSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The found PlayerTeamSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().find_unique_or_raise(
            where={
                'id': 'cbagggbji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerTeamSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerTeamSeason records returned
        skip
            Ignore the first N results
        where
            PlayerTeamSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerTeamSeason]
            The list of all PlayerTeamSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerTeamSeason records
        playerteamseasons = await PlayerTeamSeason.prisma().find_many(take=10)

        # find the first 5 PlayerTeamSeason records ordered by the teamSeasonId field
        playerteamseasons = await PlayerTeamSeason.prisma().find_many(
            take=5,
            order={
                'teamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerTeamSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first PlayerTeamSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTeamSeason record ordered by the assists field
        playerteamseason = await PlayerTeamSeason.prisma().find_first(
            skip=1,
            order={
                'assists': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerTeamSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first PlayerTeamSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTeamSeason record ordered by the gamesPlayed field
        playerteamseason = await PlayerTeamSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'gamesPlayed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerTeamSeasonUpdateInput,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerTeamSeason record.

        Parameters
        ----------
        data
            PlayerTeamSeason record data specifying what to update
        where
            PlayerTeamSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The updated PlayerTeamSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().update(
            where={
                'id': 'bchgafhjed',
            },
            data={
                # data to update the PlayerTeamSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        data: types.PlayerTeamSeasonUpsertInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerTeamSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The created or updated PlayerTeamSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().upsert(
            where={
                'id': 'heffgjdei',
            },
            data={
                'create': {
                    'id': 'heffgjdei',
                    'playerSeasonId': 'bfjibceaec',
                    'teamSeasonId': 'ibhgcdbgd',
                },
                'update': {
                    'playerSeasonId': 'bfjibceaec',
                    'teamSeasonId': 'ibhgcdbgd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerTeamSeasonUpdateManyMutationInput,
        where: types.PlayerTeamSeasonWhereInput,
    ) -> int:
        """Update multiple PlayerTeamSeason records

        Parameters
        ----------
        data
            PlayerTeamSeason data to update the selected PlayerTeamSeason records to
        where
            Filter to select the PlayerTeamSeason records to update

        Returns
        -------
        int
            The total number of PlayerTeamSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerTeamSeason records
        total = await PlayerTeamSeason.prisma().update_many(
            data={
                'giveaways': 307876141
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerTeamSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerTeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTeamSeason.prisma().count()

        # results: prisma.types.PlayerTeamSeasonCountAggregateOutput
        results = await PlayerTeamSeason.prisma().count(
            select={
                '_all': True,
                'goals': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerTeamSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> types.PlayerTeamSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerTeamSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerTeamSeasonCountAggregateOutput]:
        """Count the number of PlayerTeamSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerTeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTeamSeason.prisma().count()

        # results: prisma.types.PlayerTeamSeasonCountAggregateOutput
        results = await PlayerTeamSeason.prisma().count(
            select={
                '_all': True,
                'hits': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerTeamSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None
    ) -> int:
        """Delete multiple PlayerTeamSeason records.

        Parameters
        ----------
        where
            Optional PlayerTeamSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerTeamSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerTeamSeason records
        total = await PlayerTeamSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerTeamSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerTeamSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerTeamSeasonAvgAggregateInput'] = None,
        sum: Optional['types.PlayerTeamSeasonSumAggregateInput'] = None,
        min: Optional['types.PlayerTeamSeasonMinAggregateInput'] = None,
        max: Optional['types.PlayerTeamSeasonMaxAggregateInput'] = None,
        having: Optional['types.PlayerTeamSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerTeamSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerTeamSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerTeamSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerTeamSeasonGroupByOutput']:
        """Group PlayerTeamSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerTeamSeason fields to group records by
        where
            PlayerTeamSeason filter to select records
        take
            Limit the maximum number of PlayerTeamSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerTeamSeasonGroupByOutput]
            A list of dictionaries representing the PlayerTeamSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerTeamSeason records by penaltyMinutes values
        # and count how many records are in each group
        results = await PlayerTeamSeason.prisma().group_by(
            ['penaltyMinutes'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContractActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contract]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Contract.prisma().query_raw(
            'SELECT * FROM Contract WHERE id = $1',
            'bgheaejbcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contract
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Contract.prisma().query_first(
            'SELECT * FROM Contract WHERE amount = $1',
            1526854643,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContractCreateInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contract record.

        Parameters
        ----------
        data
            Contract record data
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created Contract record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contract record from just the required fields
        contract = await Contract.prisma().create(
            data={
                # data to create a Contract record
                'amount': 958077104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContractCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contract records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contract record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Contract.prisma().create_many(
            data=[
                {
                    # data to create a Contract record
                    'amount': 1513050921,
                },
                {
                    # data to create a Contract record
                    'amount': 204674734,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contract record.

        Parameters
        ----------
        where
            Contract filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The deleted Contract record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().delete(
            where={
                'id': 'caghgfbggd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contract record.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique(
            where={
                'id': 'bbidjbbjaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Contract record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique_or_raise(
            where={
                'id': 'bfijhaejdd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contract records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N results
        where
            Contract filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contract]
            The list of all Contract records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contract records
        contracts = await Contract.prisma().find_many(take=10)

        # find the first 5 Contract records ordered by the createdAt field
        contracts = await Contract.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contract record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the updatedAt field
        contract = await Contract.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Contract record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the id field
        contract = await Contract.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContractUpdateInput,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contract record.

        Parameters
        ----------
        data
            Contract record data specifying what to update
        where
            Contract filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The updated Contract record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contract = await Contract.prisma().update(
            where={
                'id': 'bcedehfiji',
            },
            data={
                # data to update the Contract record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContractWhereUniqueInput,
        data: types.ContractUpsertInput,
        include: Optional[types.ContractInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contract filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created or updated Contract record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().upsert(
            where={
                'id': 'bdgjicijhb',
            },
            data={
                'create': {
                    'id': 'bdgjicijhb',
                    'amount': 204674734,
                },
                'update': {
                    'amount': 204674734,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContractUpdateManyMutationInput,
        where: types.ContractWhereInput,
    ) -> int:
        """Update multiple Contract records

        Parameters
        ----------
        data
            Contract data to update the selected Contract records to
        where
            Filter to select the Contract records to update

        Returns
        -------
        int
            The total number of Contract records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contract records
        total = await Contract.prisma().update_many(
            data={
                'amount': 1678593480
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContractCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> types.ContractCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContractCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> Union[int, types.ContractCountAggregateOutput]:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContractCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContractWhereInput] = None
    ) -> int:
        """Delete multiple Contract records.

        Parameters
        ----------
        where
            Optional Contract filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contract records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contract records
        total = await Contract.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContractScalarFieldKeysT'],
        *,
        where: Optional['types.ContractWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContractAvgAggregateInput'] = None,
        sum: Optional['types.ContractSumAggregateInput'] = None,
        min: Optional['types.ContractMinAggregateInput'] = None,
        max: Optional['types.ContractMaxAggregateInput'] = None,
        having: Optional['types.ContractScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContractCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContractScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ContractScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ContractGroupByOutput']:
        """Group Contract records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contract fields to group records by
        where
            Contract filter to select records
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContractGroupByOutput]
            A list of dictionaries representing the Contract record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contract records by id values
        # and count how many records are in each group
        results = await Contract.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BidActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Bid]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Bid.prisma().query_raw(
            'SELECT * FROM Bid WHERE id = $1',
            'eadfcbbcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Bid
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Bid.prisma().query_first(
            'SELECT * FROM Bid WHERE contractId = $1',
            'geihgahba',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BidCreateInput,
        include: Optional[types.BidInclude] = None
    ) -> _PrismaModelT:
        """Create a new Bid record.

        Parameters
        ----------
        data
            Bid record data
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The created Bid record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Bid record from just the required fields
        bid = await Bid.prisma().create(
            data={
                # data to create a Bid record
                'contractId': 'gahdcdhbj',
                'teamSeasonId': 'begiijahea',
                'amount': 629039005,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BidCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Bid records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Bid record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Bid.prisma().create_many(
            data=[
                {
                    # data to create a Bid record
                    'contractId': 'bcbebgiaic',
                    'teamSeasonId': 'ijigbdcbj',
                    'amount': 658378208,
                },
                {
                    # data to create a Bid record
                    'contractId': 'jfegcaafh',
                    'teamSeasonId': 'bcbeiajjfa',
                    'amount': 1047820095,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Bid record.

        Parameters
        ----------
        where
            Bid filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The deleted Bid record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().delete(
            where={
                'id': 'bdachdeiga',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Bid record.

        Parameters
        ----------
        where
            Bid filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The found Bid record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().find_unique(
            where={
                'id': 'ijdafccef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Bid record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Bid filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The found Bid record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().find_unique_or_raise(
            where={
                'id': 'ciaaiddag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Bid records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Bid records returned
        skip
            Ignore the first N results
        where
            Bid filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Bid]
            The list of all Bid records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Bid records
        bids = await Bid.prisma().find_many(take=10)

        # find the first 5 Bid records ordered by the teamSeasonId field
        bids = await Bid.prisma().find_many(
            take=5,
            order={
                'teamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Bid record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Bid filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Bid
            The first Bid record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Bid record ordered by the amount field
        bid = await Bid.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Bid record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Bid filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Bid
            The first Bid record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Bid record ordered by the status field
        bid = await Bid.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BidUpdateInput,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Bid record.

        Parameters
        ----------
        data
            Bid record data specifying what to update
        where
            Bid filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The updated Bid record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bid = await Bid.prisma().update(
            where={
                'id': 'fejggijff',
            },
            data={
                # data to update the Bid record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BidWhereUniqueInput,
        data: types.BidUpsertInput,
        include: Optional[types.BidInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Bid filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The created or updated Bid record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().upsert(
            where={
                'id': 'hghjaaai',
            },
            data={
                'create': {
                    'id': 'hghjaaai',
                    'contractId': 'jfegcaafh',
                    'teamSeasonId': 'bcbeiajjfa',
                    'amount': 1047820095,
                },
                'update': {
                    'contractId': 'jfegcaafh',
                    'teamSeasonId': 'bcbeiajjfa',
                    'amount': 1047820095,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BidUpdateManyMutationInput,
        where: types.BidWhereInput,
    ) -> int:
        """Update multiple Bid records

        Parameters
        ----------
        data
            Bid data to update the selected Bid records to
        where
            Filter to select the Bid records to update

        Returns
        -------
        int
            The total number of Bid records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Bid records
        total = await Bid.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Bid records present in the database

        Parameters
        ----------
        select
            Select the Bid fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Bid filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BidCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Bid.prisma().count()

        # results: prisma.types.BidCountAggregateOutput
        results = await Bid.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BidCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> types.BidCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BidCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> Union[int, types.BidCountAggregateOutput]:
        """Count the number of Bid records present in the database

        Parameters
        ----------
        select
            Select the Bid fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Bid filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BidCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Bid.prisma().count()

        # results: prisma.types.BidCountAggregateOutput
        results = await Bid.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BidCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BidWhereInput] = None
    ) -> int:
        """Delete multiple Bid records.

        Parameters
        ----------
        where
            Optional Bid filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Bid records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Bid records
        total = await Bid.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BidScalarFieldKeysT'],
        *,
        where: Optional['types.BidWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BidAvgAggregateInput'] = None,
        sum: Optional['types.BidSumAggregateInput'] = None,
        min: Optional['types.BidMinAggregateInput'] = None,
        max: Optional['types.BidMaxAggregateInput'] = None,
        having: Optional['types.BidScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BidCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BidScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BidScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BidGroupByOutput']:
        """Group Bid records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Bid fields to group records by
        where
            Bid filter to select records
        take
            Limit the maximum number of Bid records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BidGroupByOutput]
            A list of dictionaries representing the Bid record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Bid records by contractId values
        # and count how many records are in each group
        results = await Bid.prisma().group_by(
            ['contractId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MatchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Match]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Match.prisma().query_raw(
            'SELECT * FROM Match WHERE id = $1',
            'cajicjjdef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Match
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Match.prisma().query_first(
            'SELECT * FROM Match WHERE teamSeasonId = $1',
            'cefjaadec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MatchCreateInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Create a new Match record.

        Parameters
        ----------
        data
            Match record data
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created Match record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Match record from just the required fields
        match = await Match.prisma().create(
            data={
                # data to create a Match record
                'teamSeasonId': 'ibbigdigd',
                'eaMatchId': 'bdiiiabbii',
                'goalsAgainst': 752577037,
                'goalsFor': 1187663298,
                'opponentClubId': 'hgjgibdgd',
                'opponentTeamId': 'bcbecjfice',
                'penaltyKillGoalsAgainst': 1021417993,
                'penaltyKillOpportunities': 351503374,
                'powerplayGoals': 1321184815,
                'powerplayOpportunities': 369732668,
                'shots': 1191235013,
                'shotsAgainst': 627561242,
                'timeOnAttack': 1872952907,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MatchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Match records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Match record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Match.prisma().create_many(
            data=[
                {
                    # data to create a Match record
                    'teamSeasonId': 'bhjdcicaii',
                    'eaMatchId': 'bibedjhcej',
                    'goalsAgainst': 1923090150,
                    'goalsFor': 1277244455,
                    'opponentClubId': 'bbgaifhdaa',
                    'opponentTeamId': 'dgbcdaegb',
                    'penaltyKillGoalsAgainst': 1406511986,
                    'penaltyKillOpportunities': 1482877891,
                    'powerplayGoals': 566623296,
                    'powerplayOpportunities': 229119865,
                    'shots': 1750011070,
                    'shotsAgainst': 410943775,
                    'timeOnAttack': 909024364,
                },
                {
                    # data to create a Match record
                    'teamSeasonId': 'hffgbabgf',
                    'eaMatchId': 'biacbiieja',
                    'goalsAgainst': 294916155,
                    'goalsFor': 564073304,
                    'opponentClubId': 'diageigcf',
                    'opponentTeamId': 'badagbgeha',
                    'penaltyKillGoalsAgainst': 816411927,
                    'penaltyKillOpportunities': 1084099844,
                    'powerplayGoals': 1079702253,
                    'powerplayOpportunities': 755750178,
                    'shots': 1128680371,
                    'shotsAgainst': 259061104,
                    'timeOnAttack': 1115738345,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Match record.

        Parameters
        ----------
        where
            Match filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The deleted Match record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().delete(
            where={
                'id': 'bdadhibhec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Match record.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().find_unique(
            where={
                'id': 'bfhdjaiejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Match record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().find_unique_or_raise(
            where={
                'id': 'bbjfijjadg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Match records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N results
        where
            Match filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Match]
            The list of all Match records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Match records
        matchs = await Match.prisma().find_many(take=10)

        # find the first 5 Match records ordered by the eaMatchId field
        matchs = await Match.prisma().find_many(
            take=5,
            order={
                'eaMatchId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Match record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the goalsAgainst field
        match = await Match.prisma().find_first(
            skip=1,
            order={
                'goalsAgainst': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Match record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the goalsFor field
        match = await Match.prisma().find_first_or_raise(
            skip=1,
            order={
                'goalsFor': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MatchUpdateInput,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Match record.

        Parameters
        ----------
        data
            Match record data specifying what to update
        where
            Match filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The updated Match record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        match = await Match.prisma().update(
            where={
                'id': 'hdjacbehh',
            },
            data={
                # data to update the Match record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MatchWhereUniqueInput,
        data: types.MatchUpsertInput,
        include: Optional[types.MatchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Match filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created or updated Match record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().upsert(
            where={
                'id': 'bhcccbeaba',
            },
            data={
                'create': {
                    'id': 'bhcccbeaba',
                    'teamSeasonId': 'hffgbabgf',
                    'eaMatchId': 'biacbiieja',
                    'goalsAgainst': 294916155,
                    'goalsFor': 564073304,
                    'opponentClubId': 'diageigcf',
                    'opponentTeamId': 'badagbgeha',
                    'penaltyKillGoalsAgainst': 816411927,
                    'penaltyKillOpportunities': 1084099844,
                    'powerplayGoals': 1079702253,
                    'powerplayOpportunities': 755750178,
                    'shots': 1128680371,
                    'shotsAgainst': 259061104,
                    'timeOnAttack': 1115738345,
                },
                'update': {
                    'teamSeasonId': 'hffgbabgf',
                    'eaMatchId': 'biacbiieja',
                    'goalsAgainst': 294916155,
                    'goalsFor': 564073304,
                    'opponentClubId': 'diageigcf',
                    'opponentTeamId': 'badagbgeha',
                    'penaltyKillGoalsAgainst': 816411927,
                    'penaltyKillOpportunities': 1084099844,
                    'powerplayGoals': 1079702253,
                    'powerplayOpportunities': 755750178,
                    'shots': 1128680371,
                    'shotsAgainst': 259061104,
                    'timeOnAttack': 1115738345,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MatchUpdateManyMutationInput,
        where: types.MatchWhereInput,
    ) -> int:
        """Update multiple Match records

        Parameters
        ----------
        data
            Match data to update the selected Match records to
        where
            Filter to select the Match records to update

        Returns
        -------
        int
            The total number of Match records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Match records
        total = await Match.prisma().update_many(
            data={
                'opponentClubId': 'bcgjbdgjdj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = await Match.prisma().count(
            select={
                '_all': True,
                'opponentTeamId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MatchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> types.MatchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MatchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> Union[int, types.MatchCountAggregateOutput]:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = await Match.prisma().count(
            select={
                '_all': True,
                'penaltyKillGoalsAgainst': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MatchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MatchWhereInput] = None
    ) -> int:
        """Delete multiple Match records.

        Parameters
        ----------
        where
            Optional Match filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Match records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Match records
        total = await Match.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MatchScalarFieldKeysT'],
        *,
        where: Optional['types.MatchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MatchAvgAggregateInput'] = None,
        sum: Optional['types.MatchSumAggregateInput'] = None,
        min: Optional['types.MatchMinAggregateInput'] = None,
        max: Optional['types.MatchMaxAggregateInput'] = None,
        having: Optional['types.MatchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MatchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MatchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.MatchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.MatchGroupByOutput']:
        """Group Match records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Match fields to group records by
        where
            Match filter to select records
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MatchGroupByOutput]
            A list of dictionaries representing the Match record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Match records by penaltyKillOpportunities values
        # and count how many records are in each group
        results = await Match.prisma().group_by(
            ['penaltyKillOpportunities'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerMatchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerMatch]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerMatch.prisma().query_raw(
            'SELECT * FROM PlayerMatch WHERE id = $1',
            'fhdbhifae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerMatch
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerMatch.prisma().query_first(
            'SELECT * FROM PlayerMatch WHERE matchId = $1',
            'beeacgfcej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerMatchCreateInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerMatch record.

        Parameters
        ----------
        data
            PlayerMatch record data
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The created PlayerMatch record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerMatch record from just the required fields
        playermatch = await PlayerMatch.prisma().create(
            data={
                # data to create a PlayerMatch record
                'matchId': 'bbifhdiicc',
                'playerTeamSeasonId': 'bgjeccejad',
                'assists': 1906360116,
                'giveaways': 1911255389,
                'goals': 146262738,
                'hits': 1719240611,
                'penaltyMinutes': 1948555936,
                'plusMinus': 1383253593,
                'ratingDefense': 354664990.64716,
                'ratingOffense': 357089484.61239,
                'ratingTeamplay': 1808130602.115174,
                'shots': 78060984,
                'takeaways': 444983185,
                'timeOnIce': 45610742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerMatchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerMatch records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerMatch record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerMatch.prisma().create_many(
            data=[
                {
                    # data to create a PlayerMatch record
                    'matchId': 'hgjaiebfb',
                    'playerTeamSeasonId': 'bddefjjabc',
                    'assists': 1116761037,
                    'giveaways': 1172606082,
                    'goals': 330014611,
                    'hits': 1768156112,
                    'penaltyMinutes': 71628745,
                    'plusMinus': 55766734,
                    'ratingDefense': 812032495.132356,
                    'ratingOffense': 43796357.134553,
                    'ratingTeamplay': 1965387275.80487,
                    'shots': 1566496513,
                    'takeaways': 850004390,
                    'timeOnIce': 2109399015,
                },
                {
                    # data to create a PlayerMatch record
                    'matchId': 'bcicggedea',
                    'playerTeamSeasonId': 'cebcdadjh',
                    'assists': 475863602,
                    'giveaways': 1716228995,
                    'goals': 1869736192,
                    'hits': 1585341753,
                    'penaltyMinutes': 29271934,
                    'plusMinus': 1588192479,
                    'ratingDefense': 898405676.77746,
                    'ratingOffense': 437894538.39334,
                    'ratingTeamplay': 163829784.24815,
                    'shots': 341715030,
                    'takeaways': 1692766423,
                    'timeOnIce': 86662596,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerMatch record.

        Parameters
        ----------
        where
            PlayerMatch filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The deleted PlayerMatch record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().delete(
            where={
                'id': 'bgjhijffjh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerMatch record.

        Parameters
        ----------
        where
            PlayerMatch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The found PlayerMatch record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().find_unique(
            where={
                'id': 'bcigdhache',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerMatch record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerMatch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The found PlayerMatch record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().find_unique_or_raise(
            where={
                'id': 'igefhgdhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerMatch records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerMatch records returned
        skip
            Ignore the first N results
        where
            PlayerMatch filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerMatch]
            The list of all PlayerMatch records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerMatch records
        playermatchs = await PlayerMatch.prisma().find_many(take=10)

        # find the first 5 PlayerMatch records ordered by the playerTeamSeasonId field
        playermatchs = await PlayerMatch.prisma().find_many(
            take=5,
            order={
                'playerTeamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerMatch record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerMatch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerMatch
            The first PlayerMatch record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerMatch record ordered by the assists field
        playermatch = await PlayerMatch.prisma().find_first(
            skip=1,
            order={
                'assists': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerMatch record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerMatch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerMatch
            The first PlayerMatch record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerMatch record ordered by the giveaways field
        playermatch = await PlayerMatch.prisma().find_first_or_raise(
            skip=1,
            order={
                'giveaways': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerMatchUpdateInput,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerMatch record.

        Parameters
        ----------
        data
            PlayerMatch record data specifying what to update
        where
            PlayerMatch filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The updated PlayerMatch record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().update(
            where={
                'id': 'ejbiifbae',
            },
            data={
                # data to update the PlayerMatch record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        data: types.PlayerMatchUpsertInput,
        include: Optional[types.PlayerMatchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerMatch filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The created or updated PlayerMatch record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().upsert(
            where={
                'id': 'djcfgedjd',
            },
            data={
                'create': {
                    'id': 'djcfgedjd',
                    'matchId': 'bcicggedea',
                    'playerTeamSeasonId': 'cebcdadjh',
                    'assists': 475863602,
                    'giveaways': 1716228995,
                    'goals': 1869736192,
                    'hits': 1585341753,
                    'penaltyMinutes': 29271934,
                    'plusMinus': 1588192479,
                    'ratingDefense': 898405676.77746,
                    'ratingOffense': 437894538.39334,
                    'ratingTeamplay': 163829784.24815,
                    'shots': 341715030,
                    'takeaways': 1692766423,
                    'timeOnIce': 86662596,
                },
                'update': {
                    'matchId': 'bcicggedea',
                    'playerTeamSeasonId': 'cebcdadjh',
                    'assists': 475863602,
                    'giveaways': 1716228995,
                    'goals': 1869736192,
                    'hits': 1585341753,
                    'penaltyMinutes': 29271934,
                    'plusMinus': 1588192479,
                    'ratingDefense': 898405676.77746,
                    'ratingOffense': 437894538.39334,
                    'ratingTeamplay': 163829784.24815,
                    'shots': 341715030,
                    'takeaways': 1692766423,
                    'timeOnIce': 86662596,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerMatchUpdateManyMutationInput,
        where: types.PlayerMatchWhereInput,
    ) -> int:
        """Update multiple PlayerMatch records

        Parameters
        ----------
        data
            PlayerMatch data to update the selected PlayerMatch records to
        where
            Filter to select the PlayerMatch records to update

        Returns
        -------
        int
            The total number of PlayerMatch records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerMatch records
        total = await PlayerMatch.prisma().update_many(
            data={
                'goals': 1319234606
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerMatch records present in the database

        Parameters
        ----------
        select
            Select the PlayerMatch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerMatch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerMatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerMatch.prisma().count()

        # results: prisma.types.PlayerMatchCountAggregateOutput
        results = await PlayerMatch.prisma().count(
            select={
                '_all': True,
                'hits': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerMatchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> types.PlayerMatchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerMatchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerMatchCountAggregateOutput]:
        """Count the number of PlayerMatch records present in the database

        Parameters
        ----------
        select
            Select the PlayerMatch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerMatch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerMatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerMatch.prisma().count()

        # results: prisma.types.PlayerMatchCountAggregateOutput
        results = await PlayerMatch.prisma().count(
            select={
                '_all': True,
                'penaltyMinutes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerMatchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerMatchWhereInput] = None
    ) -> int:
        """Delete multiple PlayerMatch records.

        Parameters
        ----------
        where
            Optional PlayerMatch filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerMatch records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerMatch records
        total = await PlayerMatch.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerMatchScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerMatchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerMatchAvgAggregateInput'] = None,
        sum: Optional['types.PlayerMatchSumAggregateInput'] = None,
        min: Optional['types.PlayerMatchMinAggregateInput'] = None,
        max: Optional['types.PlayerMatchMaxAggregateInput'] = None,
        having: Optional['types.PlayerMatchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerMatchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerMatchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerMatchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerMatchGroupByOutput']:
        """Group PlayerMatch records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerMatch fields to group records by
        where
            PlayerMatch filter to select records
        take
            Limit the maximum number of PlayerMatch records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerMatchGroupByOutput]
            A list of dictionaries representing the PlayerMatch record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerMatch records by plusMinus values
        # and count how many records are in each group
        results = await PlayerMatch.prisma().group_by(
            ['plusMinus'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            'hbchfebch',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            'bcjjffegfc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 'cahaeaicjd',
                'type': enums.NotificationType.SYSTEM,
                'title': 'ibbjaacbi',
                'message': 'djgacbcch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 'geeeegace',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bbgdigchd',
                    'message': 'dajcifgdi',
                },
                {
                    # data to create a Notification record
                    'userId': 'ccedhdbj',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bjaabjjjce',
                    'message': 'cafhdcdcjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 'bdeebbhbdi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 'cafcbdchah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 'bdffbehbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the type field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the title field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the message field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 'ieahjgeb',
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 'hfeeddceg',
            },
            data={
                'create': {
                    'id': 'hfeeddceg',
                    'userId': 'ccedhdbj',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bjaabjjjce',
                    'message': 'cafhdcdcjd',
                },
                'update': {
                    'userId': 'ccedhdbj',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bjaabjjjce',
                    'message': 'cafhdcdcjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'status': enums.NotificationStatus.UNREAD
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'link': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeysT'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by createdAt values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumPostActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumPost]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumPost.prisma().query_raw(
            'SELECT * FROM ForumPost WHERE id = $1',
            'dbecgbbid',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumPost
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumPost.prisma().query_first(
            'SELECT * FROM ForumPost WHERE title = $1',
            'cchghigae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumPostCreateInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumPost record.

        Parameters
        ----------
        data
            ForumPost record data
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The created ForumPost record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumPost record from just the required fields
        forumpost = await ForumPost.prisma().create(
            data={
                # data to create a ForumPost record
                'title': 'ecdjjjhab',
                'content': 'biachfede',
                'authorId': 'fhgaibff',
                'leagueId': 'cadajbcbca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumPostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumPost records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumPost record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumPost.prisma().create_many(
            data=[
                {
                    # data to create a ForumPost record
                    'title': 'bjheigfcdd',
                    'content': 'bjejigcdcg',
                    'authorId': 'bifiiibcah',
                    'leagueId': 'dbjibjdaa',
                },
                {
                    # data to create a ForumPost record
                    'title': 'dgijbdiaf',
                    'content': 'begfaigba',
                    'authorId': 'bdjiafcgjb',
                    'leagueId': 'bficecgcfg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumPost record.

        Parameters
        ----------
        where
            ForumPost filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The deleted ForumPost record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().delete(
            where={
                'id': 'cbjjeedcj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumPost record.

        Parameters
        ----------
        where
            ForumPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The found ForumPost record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().find_unique(
            where={
                'id': 'dedgbbhja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumPost record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The found ForumPost record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().find_unique_or_raise(
            where={
                'id': 'cabiahchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumPost records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumPost records returned
        skip
            Ignore the first N results
        where
            ForumPost filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumPost]
            The list of all ForumPost records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumPost records
        forumposts = await ForumPost.prisma().find_many(take=10)

        # find the first 5 ForumPost records ordered by the content field
        forumposts = await ForumPost.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumPost record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPost
            The first ForumPost record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPost record ordered by the status field
        forumpost = await ForumPost.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumPost record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPost
            The first ForumPost record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPost record ordered by the authorId field
        forumpost = await ForumPost.prisma().find_first_or_raise(
            skip=1,
            order={
                'authorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumPostUpdateInput,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumPost record.

        Parameters
        ----------
        data
            ForumPost record data specifying what to update
        where
            ForumPost filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The updated ForumPost record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().update(
            where={
                'id': 'cgbeccfce',
            },
            data={
                # data to update the ForumPost record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumPostWhereUniqueInput,
        data: types.ForumPostUpsertInput,
        include: Optional[types.ForumPostInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumPost filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The created or updated ForumPost record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().upsert(
            where={
                'id': 'fcjcagef',
            },
            data={
                'create': {
                    'id': 'fcjcagef',
                    'title': 'dgijbdiaf',
                    'content': 'begfaigba',
                    'authorId': 'bdjiafcgjb',
                    'leagueId': 'bficecgcfg',
                },
                'update': {
                    'title': 'dgijbdiaf',
                    'content': 'begfaigba',
                    'authorId': 'bdjiafcgjb',
                    'leagueId': 'bficecgcfg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumPostUpdateManyMutationInput,
        where: types.ForumPostWhereInput,
    ) -> int:
        """Update multiple ForumPost records

        Parameters
        ----------
        data
            ForumPost data to update the selected ForumPost records to
        where
            Filter to select the ForumPost records to update

        Returns
        -------
        int
            The total number of ForumPost records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumPost records
        total = await ForumPost.prisma().update_many(
            data={
                'leagueId': 'bgdhaeacic'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumPost records present in the database

        Parameters
        ----------
        select
            Select the ForumPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPost.prisma().count()

        # results: prisma.types.ForumPostCountAggregateOutput
        results = await ForumPost.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumPostCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> types.ForumPostCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumPostCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> Union[int, types.ForumPostCountAggregateOutput]:
        """Count the number of ForumPost records present in the database

        Parameters
        ----------
        select
            Select the ForumPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPost.prisma().count()

        # results: prisma.types.ForumPostCountAggregateOutput
        results = await ForumPost.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumPostCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumPostWhereInput] = None
    ) -> int:
        """Delete multiple ForumPost records.

        Parameters
        ----------
        where
            Optional ForumPost filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumPost records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumPost records
        total = await ForumPost.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumPostScalarFieldKeysT'],
        *,
        where: Optional['types.ForumPostWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumPostAvgAggregateInput'] = None,
        sum: Optional['types.ForumPostSumAggregateInput'] = None,
        min: Optional['types.ForumPostMinAggregateInput'] = None,
        max: Optional['types.ForumPostMaxAggregateInput'] = None,
        having: Optional['types.ForumPostScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumPostCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumPostScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumPostScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumPostGroupByOutput']:
        """Group ForumPost records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumPost fields to group records by
        where
            ForumPost filter to select records
        take
            Limit the maximum number of ForumPost records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumPostGroupByOutput]
            A list of dictionaries representing the ForumPost record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumPost records by gif values
        # and count how many records are in each group
        results = await ForumPost.prisma().group_by(
            ['gif'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumReactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumReaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumReaction.prisma().query_raw(
            'SELECT * FROM ForumReaction WHERE id = $1',
            'caffafcheh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumReaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumReaction.prisma().query_first(
            'SELECT * FROM ForumReaction WHERE type = $1',
            enums.ReactionType.LIKE,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumReactionCreateInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumReaction record.

        Parameters
        ----------
        data
            ForumReaction record data
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The created ForumReaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumReaction record from just the required fields
        forumreaction = await ForumReaction.prisma().create(
            data={
                # data to create a ForumReaction record
                'type': enums.ReactionType.LIKE,
                'userId': 'fjjbegge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumReactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumReaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumReaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumReaction.prisma().create_many(
            data=[
                {
                    # data to create a ForumReaction record
                    'type': enums.ReactionType.LIKE,
                    'userId': 'bdiifhbieb',
                },
                {
                    # data to create a ForumReaction record
                    'type': enums.ReactionType.LIKE,
                    'userId': 'cdcaejhgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumReaction record.

        Parameters
        ----------
        where
            ForumReaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The deleted ForumReaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().delete(
            where={
                'id': 'jbijgfbfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumReaction record.

        Parameters
        ----------
        where
            ForumReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The found ForumReaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().find_unique(
            where={
                'id': 'ggfbeddia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumReaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The found ForumReaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().find_unique_or_raise(
            where={
                'id': 'djjejdaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumReaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumReaction records returned
        skip
            Ignore the first N results
        where
            ForumReaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumReaction]
            The list of all ForumReaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumReaction records
        forumreactions = await ForumReaction.prisma().find_many(take=10)

        # find the first 5 ForumReaction records ordered by the userId field
        forumreactions = await ForumReaction.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumReaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumReaction
            The first ForumReaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumReaction record ordered by the postId field
        forumreaction = await ForumReaction.prisma().find_first(
            skip=1,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumReaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumReaction
            The first ForumReaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumReaction record ordered by the commentId field
        forumreaction = await ForumReaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'commentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumReactionUpdateInput,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumReaction record.

        Parameters
        ----------
        data
            ForumReaction record data specifying what to update
        where
            ForumReaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The updated ForumReaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().update(
            where={
                'id': 'bjabbfceji',
            },
            data={
                # data to update the ForumReaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumReactionWhereUniqueInput,
        data: types.ForumReactionUpsertInput,
        include: Optional[types.ForumReactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumReaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The created or updated ForumReaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().upsert(
            where={
                'id': 'bgchfbjibb',
            },
            data={
                'create': {
                    'id': 'bgchfbjibb',
                    'type': enums.ReactionType.LIKE,
                    'userId': 'cdcaejhgg',
                },
                'update': {
                    'type': enums.ReactionType.LIKE,
                    'userId': 'cdcaejhgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumReactionUpdateManyMutationInput,
        where: types.ForumReactionWhereInput,
    ) -> int:
        """Update multiple ForumReaction records

        Parameters
        ----------
        data
            ForumReaction data to update the selected ForumReaction records to
        where
            Filter to select the ForumReaction records to update

        Returns
        -------
        int
            The total number of ForumReaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumReaction records
        total = await ForumReaction.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumReaction records present in the database

        Parameters
        ----------
        select
            Select the ForumReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumReaction.prisma().count()

        # results: prisma.types.ForumReactionCountAggregateOutput
        results = await ForumReaction.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumReactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> types.ForumReactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumReactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> Union[int, types.ForumReactionCountAggregateOutput]:
        """Count the number of ForumReaction records present in the database

        Parameters
        ----------
        select
            Select the ForumReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumReaction.prisma().count()

        # results: prisma.types.ForumReactionCountAggregateOutput
        results = await ForumReaction.prisma().count(
            select={
                '_all': True,
                'type': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumReactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumReactionWhereInput] = None
    ) -> int:
        """Delete multiple ForumReaction records.

        Parameters
        ----------
        where
            Optional ForumReaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumReaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumReaction records
        total = await ForumReaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumReactionScalarFieldKeysT'],
        *,
        where: Optional['types.ForumReactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumReactionAvgAggregateInput'] = None,
        sum: Optional['types.ForumReactionSumAggregateInput'] = None,
        min: Optional['types.ForumReactionMinAggregateInput'] = None,
        max: Optional['types.ForumReactionMaxAggregateInput'] = None,
        having: Optional['types.ForumReactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumReactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumReactionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumReactionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumReactionGroupByOutput']:
        """Group ForumReaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumReaction fields to group records by
        where
            ForumReaction filter to select records
        take
            Limit the maximum number of ForumReaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumReactionGroupByOutput]
            A list of dictionaries representing the ForumReaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumReaction records by userId values
        # and count how many records are in each group
        results = await ForumReaction.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumFollowerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumFollower]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumFollower.prisma().query_raw(
            'SELECT * FROM ForumFollower WHERE id = $1',
            'bajecchdjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumFollower
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumFollower.prisma().query_first(
            'SELECT * FROM ForumFollower WHERE userId = $1',
            'dfgacajif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumFollowerCreateInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumFollower record.

        Parameters
        ----------
        data
            ForumFollower record data
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The created ForumFollower record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumFollower record from just the required fields
        forumfollower = await ForumFollower.prisma().create(
            data={
                # data to create a ForumFollower record
                'userId': 'bgdiddfadi',
                'postId': 'bijbfghhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumFollowerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumFollower records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumFollower record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumFollower.prisma().create_many(
            data=[
                {
                    # data to create a ForumFollower record
                    'userId': 'bahchhihdc',
                    'postId': 'bihjdcibib',
                },
                {
                    # data to create a ForumFollower record
                    'userId': 'bfhhjbbdha',
                    'postId': 'faehcjfdb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumFollower record.

        Parameters
        ----------
        where
            ForumFollower filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The deleted ForumFollower record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().delete(
            where={
                'id': 'bbaiefbee',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumFollower record.

        Parameters
        ----------
        where
            ForumFollower filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The found ForumFollower record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().find_unique(
            where={
                'id': 'bdaacgjbaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumFollower record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumFollower filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The found ForumFollower record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().find_unique_or_raise(
            where={
                'id': 'biibaighec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumFollower records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumFollower records returned
        skip
            Ignore the first N results
        where
            ForumFollower filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumFollower]
            The list of all ForumFollower records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumFollower records
        forumfollowers = await ForumFollower.prisma().find_many(take=10)

        # find the first 5 ForumFollower records ordered by the postId field
        forumfollowers = await ForumFollower.prisma().find_many(
            take=5,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumFollower record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumFollower filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumFollower
            The first ForumFollower record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumFollower record ordered by the createdAt field
        forumfollower = await ForumFollower.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumFollower record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumFollower filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumFollower
            The first ForumFollower record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumFollower record ordered by the id field
        forumfollower = await ForumFollower.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumFollowerUpdateInput,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumFollower record.

        Parameters
        ----------
        data
            ForumFollower record data specifying what to update
        where
            ForumFollower filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The updated ForumFollower record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().update(
            where={
                'id': 'baicdfeidj',
            },
            data={
                # data to update the ForumFollower record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        data: types.ForumFollowerUpsertInput,
        include: Optional[types.ForumFollowerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumFollower filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The created or updated ForumFollower record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().upsert(
            where={
                'id': 'befgiciadg',
            },
            data={
                'create': {
                    'id': 'befgiciadg',
                    'userId': 'bfhhjbbdha',
                    'postId': 'faehcjfdb',
                },
                'update': {
                    'userId': 'bfhhjbbdha',
                    'postId': 'faehcjfdb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumFollowerUpdateManyMutationInput,
        where: types.ForumFollowerWhereInput,
    ) -> int:
        """Update multiple ForumFollower records

        Parameters
        ----------
        data
            ForumFollower data to update the selected ForumFollower records to
        where
            Filter to select the ForumFollower records to update

        Returns
        -------
        int
            The total number of ForumFollower records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumFollower records
        total = await ForumFollower.prisma().update_many(
            data={
                'userId': 'cbcehahedh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumFollower records present in the database

        Parameters
        ----------
        select
            Select the ForumFollower fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumFollower filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumFollowerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumFollower.prisma().count()

        # results: prisma.types.ForumFollowerCountAggregateOutput
        results = await ForumFollower.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumFollowerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> types.ForumFollowerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumFollowerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> Union[int, types.ForumFollowerCountAggregateOutput]:
        """Count the number of ForumFollower records present in the database

        Parameters
        ----------
        select
            Select the ForumFollower fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumFollower filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumFollowerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumFollower.prisma().count()

        # results: prisma.types.ForumFollowerCountAggregateOutput
        results = await ForumFollower.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumFollowerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumFollowerWhereInput] = None
    ) -> int:
        """Delete multiple ForumFollower records.

        Parameters
        ----------
        where
            Optional ForumFollower filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumFollower records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumFollower records
        total = await ForumFollower.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumFollowerScalarFieldKeysT'],
        *,
        where: Optional['types.ForumFollowerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumFollowerAvgAggregateInput'] = None,
        sum: Optional['types.ForumFollowerSumAggregateInput'] = None,
        min: Optional['types.ForumFollowerMinAggregateInput'] = None,
        max: Optional['types.ForumFollowerMaxAggregateInput'] = None,
        having: Optional['types.ForumFollowerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumFollowerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumFollowerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumFollowerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumFollowerGroupByOutput']:
        """Group ForumFollower records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumFollower fields to group records by
        where
            ForumFollower filter to select records
        take
            Limit the maximum number of ForumFollower records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumFollowerGroupByOutput]
            A list of dictionaries representing the ForumFollower record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumFollower records by id values
        # and count how many records are in each group
        results = await ForumFollower.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumPostSubscriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumPostSubscription]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumPostSubscription.prisma().query_raw(
            'SELECT * FROM ForumPostSubscription WHERE id = $1',
            'bcjihiaide',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumPostSubscription.prisma().query_first(
            'SELECT * FROM ForumPostSubscription WHERE userId = $1',
            'bagfijcgfj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumPostSubscriptionCreateInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumPostSubscription record.

        Parameters
        ----------
        data
            ForumPostSubscription record data
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The created ForumPostSubscription record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumPostSubscription record from just the required fields
        forumpostsubscription = await ForumPostSubscription.prisma().create(
            data={
                # data to create a ForumPostSubscription record
                'userId': 'bcggehiidc',
                'postId': 'bjcdacgacf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumPostSubscriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumPostSubscription records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumPostSubscription record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumPostSubscription.prisma().create_many(
            data=[
                {
                    # data to create a ForumPostSubscription record
                    'userId': 'jfieeahi',
                    'postId': 'bijfjbddfj',
                },
                {
                    # data to create a ForumPostSubscription record
                    'userId': 'cdcdjdcee',
                    'postId': 'bbbgjdbgcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumPostSubscription record.

        Parameters
        ----------
        where
            ForumPostSubscription filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The deleted ForumPostSubscription record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().delete(
            where={
                'id': 'bcedacgecg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumPostSubscription record.

        Parameters
        ----------
        where
            ForumPostSubscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The found ForumPostSubscription record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().find_unique(
            where={
                'id': 'cbdffjeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumPostSubscription record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumPostSubscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The found ForumPostSubscription record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().find_unique_or_raise(
            where={
                'id': 'idbcdhbci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumPostSubscription records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumPostSubscription records returned
        skip
            Ignore the first N results
        where
            ForumPostSubscription filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumPostSubscription]
            The list of all ForumPostSubscription records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumPostSubscription records
        forumpostsubscriptions = await ForumPostSubscription.prisma().find_many(take=10)

        # find the first 5 ForumPostSubscription records ordered by the postId field
        forumpostsubscriptions = await ForumPostSubscription.prisma().find_many(
            take=5,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumPostSubscription record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first ForumPostSubscription record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPostSubscription record ordered by the createdAt field
        forumpostsubscription = await ForumPostSubscription.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumPostSubscription record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first ForumPostSubscription record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPostSubscription record ordered by the id field
        forumpostsubscription = await ForumPostSubscription.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumPostSubscriptionUpdateInput,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumPostSubscription record.

        Parameters
        ----------
        data
            ForumPostSubscription record data specifying what to update
        where
            ForumPostSubscription filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The updated ForumPostSubscription record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().update(
            where={
                'id': 'bacegehahd',
            },
            data={
                # data to update the ForumPostSubscription record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        data: types.ForumPostSubscriptionUpsertInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumPostSubscription filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The created or updated ForumPostSubscription record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().upsert(
            where={
                'id': 'ebedeihec',
            },
            data={
                'create': {
                    'id': 'ebedeihec',
                    'userId': 'cdcdjdcee',
                    'postId': 'bbbgjdbgcb',
                },
                'update': {
                    'userId': 'cdcdjdcee',
                    'postId': 'bbbgjdbgcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumPostSubscriptionUpdateManyMutationInput,
        where: types.ForumPostSubscriptionWhereInput,
    ) -> int:
        """Update multiple ForumPostSubscription records

        Parameters
        ----------
        data
            ForumPostSubscription data to update the selected ForumPostSubscription records to
        where
            Filter to select the ForumPostSubscription records to update

        Returns
        -------
        int
            The total number of ForumPostSubscription records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumPostSubscription records
        total = await ForumPostSubscription.prisma().update_many(
            data={
                'userId': 'bajagjdfbb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumPostSubscription records present in the database

        Parameters
        ----------
        select
            Select the ForumPostSubscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostSubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPostSubscription.prisma().count()

        # results: prisma.types.ForumPostSubscriptionCountAggregateOutput
        results = await ForumPostSubscription.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumPostSubscriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> types.ForumPostSubscriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumPostSubscriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> Union[int, types.ForumPostSubscriptionCountAggregateOutput]:
        """Count the number of ForumPostSubscription records present in the database

        Parameters
        ----------
        select
            Select the ForumPostSubscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostSubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPostSubscription.prisma().count()

        # results: prisma.types.ForumPostSubscriptionCountAggregateOutput
        results = await ForumPostSubscription.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumPostSubscriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None
    ) -> int:
        """Delete multiple ForumPostSubscription records.

        Parameters
        ----------
        where
            Optional ForumPostSubscription filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumPostSubscription records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumPostSubscription records
        total = await ForumPostSubscription.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumPostSubscriptionScalarFieldKeysT'],
        *,
        where: Optional['types.ForumPostSubscriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumPostSubscriptionAvgAggregateInput'] = None,
        sum: Optional['types.ForumPostSubscriptionSumAggregateInput'] = None,
        min: Optional['types.ForumPostSubscriptionMinAggregateInput'] = None,
        max: Optional['types.ForumPostSubscriptionMaxAggregateInput'] = None,
        having: Optional['types.ForumPostSubscriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumPostSubscriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumPostSubscriptionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumPostSubscriptionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumPostSubscriptionGroupByOutput']:
        """Group ForumPostSubscription records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumPostSubscription fields to group records by
        where
            ForumPostSubscription filter to select records
        take
            Limit the maximum number of ForumPostSubscription records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumPostSubscriptionGroupByOutput]
            A list of dictionaries representing the ForumPostSubscription record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumPostSubscription records by id values
        # and count how many records are in each group
        results = await ForumPostSubscription.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumCommentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumComment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumComment.prisma().query_raw(
            'SELECT * FROM ForumComment WHERE id = $1',
            'bggedbjggi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumComment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumComment.prisma().query_first(
            'SELECT * FROM ForumComment WHERE content = $1',
            'hgbafifcf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumCommentCreateInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumComment record.

        Parameters
        ----------
        data
            ForumComment record data
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The created ForumComment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumComment record from just the required fields
        forumcomment = await ForumComment.prisma().create(
            data={
                # data to create a ForumComment record
                'content': 'bejiecfecg',
                'authorId': 'bjgacaeagh',
                'postId': 'beeaihbefg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumCommentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumComment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumComment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumComment.prisma().create_many(
            data=[
                {
                    # data to create a ForumComment record
                    'content': 'bfbfgeddfd',
                    'authorId': 'jbgheibja',
                    'postId': 'eejajbid',
                },
                {
                    # data to create a ForumComment record
                    'content': 'efhdcdaie',
                    'authorId': 'cadejecgbd',
                    'postId': 'bahjhjjhcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumComment record.

        Parameters
        ----------
        where
            ForumComment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The deleted ForumComment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().delete(
            where={
                'id': 'ebhbhbdff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumComment record.

        Parameters
        ----------
        where
            ForumComment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The found ForumComment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().find_unique(
            where={
                'id': 'bdiefcdfhg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumComment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumComment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The found ForumComment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().find_unique_or_raise(
            where={
                'id': 'cheifeghd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumComment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumComment records returned
        skip
            Ignore the first N results
        where
            ForumComment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumComment]
            The list of all ForumComment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumComment records
        forumcomments = await ForumComment.prisma().find_many(take=10)

        # find the first 5 ForumComment records ordered by the status field
        forumcomments = await ForumComment.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumComment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumComment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumComment
            The first ForumComment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumComment record ordered by the createdAt field
        forumcomment = await ForumComment.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumComment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumComment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumComment
            The first ForumComment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumComment record ordered by the updatedAt field
        forumcomment = await ForumComment.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumCommentUpdateInput,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumComment record.

        Parameters
        ----------
        data
            ForumComment record data specifying what to update
        where
            ForumComment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The updated ForumComment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().update(
            where={
                'id': 'fgijheefe',
            },
            data={
                # data to update the ForumComment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumCommentWhereUniqueInput,
        data: types.ForumCommentUpsertInput,
        include: Optional[types.ForumCommentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumComment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The created or updated ForumComment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().upsert(
            where={
                'id': 'hcbgbhfch',
            },
            data={
                'create': {
                    'id': 'hcbgbhfch',
                    'content': 'efhdcdaie',
                    'authorId': 'cadejecgbd',
                    'postId': 'bahjhjjhcc',
                },
                'update': {
                    'content': 'efhdcdaie',
                    'authorId': 'cadejecgbd',
                    'postId': 'bahjhjjhcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumCommentUpdateManyMutationInput,
        where: types.ForumCommentWhereInput,
    ) -> int:
        """Update multiple ForumComment records

        Parameters
        ----------
        data
            ForumComment data to update the selected ForumComment records to
        where
            Filter to select the ForumComment records to update

        Returns
        -------
        int
            The total number of ForumComment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumComment records
        total = await ForumComment.prisma().update_many(
            data={
                'authorId': 'bfbbbgbfhc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumComment records present in the database

        Parameters
        ----------
        select
            Select the ForumComment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumComment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumCommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumComment.prisma().count()

        # results: prisma.types.ForumCommentCountAggregateOutput
        results = await ForumComment.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumCommentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> types.ForumCommentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumCommentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> Union[int, types.ForumCommentCountAggregateOutput]:
        """Count the number of ForumComment records present in the database

        Parameters
        ----------
        select
            Select the ForumComment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumComment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumCommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumComment.prisma().count()

        # results: prisma.types.ForumCommentCountAggregateOutput
        results = await ForumComment.prisma().count(
            select={
                '_all': True,
                'quotedCommentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumCommentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumCommentWhereInput] = None
    ) -> int:
        """Delete multiple ForumComment records.

        Parameters
        ----------
        where
            Optional ForumComment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumComment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumComment records
        total = await ForumComment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumCommentScalarFieldKeysT'],
        *,
        where: Optional['types.ForumCommentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumCommentAvgAggregateInput'] = None,
        sum: Optional['types.ForumCommentSumAggregateInput'] = None,
        min: Optional['types.ForumCommentMinAggregateInput'] = None,
        max: Optional['types.ForumCommentMaxAggregateInput'] = None,
        having: Optional['types.ForumCommentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumCommentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumCommentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumCommentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumCommentGroupByOutput']:
        """Group ForumComment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumComment fields to group records by
        where
            ForumComment filter to select records
        take
            Limit the maximum number of ForumComment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumCommentGroupByOutput]
            A list of dictionaries representing the ForumComment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumComment records by gif values
        # and count how many records are in each group
        results = await ForumComment.prisma().group_by(
            ['gif'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamManagerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamManager]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TeamManager.prisma().query_raw(
            'SELECT * FROM TeamManager WHERE id = $1',
            'ibijjdeb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamManager
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TeamManager.prisma().query_first(
            'SELECT * FROM TeamManager WHERE userId = $1',
            'caehiccddi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamManagerCreateInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamManager record.

        Parameters
        ----------
        data
            TeamManager record data
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The created TeamManager record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamManager record from just the required fields
        teammanager = await TeamManager.prisma().create(
            data={
                # data to create a TeamManager record
                'userId': 'bgcahjbafj',
                'teamId': 'bihhgeihca',
                'role': enums.TeamManagementRole.OWNER,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamManagerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamManager records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamManager record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TeamManager.prisma().create_many(
            data=[
                {
                    # data to create a TeamManager record
                    'userId': 'bdgbfahbef',
                    'teamId': 'fccjhidic',
                    'role': enums.TeamManagementRole.OWNER,
                },
                {
                    # data to create a TeamManager record
                    'userId': 'bdgfdgdaff',
                    'teamId': 'bicgeaiaga',
                    'role': enums.TeamManagementRole.OWNER,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamManager record.

        Parameters
        ----------
        where
            TeamManager filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The deleted TeamManager record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().delete(
            where={
                'id': 'fajhhafab',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamManager record.

        Parameters
        ----------
        where
            TeamManager filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The found TeamManager record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().find_unique(
            where={
                'id': 'bfeiccieec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamManager record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamManager filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The found TeamManager record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().find_unique_or_raise(
            where={
                'id': 'hciegiihf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamManager records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamManager records returned
        skip
            Ignore the first N results
        where
            TeamManager filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamManager]
            The list of all TeamManager records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamManager records
        teammanagers = await TeamManager.prisma().find_many(take=10)

        # find the first 5 TeamManager records ordered by the teamId field
        teammanagers = await TeamManager.prisma().find_many(
            take=5,
            order={
                'teamId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamManager record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamManager filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamManager
            The first TeamManager record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamManager record ordered by the role field
        teammanager = await TeamManager.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamManager record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamManager filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamManager
            The first TeamManager record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamManager record ordered by the createdAt field
        teammanager = await TeamManager.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamManagerUpdateInput,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamManager record.

        Parameters
        ----------
        data
            TeamManager record data specifying what to update
        where
            TeamManager filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The updated TeamManager record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().update(
            where={
                'id': 'bahifjfga',
            },
            data={
                # data to update the TeamManager record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamManagerWhereUniqueInput,
        data: types.TeamManagerUpsertInput,
        include: Optional[types.TeamManagerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamManager filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The created or updated TeamManager record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().upsert(
            where={
                'id': 'baebfehjaf',
            },
            data={
                'create': {
                    'id': 'baebfehjaf',
                    'userId': 'bdgfdgdaff',
                    'teamId': 'bicgeaiaga',
                    'role': enums.TeamManagementRole.OWNER,
                },
                'update': {
                    'userId': 'bdgfdgdaff',
                    'teamId': 'bicgeaiaga',
                    'role': enums.TeamManagementRole.OWNER,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamManagerUpdateManyMutationInput,
        where: types.TeamManagerWhereInput,
    ) -> int:
        """Update multiple TeamManager records

        Parameters
        ----------
        data
            TeamManager data to update the selected TeamManager records to
        where
            Filter to select the TeamManager records to update

        Returns
        -------
        int
            The total number of TeamManager records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamManager records
        total = await TeamManager.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamManager records present in the database

        Parameters
        ----------
        select
            Select the TeamManager fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamManager filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamManagerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamManager.prisma().count()

        # results: prisma.types.TeamManagerCountAggregateOutput
        results = await TeamManager.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamManagerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> types.TeamManagerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamManagerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> Union[int, types.TeamManagerCountAggregateOutput]:
        """Count the number of TeamManager records present in the database

        Parameters
        ----------
        select
            Select the TeamManager fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamManager filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamManagerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamManager.prisma().count()

        # results: prisma.types.TeamManagerCountAggregateOutput
        results = await TeamManager.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamManagerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamManagerWhereInput] = None
    ) -> int:
        """Delete multiple TeamManager records.

        Parameters
        ----------
        where
            Optional TeamManager filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamManager records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamManager records
        total = await TeamManager.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamManagerScalarFieldKeysT'],
        *,
        where: Optional['types.TeamManagerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamManagerAvgAggregateInput'] = None,
        sum: Optional['types.TeamManagerSumAggregateInput'] = None,
        min: Optional['types.TeamManagerMinAggregateInput'] = None,
        max: Optional['types.TeamManagerMaxAggregateInput'] = None,
        having: Optional['types.TeamManagerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamManagerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamManagerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamManagerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamManagerGroupByOutput']:
        """Group TeamManager records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamManager fields to group records by
        where
            TeamManager filter to select records
        take
            Limit the maximum number of TeamManager records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamManagerGroupByOutput]
            A list of dictionaries representing the TeamManager record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamManager records by teamId values
        # and count how many records are in each group
        results = await TeamManager.prisma().group_by(
            ['teamId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNProfile.prisma().query_raw(
            'SELECT * FROM PSNProfile WHERE id = $1',
            'bjchdacjfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNProfile.prisma().query_first(
            'SELECT * FROM PSNProfile WHERE userId = $1',
            'fcadcaihb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNProfileCreateInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNProfile record.

        Parameters
        ----------
        data
            PSNProfile record data
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The created PSNProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNProfile record from just the required fields
        psnprofile = await PSNProfile.prisma().create(
            data={
                # data to create a PSNProfile record
                'userId': 'bbdcibggga',
                'onlineId': 'bagbibfheb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNProfile.prisma().create_many(
            data=[
                {
                    # data to create a PSNProfile record
                    'userId': 'bidgcabjag',
                    'onlineId': 'hechjdjih',
                },
                {
                    # data to create a PSNProfile record
                    'userId': 'cgfjefhci',
                    'onlineId': 'egcidbiab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNProfile record.

        Parameters
        ----------
        where
            PSNProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The deleted PSNProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().delete(
            where={
                'id': 'cehjjfgeg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNProfile record.

        Parameters
        ----------
        where
            PSNProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The found PSNProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().find_unique(
            where={
                'id': 'hiaaaeeeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The found PSNProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().find_unique_or_raise(
            where={
                'id': 'ediajdeie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNProfile records returned
        skip
            Ignore the first N results
        where
            PSNProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNProfile]
            The list of all PSNProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNProfile records
        psnprofiles = await PSNProfile.prisma().find_many(take=10)

        # find the first 5 PSNProfile records ordered by the onlineId field
        psnprofiles = await PSNProfile.prisma().find_many(
            take=5,
            order={
                'onlineId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNProfile
            The first PSNProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNProfile record ordered by the accountId field
        psnprofile = await PSNProfile.prisma().find_first(
            skip=1,
            order={
                'accountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNProfile
            The first PSNProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNProfile record ordered by the aboutMe field
        psnprofile = await PSNProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'aboutMe': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNProfileUpdateInput,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNProfile record.

        Parameters
        ----------
        data
            PSNProfile record data specifying what to update
        where
            PSNProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The updated PSNProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().update(
            where={
                'id': 'jdgefgafd',
            },
            data={
                # data to update the PSNProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNProfileWhereUniqueInput,
        data: types.PSNProfileUpsertInput,
        include: Optional[types.PSNProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The created or updated PSNProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().upsert(
            where={
                'id': 'bhhihbfeac',
            },
            data={
                'create': {
                    'id': 'bhhihbfeac',
                    'userId': 'cgfjefhci',
                    'onlineId': 'egcidbiab',
                },
                'update': {
                    'userId': 'cgfjefhci',
                    'onlineId': 'egcidbiab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNProfileUpdateManyMutationInput,
        where: types.PSNProfileWhereInput,
    ) -> int:
        """Update multiple PSNProfile records

        Parameters
        ----------
        data
            PSNProfile data to update the selected PSNProfile records to
        where
            Filter to select the PSNProfile records to update

        Returns
        -------
        int
            The total number of PSNProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNProfile records
        total = await PSNProfile.prisma().update_many(
            data={
                'languages': ['bajegedfhj']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNProfile records present in the database

        Parameters
        ----------
        select
            Select the PSNProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNProfile.prisma().count()

        # results: prisma.types.PSNProfileCountAggregateOutput
        results = await PSNProfile.prisma().count(
            select={
                '_all': True,
                'isPlus': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> types.PSNProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> Union[int, types.PSNProfileCountAggregateOutput]:
        """Count the number of PSNProfile records present in the database

        Parameters
        ----------
        select
            Select the PSNProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNProfile.prisma().count()

        # results: prisma.types.PSNProfileCountAggregateOutput
        results = await PSNProfile.prisma().count(
            select={
                '_all': True,
                'isOfficiallyVerified': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNProfileWhereInput] = None
    ) -> int:
        """Delete multiple PSNProfile records.

        Parameters
        ----------
        where
            Optional PSNProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNProfile records
        total = await PSNProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNProfileScalarFieldKeysT'],
        *,
        where: Optional['types.PSNProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNProfileAvgAggregateInput'] = None,
        sum: Optional['types.PSNProfileSumAggregateInput'] = None,
        min: Optional['types.PSNProfileMinAggregateInput'] = None,
        max: Optional['types.PSNProfileMaxAggregateInput'] = None,
        having: Optional['types.PSNProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNProfileScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNProfileScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNProfileGroupByOutput']:
        """Group PSNProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNProfile fields to group records by
        where
            PSNProfile filter to select records
        take
            Limit the maximum number of PSNProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNProfileGroupByOutput]
            A list of dictionaries representing the PSNProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNProfile records by friendsCount values
        # and count how many records are in each group
        results = await PSNProfile.prisma().group_by(
            ['friendsCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNAvatarActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNAvatar]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNAvatar.prisma().query_raw(
            'SELECT * FROM PSNAvatar WHERE id = $1',
            'bhfjihjfhg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNAvatar
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNAvatar.prisma().query_first(
            'SELECT * FROM PSNAvatar WHERE profileId = $1',
            'iicaadeeb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNAvatarCreateInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNAvatar record.

        Parameters
        ----------
        data
            PSNAvatar record data
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The created PSNAvatar record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNAvatar record from just the required fields
        psnavatar = await PSNAvatar.prisma().create(
            data={
                # data to create a PSNAvatar record
                'profileId': 'bigjggdhac',
                'size': 'bfdbbbjhad',
                'url': 'bdibjhdici',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNAvatarCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNAvatar records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNAvatar record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNAvatar.prisma().create_many(
            data=[
                {
                    # data to create a PSNAvatar record
                    'profileId': 'bceigehcbd',
                    'size': 'caehahihfe',
                    'url': 'jjacdhech',
                },
                {
                    # data to create a PSNAvatar record
                    'profileId': 'bbbjadabjc',
                    'size': 'hhaechedd',
                    'url': 'gjjgegdic',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNAvatar record.

        Parameters
        ----------
        where
            PSNAvatar filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The deleted PSNAvatar record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().delete(
            where={
                'id': 'bijbiccd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNAvatar record.

        Parameters
        ----------
        where
            PSNAvatar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The found PSNAvatar record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().find_unique(
            where={
                'id': 'cbaagdieci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNAvatar record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNAvatar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The found PSNAvatar record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().find_unique_or_raise(
            where={
                'id': 'jchifaegj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNAvatar records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNAvatar records returned
        skip
            Ignore the first N results
        where
            PSNAvatar filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNAvatar]
            The list of all PSNAvatar records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNAvatar records
        psnavatars = await PSNAvatar.prisma().find_many(take=10)

        # find the first 5 PSNAvatar records ordered by the size field
        psnavatars = await PSNAvatar.prisma().find_many(
            take=5,
            order={
                'size': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNAvatar record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNAvatar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNAvatar
            The first PSNAvatar record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNAvatar record ordered by the url field
        psnavatar = await PSNAvatar.prisma().find_first(
            skip=1,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNAvatar record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNAvatar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNAvatar
            The first PSNAvatar record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNAvatar record ordered by the createdAt field
        psnavatar = await PSNAvatar.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNAvatarUpdateInput,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNAvatar record.

        Parameters
        ----------
        data
            PSNAvatar record data specifying what to update
        where
            PSNAvatar filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The updated PSNAvatar record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().update(
            where={
                'id': 'dhhdhfebi',
            },
            data={
                # data to update the PSNAvatar record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        data: types.PSNAvatarUpsertInput,
        include: Optional[types.PSNAvatarInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNAvatar filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The created or updated PSNAvatar record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().upsert(
            where={
                'id': 'decchddih',
            },
            data={
                'create': {
                    'id': 'decchddih',
                    'profileId': 'bbbjadabjc',
                    'size': 'hhaechedd',
                    'url': 'gjjgegdic',
                },
                'update': {
                    'profileId': 'bbbjadabjc',
                    'size': 'hhaechedd',
                    'url': 'gjjgegdic',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNAvatarUpdateManyMutationInput,
        where: types.PSNAvatarWhereInput,
    ) -> int:
        """Update multiple PSNAvatar records

        Parameters
        ----------
        data
            PSNAvatar data to update the selected PSNAvatar records to
        where
            Filter to select the PSNAvatar records to update

        Returns
        -------
        int
            The total number of PSNAvatar records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNAvatar records
        total = await PSNAvatar.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNAvatar records present in the database

        Parameters
        ----------
        select
            Select the PSNAvatar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNAvatar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNAvatarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNAvatar.prisma().count()

        # results: prisma.types.PSNAvatarCountAggregateOutput
        results = await PSNAvatar.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNAvatarCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> types.PSNAvatarCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNAvatarCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> Union[int, types.PSNAvatarCountAggregateOutput]:
        """Count the number of PSNAvatar records present in the database

        Parameters
        ----------
        select
            Select the PSNAvatar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNAvatar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNAvatarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNAvatar.prisma().count()

        # results: prisma.types.PSNAvatarCountAggregateOutput
        results = await PSNAvatar.prisma().count(
            select={
                '_all': True,
                'profileId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNAvatarCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNAvatarWhereInput] = None
    ) -> int:
        """Delete multiple PSNAvatar records.

        Parameters
        ----------
        where
            Optional PSNAvatar filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNAvatar records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNAvatar records
        total = await PSNAvatar.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNAvatarScalarFieldKeysT'],
        *,
        where: Optional['types.PSNAvatarWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNAvatarAvgAggregateInput'] = None,
        sum: Optional['types.PSNAvatarSumAggregateInput'] = None,
        min: Optional['types.PSNAvatarMinAggregateInput'] = None,
        max: Optional['types.PSNAvatarMaxAggregateInput'] = None,
        having: Optional['types.PSNAvatarScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNAvatarCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNAvatarScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNAvatarScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNAvatarGroupByOutput']:
        """Group PSNAvatar records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNAvatar fields to group records by
        where
            PSNAvatar filter to select records
        take
            Limit the maximum number of PSNAvatar records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNAvatarGroupByOutput]
            A list of dictionaries representing the PSNAvatar record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNAvatar records by size values
        # and count how many records are in each group
        results = await PSNAvatar.prisma().group_by(
            ['size'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNTrophyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNTrophy]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNTrophy.prisma().query_raw(
            'SELECT * FROM PSNTrophy WHERE id = $1',
            'bbegbdehci',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNTrophy
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNTrophy.prisma().query_first(
            'SELECT * FROM PSNTrophy WHERE profileId = $1',
            'bcebgbhhgb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNTrophyCreateInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNTrophy record.

        Parameters
        ----------
        data
            PSNTrophy record data
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The created PSNTrophy record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNTrophy record from just the required fields
        psntrophy = await PSNTrophy.prisma().create(
            data={
                # data to create a PSNTrophy record
                'profileId': 'ghegfaceg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNTrophyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNTrophy records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNTrophy record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNTrophy.prisma().create_many(
            data=[
                {
                    # data to create a PSNTrophy record
                    'profileId': 'hdeaejgah',
                },
                {
                    # data to create a PSNTrophy record
                    'profileId': 'ddiiihaci',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNTrophy record.

        Parameters
        ----------
        where
            PSNTrophy filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The deleted PSNTrophy record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().delete(
            where={
                'id': 'jdhfacdgf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNTrophy record.

        Parameters
        ----------
        where
            PSNTrophy filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The found PSNTrophy record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().find_unique(
            where={
                'id': 'fcbbahcbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNTrophy record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNTrophy filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The found PSNTrophy record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().find_unique_or_raise(
            where={
                'id': 'edcgchech',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNTrophy records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNTrophy records returned
        skip
            Ignore the first N results
        where
            PSNTrophy filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNTrophy]
            The list of all PSNTrophy records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNTrophy records
        psntrophys = await PSNTrophy.prisma().find_many(take=10)

        # find the first 5 PSNTrophy records ordered by the trophyLevel field
        psntrophys = await PSNTrophy.prisma().find_many(
            take=5,
            order={
                'trophyLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNTrophy record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNTrophy filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNTrophy
            The first PSNTrophy record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNTrophy record ordered by the progress field
        psntrophy = await PSNTrophy.prisma().find_first(
            skip=1,
            order={
                'progress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNTrophy record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNTrophy filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNTrophy
            The first PSNTrophy record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNTrophy record ordered by the tier field
        psntrophy = await PSNTrophy.prisma().find_first_or_raise(
            skip=1,
            order={
                'tier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNTrophyUpdateInput,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNTrophy record.

        Parameters
        ----------
        data
            PSNTrophy record data specifying what to update
        where
            PSNTrophy filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The updated PSNTrophy record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().update(
            where={
                'id': 'bfehccdcge',
            },
            data={
                # data to update the PSNTrophy record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        data: types.PSNTrophyUpsertInput,
        include: Optional[types.PSNTrophyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNTrophy filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The created or updated PSNTrophy record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().upsert(
            where={
                'id': 'ehcibdegf',
            },
            data={
                'create': {
                    'id': 'ehcibdegf',
                    'profileId': 'ddiiihaci',
                },
                'update': {
                    'profileId': 'ddiiihaci',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNTrophyUpdateManyMutationInput,
        where: types.PSNTrophyWhereInput,
    ) -> int:
        """Update multiple PSNTrophy records

        Parameters
        ----------
        data
            PSNTrophy data to update the selected PSNTrophy records to
        where
            Filter to select the PSNTrophy records to update

        Returns
        -------
        int
            The total number of PSNTrophy records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNTrophy records
        total = await PSNTrophy.prisma().update_many(
            data={
                'platinumCount': 417985118
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNTrophy records present in the database

        Parameters
        ----------
        select
            Select the PSNTrophy fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNTrophy filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNTrophyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNTrophy.prisma().count()

        # results: prisma.types.PSNTrophyCountAggregateOutput
        results = await PSNTrophy.prisma().count(
            select={
                '_all': True,
                'goldCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNTrophyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> types.PSNTrophyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNTrophyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> Union[int, types.PSNTrophyCountAggregateOutput]:
        """Count the number of PSNTrophy records present in the database

        Parameters
        ----------
        select
            Select the PSNTrophy fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNTrophy filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNTrophyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNTrophy.prisma().count()

        # results: prisma.types.PSNTrophyCountAggregateOutput
        results = await PSNTrophy.prisma().count(
            select={
                '_all': True,
                'silverCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNTrophyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNTrophyWhereInput] = None
    ) -> int:
        """Delete multiple PSNTrophy records.

        Parameters
        ----------
        where
            Optional PSNTrophy filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNTrophy records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNTrophy records
        total = await PSNTrophy.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNTrophyScalarFieldKeysT'],
        *,
        where: Optional['types.PSNTrophyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNTrophyAvgAggregateInput'] = None,
        sum: Optional['types.PSNTrophySumAggregateInput'] = None,
        min: Optional['types.PSNTrophyMinAggregateInput'] = None,
        max: Optional['types.PSNTrophyMaxAggregateInput'] = None,
        having: Optional['types.PSNTrophyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNTrophyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNTrophyScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNTrophyScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNTrophyGroupByOutput']:
        """Group PSNTrophy records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNTrophy fields to group records by
        where
            PSNTrophy filter to select records
        take
            Limit the maximum number of PSNTrophy records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNTrophyGroupByOutput]
            A list of dictionaries representing the PSNTrophy record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNTrophy records by bronzeCount values
        # and count how many records are in each group
        results = await PSNTrophy.prisma().group_by(
            ['bronzeCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNGameActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNGame]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNGame.prisma().query_raw(
            'SELECT * FROM PSNGame WHERE id = $1',
            'jaigficdj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNGame
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNGame.prisma().query_first(
            'SELECT * FROM PSNGame WHERE profileId = $1',
            'bggcfifgbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNGameCreateInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNGame record.

        Parameters
        ----------
        data
            PSNGame record data
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The created PSNGame record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNGame record from just the required fields
        psngame = await PSNGame.prisma().create(
            data={
                # data to create a PSNGame record
                'profileId': 'bhidfjibgf',
                'name': 'fcgdaijha',
                'titleId': 'bbgfajah',
                'platform': 'bbaecgicia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNGameCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNGame records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNGame record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNGame.prisma().create_many(
            data=[
                {
                    # data to create a PSNGame record
                    'profileId': 'hedacahfd',
                    'name': 'bhgjecjac',
                    'titleId': 'bfbdieidhf',
                    'platform': 'ffjbdcfia',
                },
                {
                    # data to create a PSNGame record
                    'profileId': 'hfeidjicb',
                    'name': 'bbfbdccdag',
                    'titleId': 'biggefaged',
                    'platform': 'gfdbeaejg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNGame record.

        Parameters
        ----------
        where
            PSNGame filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The deleted PSNGame record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().delete(
            where={
                'id': 'bhacdebcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNGame record.

        Parameters
        ----------
        where
            PSNGame filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The found PSNGame record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().find_unique(
            where={
                'id': 'jhffeibhe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNGame record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNGame filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The found PSNGame record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().find_unique_or_raise(
            where={
                'id': 'iaiieefjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNGame records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNGame records returned
        skip
            Ignore the first N results
        where
            PSNGame filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNGame]
            The list of all PSNGame records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNGame records
        psngames = await PSNGame.prisma().find_many(take=10)

        # find the first 5 PSNGame records ordered by the name field
        psngames = await PSNGame.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNGame record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGame filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGame
            The first PSNGame record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGame record ordered by the titleId field
        psngame = await PSNGame.prisma().find_first(
            skip=1,
            order={
                'titleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNGame record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGame filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGame
            The first PSNGame record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGame record ordered by the platform field
        psngame = await PSNGame.prisma().find_first_or_raise(
            skip=1,
            order={
                'platform': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNGameUpdateInput,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNGame record.

        Parameters
        ----------
        data
            PSNGame record data specifying what to update
        where
            PSNGame filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The updated PSNGame record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().update(
            where={
                'id': 'jjhjdgjfg',
            },
            data={
                # data to update the PSNGame record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNGameWhereUniqueInput,
        data: types.PSNGameUpsertInput,
        include: Optional[types.PSNGameInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNGame filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The created or updated PSNGame record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().upsert(
            where={
                'id': 'bhhjcfadhd',
            },
            data={
                'create': {
                    'id': 'bhhjcfadhd',
                    'profileId': 'hfeidjicb',
                    'name': 'bbfbdccdag',
                    'titleId': 'biggefaged',
                    'platform': 'gfdbeaejg',
                },
                'update': {
                    'profileId': 'hfeidjicb',
                    'name': 'bbfbdccdag',
                    'titleId': 'biggefaged',
                    'platform': 'gfdbeaejg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNGameUpdateManyMutationInput,
        where: types.PSNGameWhereInput,
    ) -> int:
        """Update multiple PSNGame records

        Parameters
        ----------
        data
            PSNGame data to update the selected PSNGame records to
        where
            Filter to select the PSNGame records to update

        Returns
        -------
        int
            The total number of PSNGame records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNGame records
        total = await PSNGame.prisma().update_many(
            data={
                'imageUrl': 'fbejadda'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNGame records present in the database

        Parameters
        ----------
        select
            Select the PSNGame fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGame filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGame.prisma().count()

        # results: prisma.types.PSNGameCountAggregateOutput
        results = await PSNGame.prisma().count(
            select={
                '_all': True,
                'playCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNGameCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> types.PSNGameCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNGameCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> Union[int, types.PSNGameCountAggregateOutput]:
        """Count the number of PSNGame records present in the database

        Parameters
        ----------
        select
            Select the PSNGame fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGame filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGame.prisma().count()

        # results: prisma.types.PSNGameCountAggregateOutput
        results = await PSNGame.prisma().count(
            select={
                '_all': True,
                'firstPlayed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNGameCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNGameWhereInput] = None
    ) -> int:
        """Delete multiple PSNGame records.

        Parameters
        ----------
        where
            Optional PSNGame filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNGame records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNGame records
        total = await PSNGame.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNGameScalarFieldKeysT'],
        *,
        where: Optional['types.PSNGameWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNGameAvgAggregateInput'] = None,
        sum: Optional['types.PSNGameSumAggregateInput'] = None,
        min: Optional['types.PSNGameMinAggregateInput'] = None,
        max: Optional['types.PSNGameMaxAggregateInput'] = None,
        having: Optional['types.PSNGameScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNGameCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNGameScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNGameScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNGameGroupByOutput']:
        """Group PSNGame records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNGame fields to group records by
        where
            PSNGame filter to select records
        take
            Limit the maximum number of PSNGame records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNGameGroupByOutput]
            A list of dictionaries representing the PSNGame record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNGame records by lastPlayed values
        # and count how many records are in each group
        results = await PSNGame.prisma().group_by(
            ['lastPlayed'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNSyncLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNSyncLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNSyncLog.prisma().query_raw(
            'SELECT * FROM PSNSyncLog WHERE id = $1',
            'bjeaigeddb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNSyncLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNSyncLog.prisma().query_first(
            'SELECT * FROM PSNSyncLog WHERE profileId = $1',
            'eceecabdg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNSyncLogCreateInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNSyncLog record.

        Parameters
        ----------
        data
            PSNSyncLog record data
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The created PSNSyncLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNSyncLog record from just the required fields
        psnsynclog = await PSNSyncLog.prisma().create(
            data={
                # data to create a PSNSyncLog record
                'profileId': 'bdgaajbcab',
                'syncType': enums.PSNSyncType.PROFILE,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNSyncLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNSyncLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNSyncLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNSyncLog.prisma().create_many(
            data=[
                {
                    # data to create a PSNSyncLog record
                    'profileId': 'chhgehieg',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
                {
                    # data to create a PSNSyncLog record
                    'profileId': 'faggbiggd',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNSyncLog record.

        Parameters
        ----------
        where
            PSNSyncLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The deleted PSNSyncLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().delete(
            where={
                'id': 'bciijiajei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNSyncLog record.

        Parameters
        ----------
        where
            PSNSyncLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The found PSNSyncLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().find_unique(
            where={
                'id': 'bdjaadchgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNSyncLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNSyncLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The found PSNSyncLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().find_unique_or_raise(
            where={
                'id': 'biadfeebhi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNSyncLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNSyncLog records returned
        skip
            Ignore the first N results
        where
            PSNSyncLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNSyncLog]
            The list of all PSNSyncLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNSyncLog records
        psnsynclogs = await PSNSyncLog.prisma().find_many(take=10)

        # find the first 5 PSNSyncLog records ordered by the syncType field
        psnsynclogs = await PSNSyncLog.prisma().find_many(
            take=5,
            order={
                'syncType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNSyncLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNSyncLog
            The first PSNSyncLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNSyncLog record ordered by the status field
        psnsynclog = await PSNSyncLog.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNSyncLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNSyncLog
            The first PSNSyncLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNSyncLog record ordered by the startedAt field
        psnsynclog = await PSNSyncLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'startedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNSyncLogUpdateInput,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNSyncLog record.

        Parameters
        ----------
        data
            PSNSyncLog record data specifying what to update
        where
            PSNSyncLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The updated PSNSyncLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().update(
            where={
                'id': 'biajdcaged',
            },
            data={
                # data to update the PSNSyncLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        data: types.PSNSyncLogUpsertInput,
        include: Optional[types.PSNSyncLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNSyncLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The created or updated PSNSyncLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().upsert(
            where={
                'id': 'ddgjjicai',
            },
            data={
                'create': {
                    'id': 'ddgjjicai',
                    'profileId': 'faggbiggd',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
                'update': {
                    'profileId': 'faggbiggd',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNSyncLogUpdateManyMutationInput,
        where: types.PSNSyncLogWhereInput,
    ) -> int:
        """Update multiple PSNSyncLog records

        Parameters
        ----------
        data
            PSNSyncLog data to update the selected PSNSyncLog records to
        where
            Filter to select the PSNSyncLog records to update

        Returns
        -------
        int
            The total number of PSNSyncLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNSyncLog records
        total = await PSNSyncLog.prisma().update_many(
            data={
                'completedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNSyncLog records present in the database

        Parameters
        ----------
        select
            Select the PSNSyncLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNSyncLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNSyncLog.prisma().count()

        # results: prisma.types.PSNSyncLogCountAggregateOutput
        results = await PSNSyncLog.prisma().count(
            select={
                '_all': True,
                'errorMessage': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNSyncLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> types.PSNSyncLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNSyncLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> Union[int, types.PSNSyncLogCountAggregateOutput]:
        """Count the number of PSNSyncLog records present in the database

        Parameters
        ----------
        select
            Select the PSNSyncLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNSyncLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNSyncLog.prisma().count()

        # results: prisma.types.PSNSyncLogCountAggregateOutput
        results = await PSNSyncLog.prisma().count(
            select={
                '_all': True,
                'recordsUpdated': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNSyncLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNSyncLogWhereInput] = None
    ) -> int:
        """Delete multiple PSNSyncLog records.

        Parameters
        ----------
        where
            Optional PSNSyncLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNSyncLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNSyncLog records
        total = await PSNSyncLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNSyncLogScalarFieldKeysT'],
        *,
        where: Optional['types.PSNSyncLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNSyncLogAvgAggregateInput'] = None,
        sum: Optional['types.PSNSyncLogSumAggregateInput'] = None,
        min: Optional['types.PSNSyncLogMinAggregateInput'] = None,
        max: Optional['types.PSNSyncLogMaxAggregateInput'] = None,
        having: Optional['types.PSNSyncLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNSyncLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNSyncLogScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNSyncLogScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNSyncLogGroupByOutput']:
        """Group PSNSyncLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNSyncLog fields to group records by
        where
            PSNSyncLog filter to select records
        take
            Limit the maximum number of PSNSyncLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNSyncLogGroupByOutput]
            A list of dictionaries representing the PSNSyncLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNSyncLog records by id values
        # and count how many records are in each group
        results = await PSNSyncLog.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNGameTrophiesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNGameTrophies]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNGameTrophies.prisma().query_raw(
            'SELECT * FROM PSNGameTrophies WHERE id = $1',
            'efihdjdcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNGameTrophies.prisma().query_first(
            'SELECT * FROM PSNGameTrophies WHERE profileId = $1',
            'bdeacajaig',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNGameTrophiesCreateInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNGameTrophies record.

        Parameters
        ----------
        data
            PSNGameTrophies record data
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The created PSNGameTrophies record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNGameTrophies record from just the required fields
        psngametrophies = await PSNGameTrophies.prisma().create(
            data={
                # data to create a PSNGameTrophies record
                'profileId': 'jddggchfb',
                'gameId': 'bccbfcfdfg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNGameTrophiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNGameTrophies records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNGameTrophies record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNGameTrophies.prisma().create_many(
            data=[
                {
                    # data to create a PSNGameTrophies record
                    'profileId': 'bjchjgjib',
                    'gameId': 'ibiaaifcc',
                },
                {
                    # data to create a PSNGameTrophies record
                    'profileId': 'bffejbbadf',
                    'gameId': 'bajgjiebfc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNGameTrophies record.

        Parameters
        ----------
        where
            PSNGameTrophies filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The deleted PSNGameTrophies record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().delete(
            where={
                'id': 'bhahahadif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNGameTrophies record.

        Parameters
        ----------
        where
            PSNGameTrophies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The found PSNGameTrophies record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().find_unique(
            where={
                'id': 'bijhaihbcg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNGameTrophies record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNGameTrophies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The found PSNGameTrophies record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().find_unique_or_raise(
            where={
                'id': 'cbgcjeecd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNGameTrophies records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNGameTrophies records returned
        skip
            Ignore the first N results
        where
            PSNGameTrophies filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNGameTrophies]
            The list of all PSNGameTrophies records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNGameTrophies records
        psngametrophies = await PSNGameTrophies.prisma().find_many(take=10)

        # find the first 5 PSNGameTrophies records ordered by the gameId field
        psngametrophies = await PSNGameTrophies.prisma().find_many(
            take=5,
            order={
                'gameId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNGameTrophies record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first PSNGameTrophies record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGameTrophies record ordered by the trophiesEarned field
        psngametrophies = await PSNGameTrophies.prisma().find_first(
            skip=1,
            order={
                'trophiesEarned': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNGameTrophies record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first PSNGameTrophies record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGameTrophies record ordered by the trophiesTotal field
        psngametrophies = await PSNGameTrophies.prisma().find_first_or_raise(
            skip=1,
            order={
                'trophiesTotal': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNGameTrophiesUpdateInput,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNGameTrophies record.

        Parameters
        ----------
        data
            PSNGameTrophies record data specifying what to update
        where
            PSNGameTrophies filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The updated PSNGameTrophies record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().update(
            where={
                'id': 'bebibighfg',
            },
            data={
                # data to update the PSNGameTrophies record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        data: types.PSNGameTrophiesUpsertInput,
        include: Optional[types.PSNGameTrophiesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNGameTrophies filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The created or updated PSNGameTrophies record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().upsert(
            where={
                'id': 'bbhjeejidh',
            },
            data={
                'create': {
                    'id': 'bbhjeejidh',
                    'profileId': 'bffejbbadf',
                    'gameId': 'bajgjiebfc',
                },
                'update': {
                    'profileId': 'bffejbbadf',
                    'gameId': 'bajgjiebfc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNGameTrophiesUpdateManyMutationInput,
        where: types.PSNGameTrophiesWhereInput,
    ) -> int:
        """Update multiple PSNGameTrophies records

        Parameters
        ----------
        data
            PSNGameTrophies data to update the selected PSNGameTrophies records to
        where
            Filter to select the PSNGameTrophies records to update

        Returns
        -------
        int
            The total number of PSNGameTrophies records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNGameTrophies records
        total = await PSNGameTrophies.prisma().update_many(
            data={
                'progress': 1564135458
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNGameTrophies records present in the database

        Parameters
        ----------
        select
            Select the PSNGameTrophies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameTrophiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGameTrophies.prisma().count()

        # results: prisma.types.PSNGameTrophiesCountAggregateOutput
        results = await PSNGameTrophies.prisma().count(
            select={
                '_all': True,
                'platinumEarned': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNGameTrophiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> types.PSNGameTrophiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNGameTrophiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> Union[int, types.PSNGameTrophiesCountAggregateOutput]:
        """Count the number of PSNGameTrophies records present in the database

        Parameters
        ----------
        select
            Select the PSNGameTrophies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameTrophiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGameTrophies.prisma().count()

        # results: prisma.types.PSNGameTrophiesCountAggregateOutput
        results = await PSNGameTrophies.prisma().count(
            select={
                '_all': True,
                'goldEarned': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNGameTrophiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNGameTrophiesWhereInput] = None
    ) -> int:
        """Delete multiple PSNGameTrophies records.

        Parameters
        ----------
        where
            Optional PSNGameTrophies filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNGameTrophies records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNGameTrophies records
        total = await PSNGameTrophies.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNGameTrophiesScalarFieldKeysT'],
        *,
        where: Optional['types.PSNGameTrophiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNGameTrophiesAvgAggregateInput'] = None,
        sum: Optional['types.PSNGameTrophiesSumAggregateInput'] = None,
        min: Optional['types.PSNGameTrophiesMinAggregateInput'] = None,
        max: Optional['types.PSNGameTrophiesMaxAggregateInput'] = None,
        having: Optional['types.PSNGameTrophiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNGameTrophiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNGameTrophiesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNGameTrophiesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNGameTrophiesGroupByOutput']:
        """Group PSNGameTrophies records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNGameTrophies fields to group records by
        where
            PSNGameTrophies filter to select records
        take
            Limit the maximum number of PSNGameTrophies records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNGameTrophiesGroupByOutput]
            A list of dictionaries representing the PSNGameTrophies record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNGameTrophies records by silverEarned values
        # and count how many records are in each group
        results = await PSNGameTrophies.prisma().group_by(
            ['silverEarned'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models