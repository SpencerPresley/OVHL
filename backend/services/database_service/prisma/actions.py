# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class ForumPostActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumPost]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumPost.prisma().query_raw(
            'SELECT * FROM ForumPost WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumPost
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumPost.prisma().query_first(
            'SELECT * FROM ForumPost WHERE title = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumPostCreateInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumPost record.

        Parameters
        ----------
        data
            ForumPost record data
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The created ForumPost record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumPost record from just the required fields
        forumpost = await ForumPost.prisma().create(
            data={
                # data to create a ForumPost record
                'title': 'ggciceaie',
                'content': 'bbehjachib',
                'authorId': 'cadfabfehe',
                'leagueId': 'dgiiaaijj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumPostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumPost records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumPost record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumPost.prisma().create_many(
            data=[
                {
                    # data to create a ForumPost record
                    'title': 'bfaiacjjfc',
                    'content': 'eigcfgbif',
                    'authorId': 'bagcfbhiig',
                    'leagueId': 'cghideieh',
                },
                {
                    # data to create a ForumPost record
                    'title': 'biabhbdai',
                    'content': 'idghgaicb',
                    'authorId': 'fjfddhigg',
                    'leagueId': 'hjaecfifb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumPost record.

        Parameters
        ----------
        where
            ForumPost filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The deleted ForumPost record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().delete(
            where={
                'id': 'cbbbjbfcii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumPost record.

        Parameters
        ----------
        where
            ForumPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The found ForumPost record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().find_unique(
            where={
                'id': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumPost record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The found ForumPost record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().find_unique_or_raise(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumPost records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumPost records returned
        skip
            Ignore the first N results
        where
            ForumPost filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumPost]
            The list of all ForumPost records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumPost records
        forumposts = await ForumPost.prisma().find_many(take=10)

        # find the first 5 ForumPost records ordered by the content field
        forumposts = await ForumPost.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumPost record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPost
            The first ForumPost record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPost record ordered by the status field
        forumpost = await ForumPost.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
        include: Optional[types.ForumPostInclude] = None,
        order: Optional[Union[types.ForumPostOrderByInput, List[types.ForumPostOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumPost record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPost model
        order
            Order the returned ForumPost records by any field
        distinct
            Filter ForumPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPost
            The first ForumPost record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPost record ordered by the authorId field
        forumpost = await ForumPost.prisma().find_first_or_raise(
            skip=1,
            order={
                'authorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumPostUpdateInput,
        where: types.ForumPostWhereUniqueInput,
        include: Optional[types.ForumPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumPost record.

        Parameters
        ----------
        data
            ForumPost record data specifying what to update
        where
            ForumPost filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The updated ForumPost record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().update(
            where={
                'id': 'bdiicjafbj',
            },
            data={
                # data to update the ForumPost record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumPostWhereUniqueInput,
        data: types.ForumPostUpsertInput,
        include: Optional[types.ForumPostInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumPost filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumPost model

        Returns
        -------
        prisma.models.ForumPost
            The created or updated ForumPost record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpost = await ForumPost.prisma().upsert(
            where={
                'id': 'bgehebiafc',
            },
            data={
                'create': {
                    'id': 'bgehebiafc',
                    'title': 'biabhbdai',
                    'content': 'idghgaicb',
                    'authorId': 'fjfddhigg',
                    'leagueId': 'hjaecfifb',
                },
                'update': {
                    'title': 'biabhbdai',
                    'content': 'idghgaicb',
                    'authorId': 'fjfddhigg',
                    'leagueId': 'hjaecfifb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumPostUpdateManyMutationInput,
        where: types.ForumPostWhereInput,
    ) -> int:
        """Update multiple ForumPost records

        Parameters
        ----------
        data
            ForumPost data to update the selected ForumPost records to
        where
            Filter to select the ForumPost records to update

        Returns
        -------
        int
            The total number of ForumPost records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumPost records
        total = await ForumPost.prisma().update_many(
            data={
                'leagueId': 'bghffegacj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumPost records present in the database

        Parameters
        ----------
        select
            Select the ForumPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPost.prisma().count()

        # results: prisma.types.ForumPostCountAggregateOutput
        results = await ForumPost.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumPostCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> types.ForumPostCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumPostCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostWhereInput] = None,
        cursor: Optional[types.ForumPostWhereUniqueInput] = None,
    ) -> Union[int, types.ForumPostCountAggregateOutput]:
        """Count the number of ForumPost records present in the database

        Parameters
        ----------
        select
            Select the ForumPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPost.prisma().count()

        # results: prisma.types.ForumPostCountAggregateOutput
        results = await ForumPost.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumPostCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumPostWhereInput] = None
    ) -> int:
        """Delete multiple ForumPost records.

        Parameters
        ----------
        where
            Optional ForumPost filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumPost records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumPost records
        total = await ForumPost.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumPostScalarFieldKeysT'],
        *,
        where: Optional['types.ForumPostWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumPostAvgAggregateInput'] = None,
        sum: Optional['types.ForumPostSumAggregateInput'] = None,
        min: Optional['types.ForumPostMinAggregateInput'] = None,
        max: Optional['types.ForumPostMaxAggregateInput'] = None,
        having: Optional['types.ForumPostScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumPostCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumPostScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumPostScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumPostGroupByOutput']:
        """Group ForumPost records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumPost fields to group records by
        where
            ForumPost filter to select records
        take
            Limit the maximum number of ForumPost records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumPostGroupByOutput]
            A list of dictionaries representing the ForumPost record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumPost records by gif values
        # and count how many records are in each group
        results = await ForumPost.prisma().group_by(
            ['gif'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumReactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumReaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumReaction.prisma().query_raw(
            'SELECT * FROM ForumReaction WHERE id = $1',
            'bhghchehcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumReaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumReaction.prisma().query_first(
            'SELECT * FROM ForumReaction WHERE type = $1',
            enums.ReactionType.LIKE,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumReactionCreateInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumReaction record.

        Parameters
        ----------
        data
            ForumReaction record data
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The created ForumReaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumReaction record from just the required fields
        forumreaction = await ForumReaction.prisma().create(
            data={
                # data to create a ForumReaction record
                'type': enums.ReactionType.LIKE,
                'userId': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumReactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumReaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumReaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumReaction.prisma().create_many(
            data=[
                {
                    # data to create a ForumReaction record
                    'type': enums.ReactionType.LIKE,
                    'userId': 'bdedcabahc',
                },
                {
                    # data to create a ForumReaction record
                    'type': enums.ReactionType.LIKE,
                    'userId': 'ghfhiafcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumReaction record.

        Parameters
        ----------
        where
            ForumReaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The deleted ForumReaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().delete(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumReaction record.

        Parameters
        ----------
        where
            ForumReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The found ForumReaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().find_unique(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumReaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The found ForumReaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().find_unique_or_raise(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumReaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumReaction records returned
        skip
            Ignore the first N results
        where
            ForumReaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumReaction]
            The list of all ForumReaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumReaction records
        forumreactions = await ForumReaction.prisma().find_many(take=10)

        # find the first 5 ForumReaction records ordered by the userId field
        forumreactions = await ForumReaction.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumReaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumReaction
            The first ForumReaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumReaction record ordered by the postId field
        forumreaction = await ForumReaction.prisma().find_first(
            skip=1,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
        include: Optional[types.ForumReactionInclude] = None,
        order: Optional[Union[types.ForumReactionOrderByInput, List[types.ForumReactionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumReactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumReaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumReaction model
        order
            Order the returned ForumReaction records by any field
        distinct
            Filter ForumReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumReaction
            The first ForumReaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumReaction record ordered by the commentId field
        forumreaction = await ForumReaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'commentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumReactionUpdateInput,
        where: types.ForumReactionWhereUniqueInput,
        include: Optional[types.ForumReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumReaction record.

        Parameters
        ----------
        data
            ForumReaction record data specifying what to update
        where
            ForumReaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The updated ForumReaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().update(
            where={
                'id': 'igbehcbab',
            },
            data={
                # data to update the ForumReaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumReactionWhereUniqueInput,
        data: types.ForumReactionUpsertInput,
        include: Optional[types.ForumReactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumReaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumReaction model

        Returns
        -------
        prisma.models.ForumReaction
            The created or updated ForumReaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumreaction = await ForumReaction.prisma().upsert(
            where={
                'id': 'bdadaadhag',
            },
            data={
                'create': {
                    'id': 'bdadaadhag',
                    'type': enums.ReactionType.LIKE,
                    'userId': 'ghfhiafcb',
                },
                'update': {
                    'type': enums.ReactionType.LIKE,
                    'userId': 'ghfhiafcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumReactionUpdateManyMutationInput,
        where: types.ForumReactionWhereInput,
    ) -> int:
        """Update multiple ForumReaction records

        Parameters
        ----------
        data
            ForumReaction data to update the selected ForumReaction records to
        where
            Filter to select the ForumReaction records to update

        Returns
        -------
        int
            The total number of ForumReaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumReaction records
        total = await ForumReaction.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumReaction records present in the database

        Parameters
        ----------
        select
            Select the ForumReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumReaction.prisma().count()

        # results: prisma.types.ForumReactionCountAggregateOutput
        results = await ForumReaction.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumReactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> types.ForumReactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumReactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumReactionWhereInput] = None,
        cursor: Optional[types.ForumReactionWhereUniqueInput] = None,
    ) -> Union[int, types.ForumReactionCountAggregateOutput]:
        """Count the number of ForumReaction records present in the database

        Parameters
        ----------
        select
            Select the ForumReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumReaction.prisma().count()

        # results: prisma.types.ForumReactionCountAggregateOutput
        results = await ForumReaction.prisma().count(
            select={
                '_all': True,
                'type': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumReactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumReactionWhereInput] = None
    ) -> int:
        """Delete multiple ForumReaction records.

        Parameters
        ----------
        where
            Optional ForumReaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumReaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumReaction records
        total = await ForumReaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumReactionScalarFieldKeysT'],
        *,
        where: Optional['types.ForumReactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumReactionAvgAggregateInput'] = None,
        sum: Optional['types.ForumReactionSumAggregateInput'] = None,
        min: Optional['types.ForumReactionMinAggregateInput'] = None,
        max: Optional['types.ForumReactionMaxAggregateInput'] = None,
        having: Optional['types.ForumReactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumReactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumReactionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumReactionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumReactionGroupByOutput']:
        """Group ForumReaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumReaction fields to group records by
        where
            ForumReaction filter to select records
        take
            Limit the maximum number of ForumReaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumReactionGroupByOutput]
            A list of dictionaries representing the ForumReaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumReaction records by userId values
        # and count how many records are in each group
        results = await ForumReaction.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumFollowerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumFollower]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumFollower.prisma().query_raw(
            'SELECT * FROM ForumFollower WHERE id = $1',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumFollower
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumFollower.prisma().query_first(
            'SELECT * FROM ForumFollower WHERE userId = $1',
            'caaaedabfc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumFollowerCreateInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumFollower record.

        Parameters
        ----------
        data
            ForumFollower record data
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The created ForumFollower record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumFollower record from just the required fields
        forumfollower = await ForumFollower.prisma().create(
            data={
                # data to create a ForumFollower record
                'userId': 'bigibebcib',
                'postId': 'bigaiehgcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumFollowerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumFollower records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumFollower record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumFollower.prisma().create_many(
            data=[
                {
                    # data to create a ForumFollower record
                    'userId': 'beeifcbebf',
                    'postId': 'bgcigfahea',
                },
                {
                    # data to create a ForumFollower record
                    'userId': 'bcejgaggif',
                    'postId': 'idfjadbcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumFollower record.

        Parameters
        ----------
        where
            ForumFollower filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The deleted ForumFollower record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().delete(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumFollower record.

        Parameters
        ----------
        where
            ForumFollower filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The found ForumFollower record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().find_unique(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumFollower record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumFollower filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The found ForumFollower record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().find_unique_or_raise(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumFollower records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumFollower records returned
        skip
            Ignore the first N results
        where
            ForumFollower filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumFollower]
            The list of all ForumFollower records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumFollower records
        forumfollowers = await ForumFollower.prisma().find_many(take=10)

        # find the first 5 ForumFollower records ordered by the postId field
        forumfollowers = await ForumFollower.prisma().find_many(
            take=5,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumFollower record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumFollower filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumFollower
            The first ForumFollower record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumFollower record ordered by the createdAt field
        forumfollower = await ForumFollower.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
        include: Optional[types.ForumFollowerInclude] = None,
        order: Optional[Union[types.ForumFollowerOrderByInput, List[types.ForumFollowerOrderByInput]]] = None,
        distinct: Optional[List[types.ForumFollowerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumFollower record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumFollower filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumFollower model
        order
            Order the returned ForumFollower records by any field
        distinct
            Filter ForumFollower records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumFollower
            The first ForumFollower record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumFollower record ordered by the id field
        forumfollower = await ForumFollower.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumFollowerUpdateInput,
        where: types.ForumFollowerWhereUniqueInput,
        include: Optional[types.ForumFollowerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumFollower record.

        Parameters
        ----------
        data
            ForumFollower record data specifying what to update
        where
            ForumFollower filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The updated ForumFollower record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().update(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                # data to update the ForumFollower record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumFollowerWhereUniqueInput,
        data: types.ForumFollowerUpsertInput,
        include: Optional[types.ForumFollowerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumFollower filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumFollower model

        Returns
        -------
        prisma.models.ForumFollower
            The created or updated ForumFollower record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumfollower = await ForumFollower.prisma().upsert(
            where={
                'id': 'jjfeafhfj',
            },
            data={
                'create': {
                    'id': 'jjfeafhfj',
                    'userId': 'bcejgaggif',
                    'postId': 'idfjadbcc',
                },
                'update': {
                    'userId': 'bcejgaggif',
                    'postId': 'idfjadbcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumFollowerUpdateManyMutationInput,
        where: types.ForumFollowerWhereInput,
    ) -> int:
        """Update multiple ForumFollower records

        Parameters
        ----------
        data
            ForumFollower data to update the selected ForumFollower records to
        where
            Filter to select the ForumFollower records to update

        Returns
        -------
        int
            The total number of ForumFollower records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumFollower records
        total = await ForumFollower.prisma().update_many(
            data={
                'userId': 'cbachdgfce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumFollower records present in the database

        Parameters
        ----------
        select
            Select the ForumFollower fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumFollower filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumFollowerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumFollower.prisma().count()

        # results: prisma.types.ForumFollowerCountAggregateOutput
        results = await ForumFollower.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumFollowerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> types.ForumFollowerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumFollowerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumFollowerWhereInput] = None,
        cursor: Optional[types.ForumFollowerWhereUniqueInput] = None,
    ) -> Union[int, types.ForumFollowerCountAggregateOutput]:
        """Count the number of ForumFollower records present in the database

        Parameters
        ----------
        select
            Select the ForumFollower fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumFollower filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumFollowerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumFollower.prisma().count()

        # results: prisma.types.ForumFollowerCountAggregateOutput
        results = await ForumFollower.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumFollowerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumFollowerWhereInput] = None
    ) -> int:
        """Delete multiple ForumFollower records.

        Parameters
        ----------
        where
            Optional ForumFollower filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumFollower records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumFollower records
        total = await ForumFollower.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumFollowerScalarFieldKeysT'],
        *,
        where: Optional['types.ForumFollowerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumFollowerAvgAggregateInput'] = None,
        sum: Optional['types.ForumFollowerSumAggregateInput'] = None,
        min: Optional['types.ForumFollowerMinAggregateInput'] = None,
        max: Optional['types.ForumFollowerMaxAggregateInput'] = None,
        having: Optional['types.ForumFollowerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumFollowerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumFollowerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumFollowerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumFollowerGroupByOutput']:
        """Group ForumFollower records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumFollower fields to group records by
        where
            ForumFollower filter to select records
        take
            Limit the maximum number of ForumFollower records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumFollowerGroupByOutput]
            A list of dictionaries representing the ForumFollower record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumFollower records by id values
        # and count how many records are in each group
        results = await ForumFollower.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumPostSubscriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumPostSubscription]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumPostSubscription.prisma().query_raw(
            'SELECT * FROM ForumPostSubscription WHERE id = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumPostSubscription.prisma().query_first(
            'SELECT * FROM ForumPostSubscription WHERE userId = $1',
            'efggddide',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumPostSubscriptionCreateInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumPostSubscription record.

        Parameters
        ----------
        data
            ForumPostSubscription record data
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The created ForumPostSubscription record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumPostSubscription record from just the required fields
        forumpostsubscription = await ForumPostSubscription.prisma().create(
            data={
                # data to create a ForumPostSubscription record
                'userId': 'caficfigfb',
                'postId': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumPostSubscriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumPostSubscription records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumPostSubscription record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumPostSubscription.prisma().create_many(
            data=[
                {
                    # data to create a ForumPostSubscription record
                    'userId': 'ihieecagf',
                    'postId': 'bghfciaafe',
                },
                {
                    # data to create a ForumPostSubscription record
                    'userId': 'bgchfhgceh',
                    'postId': 'cafeiaccbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumPostSubscription record.

        Parameters
        ----------
        where
            ForumPostSubscription filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The deleted ForumPostSubscription record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().delete(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumPostSubscription record.

        Parameters
        ----------
        where
            ForumPostSubscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The found ForumPostSubscription record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().find_unique(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumPostSubscription record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumPostSubscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The found ForumPostSubscription record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().find_unique_or_raise(
            where={
                'id': 'bgcffadich',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumPostSubscription records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumPostSubscription records returned
        skip
            Ignore the first N results
        where
            ForumPostSubscription filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumPostSubscription]
            The list of all ForumPostSubscription records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumPostSubscription records
        forumpostsubscriptions = await ForumPostSubscription.prisma().find_many(take=10)

        # find the first 5 ForumPostSubscription records ordered by the postId field
        forumpostsubscriptions = await ForumPostSubscription.prisma().find_many(
            take=5,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumPostSubscription record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first ForumPostSubscription record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPostSubscription record ordered by the createdAt field
        forumpostsubscription = await ForumPostSubscription.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
        order: Optional[Union[types.ForumPostSubscriptionOrderByInput, List[types.ForumPostSubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.ForumPostSubscriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumPostSubscription record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model
        order
            Order the returned ForumPostSubscription records by any field
        distinct
            Filter ForumPostSubscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumPostSubscription
            The first ForumPostSubscription record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumPostSubscription record ordered by the id field
        forumpostsubscription = await ForumPostSubscription.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumPostSubscriptionUpdateInput,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumPostSubscription record.

        Parameters
        ----------
        data
            ForumPostSubscription record data specifying what to update
        where
            ForumPostSubscription filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The updated ForumPostSubscription record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().update(
            where={
                'id': 'fcbichhci',
            },
            data={
                # data to update the ForumPostSubscription record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumPostSubscriptionWhereUniqueInput,
        data: types.ForumPostSubscriptionUpsertInput,
        include: Optional[types.ForumPostSubscriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumPostSubscription filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumPostSubscription model

        Returns
        -------
        prisma.models.ForumPostSubscription
            The created or updated ForumPostSubscription record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumpostsubscription = await ForumPostSubscription.prisma().upsert(
            where={
                'id': 'bcggadccgf',
            },
            data={
                'create': {
                    'id': 'bcggadccgf',
                    'userId': 'bgchfhgceh',
                    'postId': 'cafeiaccbc',
                },
                'update': {
                    'userId': 'bgchfhgceh',
                    'postId': 'cafeiaccbc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumPostSubscriptionUpdateManyMutationInput,
        where: types.ForumPostSubscriptionWhereInput,
    ) -> int:
        """Update multiple ForumPostSubscription records

        Parameters
        ----------
        data
            ForumPostSubscription data to update the selected ForumPostSubscription records to
        where
            Filter to select the ForumPostSubscription records to update

        Returns
        -------
        int
            The total number of ForumPostSubscription records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumPostSubscription records
        total = await ForumPostSubscription.prisma().update_many(
            data={
                'userId': 'jdcfdcgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumPostSubscription records present in the database

        Parameters
        ----------
        select
            Select the ForumPostSubscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostSubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPostSubscription.prisma().count()

        # results: prisma.types.ForumPostSubscriptionCountAggregateOutput
        results = await ForumPostSubscription.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumPostSubscriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> types.ForumPostSubscriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumPostSubscriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None,
        cursor: Optional[types.ForumPostSubscriptionWhereUniqueInput] = None,
    ) -> Union[int, types.ForumPostSubscriptionCountAggregateOutput]:
        """Count the number of ForumPostSubscription records present in the database

        Parameters
        ----------
        select
            Select the ForumPostSubscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumPostSubscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumPostSubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumPostSubscription.prisma().count()

        # results: prisma.types.ForumPostSubscriptionCountAggregateOutput
        results = await ForumPostSubscription.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumPostSubscriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumPostSubscriptionWhereInput] = None
    ) -> int:
        """Delete multiple ForumPostSubscription records.

        Parameters
        ----------
        where
            Optional ForumPostSubscription filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumPostSubscription records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumPostSubscription records
        total = await ForumPostSubscription.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumPostSubscriptionScalarFieldKeysT'],
        *,
        where: Optional['types.ForumPostSubscriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumPostSubscriptionAvgAggregateInput'] = None,
        sum: Optional['types.ForumPostSubscriptionSumAggregateInput'] = None,
        min: Optional['types.ForumPostSubscriptionMinAggregateInput'] = None,
        max: Optional['types.ForumPostSubscriptionMaxAggregateInput'] = None,
        having: Optional['types.ForumPostSubscriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumPostSubscriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumPostSubscriptionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumPostSubscriptionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumPostSubscriptionGroupByOutput']:
        """Group ForumPostSubscription records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumPostSubscription fields to group records by
        where
            ForumPostSubscription filter to select records
        take
            Limit the maximum number of ForumPostSubscription records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumPostSubscriptionGroupByOutput]
            A list of dictionaries representing the ForumPostSubscription record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumPostSubscription records by id values
        # and count how many records are in each group
        results = await ForumPostSubscription.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForumCommentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ForumComment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ForumComment.prisma().query_raw(
            'SELECT * FROM ForumComment WHERE id = $1',
            'cafdaehjid',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ForumComment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ForumComment.prisma().query_first(
            'SELECT * FROM ForumComment WHERE content = $1',
            'gifdddbia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForumCommentCreateInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> _PrismaModelT:
        """Create a new ForumComment record.

        Parameters
        ----------
        data
            ForumComment record data
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The created ForumComment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ForumComment record from just the required fields
        forumcomment = await ForumComment.prisma().create(
            data={
                # data to create a ForumComment record
                'content': 'bchehecef',
                'authorId': 'jeijcbhfe',
                'postId': 'bjgejjabff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForumCommentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ForumComment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ForumComment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ForumComment.prisma().create_many(
            data=[
                {
                    # data to create a ForumComment record
                    'content': 'bcciijbibg',
                    'authorId': 'cffcachfd',
                    'postId': 'bccdfhdigc',
                },
                {
                    # data to create a ForumComment record
                    'content': 'febcgjbfj',
                    'authorId': 'bageiegghg',
                    'postId': 'faidicegb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ForumComment record.

        Parameters
        ----------
        where
            ForumComment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The deleted ForumComment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().delete(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ForumComment record.

        Parameters
        ----------
        where
            ForumComment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The found ForumComment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().find_unique(
            where={
                'id': 'ihcahiead',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ForumComment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ForumComment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The found ForumComment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().find_unique_or_raise(
            where={
                'id': 'biheheiajg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ForumComment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ForumComment records returned
        skip
            Ignore the first N results
        where
            ForumComment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ForumComment]
            The list of all ForumComment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ForumComment records
        forumcomments = await ForumComment.prisma().find_many(take=10)

        # find the first 5 ForumComment records ordered by the status field
        forumcomments = await ForumComment.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ForumComment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumComment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumComment
            The first ForumComment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumComment record ordered by the createdAt field
        forumcomment = await ForumComment.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
        include: Optional[types.ForumCommentInclude] = None,
        order: Optional[Union[types.ForumCommentOrderByInput, List[types.ForumCommentOrderByInput]]] = None,
        distinct: Optional[List[types.ForumCommentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ForumComment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ForumComment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ForumComment model
        order
            Order the returned ForumComment records by any field
        distinct
            Filter ForumComment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ForumComment
            The first ForumComment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ForumComment record ordered by the updatedAt field
        forumcomment = await ForumComment.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForumCommentUpdateInput,
        where: types.ForumCommentWhereUniqueInput,
        include: Optional[types.ForumCommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ForumComment record.

        Parameters
        ----------
        data
            ForumComment record data specifying what to update
        where
            ForumComment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The updated ForumComment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().update(
            where={
                'id': 'jbgijghgb',
            },
            data={
                # data to update the ForumComment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForumCommentWhereUniqueInput,
        data: types.ForumCommentUpsertInput,
        include: Optional[types.ForumCommentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ForumComment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ForumComment model

        Returns
        -------
        prisma.models.ForumComment
            The created or updated ForumComment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forumcomment = await ForumComment.prisma().upsert(
            where={
                'id': 'hgjcghfbi',
            },
            data={
                'create': {
                    'id': 'hgjcghfbi',
                    'content': 'febcgjbfj',
                    'authorId': 'bageiegghg',
                    'postId': 'faidicegb',
                },
                'update': {
                    'content': 'febcgjbfj',
                    'authorId': 'bageiegghg',
                    'postId': 'faidicegb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForumCommentUpdateManyMutationInput,
        where: types.ForumCommentWhereInput,
    ) -> int:
        """Update multiple ForumComment records

        Parameters
        ----------
        data
            ForumComment data to update the selected ForumComment records to
        where
            Filter to select the ForumComment records to update

        Returns
        -------
        int
            The total number of ForumComment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ForumComment records
        total = await ForumComment.prisma().update_many(
            data={
                'authorId': 'icadbcehj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ForumComment records present in the database

        Parameters
        ----------
        select
            Select the ForumComment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumComment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumCommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumComment.prisma().count()

        # results: prisma.types.ForumCommentCountAggregateOutput
        results = await ForumComment.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForumCommentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> types.ForumCommentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForumCommentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForumCommentWhereInput] = None,
        cursor: Optional[types.ForumCommentWhereUniqueInput] = None,
    ) -> Union[int, types.ForumCommentCountAggregateOutput]:
        """Count the number of ForumComment records present in the database

        Parameters
        ----------
        select
            Select the ForumComment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ForumComment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForumCommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ForumComment.prisma().count()

        # results: prisma.types.ForumCommentCountAggregateOutput
        results = await ForumComment.prisma().count(
            select={
                '_all': True,
                'quotedCommentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForumCommentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForumCommentWhereInput] = None
    ) -> int:
        """Delete multiple ForumComment records.

        Parameters
        ----------
        where
            Optional ForumComment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ForumComment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ForumComment records
        total = await ForumComment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForumCommentScalarFieldKeysT'],
        *,
        where: Optional['types.ForumCommentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForumCommentAvgAggregateInput'] = None,
        sum: Optional['types.ForumCommentSumAggregateInput'] = None,
        min: Optional['types.ForumCommentMinAggregateInput'] = None,
        max: Optional['types.ForumCommentMaxAggregateInput'] = None,
        having: Optional['types.ForumCommentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForumCommentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForumCommentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ForumCommentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ForumCommentGroupByOutput']:
        """Group ForumComment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ForumComment fields to group records by
        where
            ForumComment filter to select records
        take
            Limit the maximum number of ForumComment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForumCommentGroupByOutput]
            A list of dictionaries representing the ForumComment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ForumComment records by gif values
        # and count how many records are in each group
        results = await ForumComment.prisma().group_by(
            ['gif'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeagueActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.League]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await League.prisma().query_raw(
            'SELECT * FROM League WHERE id = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.League
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await League.prisma().query_first(
            'SELECT * FROM League WHERE name = $1',
            'deeificjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeagueCreateInput,
        include: Optional[types.LeagueInclude] = None
    ) -> _PrismaModelT:
        """Create a new League record.

        Parameters
        ----------
        data
            League record data
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The created League record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a League record from just the required fields
        league = await League.prisma().create(
            data={
                # data to create a League record
                'name': 'bbcbhebbda',
                'shortName': 'bejfijgcfb',
                'leagueType': enums.LeagueType.NHL,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeagueCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple League records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of League record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await League.prisma().create_many(
            data=[
                {
                    # data to create a League record
                    'name': 'caifcbgii',
                    'shortName': 'igaibbfgj',
                    'leagueType': enums.LeagueType.NHL,
                },
                {
                    # data to create a League record
                    'name': 'bggajdcbbi',
                    'shortName': 'fcfhgbjed',
                    'leagueType': enums.LeagueType.NHL,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeagueWhereUniqueInput,
        include: Optional[types.LeagueInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single League record.

        Parameters
        ----------
        where
            League filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The deleted League record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        league = await League.prisma().delete(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeagueWhereUniqueInput,
        include: Optional[types.LeagueInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique League record.

        Parameters
        ----------
        where
            League filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The found League record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        league = await League.prisma().find_unique(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeagueWhereUniqueInput,
        include: Optional[types.LeagueInclude] = None
    ) -> _PrismaModelT:
        """Find a unique League record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            League filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The found League record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        league = await League.prisma().find_unique_or_raise(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
        include: Optional[types.LeagueInclude] = None,
        order: Optional[Union[types.LeagueOrderByInput, List[types.LeagueOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple League records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of League records returned
        skip
            Ignore the first N results
        where
            League filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned League model
        order
            Order the returned League records by any field
        distinct
            Filter League records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.League]
            The list of all League records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 League records
        leagues = await League.prisma().find_many(take=10)

        # find the first 5 League records ordered by the shortName field
        leagues = await League.prisma().find_many(
            take=5,
            order={
                'shortName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
        include: Optional[types.LeagueInclude] = None,
        order: Optional[Union[types.LeagueOrderByInput, List[types.LeagueOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single League record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            League filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned League model
        order
            Order the returned League records by any field
        distinct
            Filter League records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.League
            The first League record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second League record ordered by the leagueType field
        league = await League.prisma().find_first(
            skip=1,
            order={
                'leagueType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
        include: Optional[types.LeagueInclude] = None,
        order: Optional[Union[types.LeagueOrderByInput, List[types.LeagueOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single League record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            League filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned League model
        order
            Order the returned League records by any field
        distinct
            Filter League records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.League
            The first League record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second League record ordered by the isSubLeague field
        league = await League.prisma().find_first_or_raise(
            skip=1,
            order={
                'isSubLeague': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeagueUpdateInput,
        where: types.LeagueWhereUniqueInput,
        include: Optional[types.LeagueInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single League record.

        Parameters
        ----------
        data
            League record data specifying what to update
        where
            League filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The updated League record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        league = await League.prisma().update(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                # data to update the League record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeagueWhereUniqueInput,
        data: types.LeagueUpsertInput,
        include: Optional[types.LeagueInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            League filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned League model

        Returns
        -------
        prisma.models.League
            The created or updated League record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        league = await League.prisma().upsert(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                'create': {
                    'id': 'bjafcgbffc',
                    'name': 'bggajdcbbi',
                    'shortName': 'fcfhgbjed',
                    'leagueType': enums.LeagueType.NHL,
                },
                'update': {
                    'name': 'bggajdcbbi',
                    'shortName': 'fcfhgbjed',
                    'leagueType': enums.LeagueType.NHL,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeagueUpdateManyMutationInput,
        where: types.LeagueWhereInput,
    ) -> int:
        """Update multiple League records

        Parameters
        ----------
        data
            League data to update the selected League records to
        where
            Filter to select the League records to update

        Returns
        -------
        int
            The total number of League records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all League records
        total = await League.prisma().update_many(
            data={
                'parentLeagueId': 'hihegjif'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
    ) -> int:
        """Count the number of League records present in the database

        Parameters
        ----------
        select
            Select the League fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            League filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await League.prisma().count()

        # results: prisma.types.LeagueCountAggregateOutput
        results = await League.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeagueCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
    ) -> types.LeagueCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeagueCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueWhereInput] = None,
        cursor: Optional[types.LeagueWhereUniqueInput] = None,
    ) -> Union[int, types.LeagueCountAggregateOutput]:
        """Count the number of League records present in the database

        Parameters
        ----------
        select
            Select the League fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            League filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await League.prisma().count()

        # results: prisma.types.LeagueCountAggregateOutput
        results = await League.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeagueCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeagueWhereInput] = None
    ) -> int:
        """Delete multiple League records.

        Parameters
        ----------
        where
            Optional League filter to find the records to be deleted

        Returns
        -------
        int
            The total number of League records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all League records
        total = await League.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeagueScalarFieldKeysT'],
        *,
        where: Optional['types.LeagueWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeagueAvgAggregateInput'] = None,
        sum: Optional['types.LeagueSumAggregateInput'] = None,
        min: Optional['types.LeagueMinAggregateInput'] = None,
        max: Optional['types.LeagueMaxAggregateInput'] = None,
        having: Optional['types.LeagueScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeagueCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeagueScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LeagueScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LeagueGroupByOutput']:
        """Group League records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar League fields to group records by
        where
            League filter to select records
        take
            Limit the maximum number of League records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeagueGroupByOutput]
            A list of dictionaries representing the League record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group League records by shortName values
        # and count how many records are in each group
        results = await League.prisma().group_by(
            ['shortName'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeagueSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LeagueSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LeagueSeason.prisma().query_raw(
            'SELECT * FROM LeagueSeason WHERE id = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LeagueSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LeagueSeason.prisma().query_first(
            'SELECT * FROM LeagueSeason WHERE leagueId = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeagueSeasonCreateInput,
        include: Optional[types.LeagueSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new LeagueSeason record.

        Parameters
        ----------
        data
            LeagueSeason record data
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The created LeagueSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LeagueSeason record from just the required fields
        leagueseason = await LeagueSeason.prisma().create(
            data={
                # data to create a LeagueSeason record
                'leagueId': 'befcddgjce',
                'seasonId': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeagueSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LeagueSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LeagueSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LeagueSeason.prisma().create_many(
            data=[
                {
                    # data to create a LeagueSeason record
                    'leagueId': 'cabdjadaji',
                    'seasonId': 'faajgfadf',
                },
                {
                    # data to create a LeagueSeason record
                    'leagueId': 'biaagcedjc',
                    'seasonId': 'cahhaghecf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeagueSeasonWhereUniqueInput,
        include: Optional[types.LeagueSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LeagueSeason record.

        Parameters
        ----------
        where
            LeagueSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The deleted LeagueSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leagueseason = await LeagueSeason.prisma().delete(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeagueSeasonWhereUniqueInput,
        include: Optional[types.LeagueSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LeagueSeason record.

        Parameters
        ----------
        where
            LeagueSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The found LeagueSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leagueseason = await LeagueSeason.prisma().find_unique(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeagueSeasonWhereUniqueInput,
        include: Optional[types.LeagueSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LeagueSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LeagueSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The found LeagueSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leagueseason = await LeagueSeason.prisma().find_unique_or_raise(
            where={
                'id': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
        include: Optional[types.LeagueSeasonInclude] = None,
        order: Optional[Union[types.LeagueSeasonOrderByInput, List[types.LeagueSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LeagueSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LeagueSeason records returned
        skip
            Ignore the first N results
        where
            LeagueSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueSeason model
        order
            Order the returned LeagueSeason records by any field
        distinct
            Filter LeagueSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LeagueSeason]
            The list of all LeagueSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LeagueSeason records
        leagueseasons = await LeagueSeason.prisma().find_many(take=10)

        # find the first 5 LeagueSeason records ordered by the seasonId field
        leagueseasons = await LeagueSeason.prisma().find_many(
            take=5,
            order={
                'seasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
        include: Optional[types.LeagueSeasonInclude] = None,
        order: Optional[Union[types.LeagueSeasonOrderByInput, List[types.LeagueSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LeagueSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueSeason model
        order
            Order the returned LeagueSeason records by any field
        distinct
            Filter LeagueSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueSeason
            The first LeagueSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueSeason record ordered by the salaryCap field
        leagueseason = await LeagueSeason.prisma().find_first(
            skip=1,
            order={
                'salaryCap': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
        include: Optional[types.LeagueSeasonInclude] = None,
        order: Optional[Union[types.LeagueSeasonOrderByInput, List[types.LeagueSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LeagueSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueSeason model
        order
            Order the returned LeagueSeason records by any field
        distinct
            Filter LeagueSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueSeason
            The first LeagueSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueSeason record ordered by the createdAt field
        leagueseason = await LeagueSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeagueSeasonUpdateInput,
        where: types.LeagueSeasonWhereUniqueInput,
        include: Optional[types.LeagueSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LeagueSeason record.

        Parameters
        ----------
        data
            LeagueSeason record data specifying what to update
        where
            LeagueSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The updated LeagueSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        leagueseason = await LeagueSeason.prisma().update(
            where={
                'id': 'bhdiaidiaf',
            },
            data={
                # data to update the LeagueSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeagueSeasonWhereUniqueInput,
        data: types.LeagueSeasonUpsertInput,
        include: Optional[types.LeagueSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LeagueSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LeagueSeason model

        Returns
        -------
        prisma.models.LeagueSeason
            The created or updated LeagueSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leagueseason = await LeagueSeason.prisma().upsert(
            where={
                'id': 'deajegcfi',
            },
            data={
                'create': {
                    'id': 'deajegcfi',
                    'leagueId': 'biaagcedjc',
                    'seasonId': 'cahhaghecf',
                },
                'update': {
                    'leagueId': 'biaagcedjc',
                    'seasonId': 'cahhaghecf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeagueSeasonUpdateManyMutationInput,
        where: types.LeagueSeasonWhereInput,
    ) -> int:
        """Update multiple LeagueSeason records

        Parameters
        ----------
        data
            LeagueSeason data to update the selected LeagueSeason records to
        where
            Filter to select the LeagueSeason records to update

        Returns
        -------
        int
            The total number of LeagueSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LeagueSeason records
        total = await LeagueSeason.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LeagueSeason records present in the database

        Parameters
        ----------
        select
            Select the LeagueSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueSeason.prisma().count()

        # results: prisma.types.LeagueSeasonCountAggregateOutput
        results = await LeagueSeason.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeagueSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
    ) -> types.LeagueSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeagueSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueSeasonWhereInput] = None,
        cursor: Optional[types.LeagueSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.LeagueSeasonCountAggregateOutput]:
        """Count the number of LeagueSeason records present in the database

        Parameters
        ----------
        select
            Select the LeagueSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueSeason.prisma().count()

        # results: prisma.types.LeagueSeasonCountAggregateOutput
        results = await LeagueSeason.prisma().count(
            select={
                '_all': True,
                'leagueId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeagueSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeagueSeasonWhereInput] = None
    ) -> int:
        """Delete multiple LeagueSeason records.

        Parameters
        ----------
        where
            Optional LeagueSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LeagueSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LeagueSeason records
        total = await LeagueSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeagueSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.LeagueSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeagueSeasonAvgAggregateInput'] = None,
        sum: Optional['types.LeagueSeasonSumAggregateInput'] = None,
        min: Optional['types.LeagueSeasonMinAggregateInput'] = None,
        max: Optional['types.LeagueSeasonMaxAggregateInput'] = None,
        having: Optional['types.LeagueSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeagueSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeagueSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LeagueSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LeagueSeasonGroupByOutput']:
        """Group LeagueSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LeagueSeason fields to group records by
        where
            LeagueSeason filter to select records
        take
            Limit the maximum number of LeagueSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeagueSeasonGroupByOutput]
            A list of dictionaries representing the LeagueSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LeagueSeason records by seasonId values
        # and count how many records are in each group
        results = await LeagueSeason.prisma().group_by(
            ['seasonId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConferenceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Conference]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Conference.prisma().query_raw(
            'SELECT * FROM Conference WHERE id = $1',
            'gabahhhjf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Conference
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Conference.prisma().query_first(
            'SELECT * FROM Conference WHERE name = $1',
            'cjagadcjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ConferenceCreateInput,
        include: Optional[types.ConferenceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Conference record.

        Parameters
        ----------
        data
            Conference record data
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The created Conference record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Conference record from just the required fields
        conference = await Conference.prisma().create(
            data={
                # data to create a Conference record
                'name': 'bifficggej',
                'leagueId': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConferenceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Conference records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Conference record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Conference.prisma().create_many(
            data=[
                {
                    # data to create a Conference record
                    'name': 'eegghdhjb',
                    'leagueId': 'daafgidjg',
                },
                {
                    # data to create a Conference record
                    'name': 'gdcgcgagj',
                    'leagueId': 'bhceabbgja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConferenceWhereUniqueInput,
        include: Optional[types.ConferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Conference record.

        Parameters
        ----------
        where
            Conference filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The deleted Conference record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conference = await Conference.prisma().delete(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConferenceWhereUniqueInput,
        include: Optional[types.ConferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Conference record.

        Parameters
        ----------
        where
            Conference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The found Conference record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conference = await Conference.prisma().find_unique(
            where={
                'id': 'bcajcajjbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConferenceWhereUniqueInput,
        include: Optional[types.ConferenceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Conference record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Conference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The found Conference record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conference = await Conference.prisma().find_unique_or_raise(
            where={
                'id': 'bfdgheeegf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
        include: Optional[types.ConferenceInclude] = None,
        order: Optional[Union[types.ConferenceOrderByInput, List[types.ConferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConferenceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Conference records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Conference records returned
        skip
            Ignore the first N results
        where
            Conference filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conference model
        order
            Order the returned Conference records by any field
        distinct
            Filter Conference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Conference]
            The list of all Conference records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Conference records
        conferences = await Conference.prisma().find_many(take=10)

        # find the first 5 Conference records ordered by the leagueId field
        conferences = await Conference.prisma().find_many(
            take=5,
            order={
                'leagueId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
        include: Optional[types.ConferenceInclude] = None,
        order: Optional[Union[types.ConferenceOrderByInput, List[types.ConferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConferenceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Conference record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conference model
        order
            Order the returned Conference records by any field
        distinct
            Filter Conference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conference
            The first Conference record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conference record ordered by the id field
        conference = await Conference.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
        include: Optional[types.ConferenceInclude] = None,
        order: Optional[Union[types.ConferenceOrderByInput, List[types.ConferenceOrderByInput]]] = None,
        distinct: Optional[List[types.ConferenceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Conference record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conference model
        order
            Order the returned Conference records by any field
        distinct
            Filter Conference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conference
            The first Conference record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conference record ordered by the name field
        conference = await Conference.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConferenceUpdateInput,
        where: types.ConferenceWhereUniqueInput,
        include: Optional[types.ConferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Conference record.

        Parameters
        ----------
        data
            Conference record data specifying what to update
        where
            Conference filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The updated Conference record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conference = await Conference.prisma().update(
            where={
                'id': 'ececbijji',
            },
            data={
                # data to update the Conference record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConferenceWhereUniqueInput,
        data: types.ConferenceUpsertInput,
        include: Optional[types.ConferenceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Conference filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Conference model

        Returns
        -------
        prisma.models.Conference
            The created or updated Conference record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conference = await Conference.prisma().upsert(
            where={
                'id': 'cbcfgdcdhf',
            },
            data={
                'create': {
                    'id': 'cbcfgdcdhf',
                    'name': 'gdcgcgagj',
                    'leagueId': 'bhceabbgja',
                },
                'update': {
                    'name': 'gdcgcgagj',
                    'leagueId': 'bhceabbgja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConferenceUpdateManyMutationInput,
        where: types.ConferenceWhereInput,
    ) -> int:
        """Update multiple Conference records

        Parameters
        ----------
        data
            Conference data to update the selected Conference records to
        where
            Filter to select the Conference records to update

        Returns
        -------
        int
            The total number of Conference records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Conference records
        total = await Conference.prisma().update_many(
            data={
                'leagueId': 'fdgjfbhia'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Conference records present in the database

        Parameters
        ----------
        select
            Select the Conference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conference.prisma().count()

        # results: prisma.types.ConferenceCountAggregateOutput
        results = await Conference.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConferenceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
    ) -> types.ConferenceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConferenceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConferenceWhereInput] = None,
        cursor: Optional[types.ConferenceWhereUniqueInput] = None,
    ) -> Union[int, types.ConferenceCountAggregateOutput]:
        """Count the number of Conference records present in the database

        Parameters
        ----------
        select
            Select the Conference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conference.prisma().count()

        # results: prisma.types.ConferenceCountAggregateOutput
        results = await Conference.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConferenceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConferenceWhereInput] = None
    ) -> int:
        """Delete multiple Conference records.

        Parameters
        ----------
        where
            Optional Conference filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Conference records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Conference records
        total = await Conference.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConferenceScalarFieldKeysT'],
        *,
        where: Optional['types.ConferenceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConferenceAvgAggregateInput'] = None,
        sum: Optional['types.ConferenceSumAggregateInput'] = None,
        min: Optional['types.ConferenceMinAggregateInput'] = None,
        max: Optional['types.ConferenceMaxAggregateInput'] = None,
        having: Optional['types.ConferenceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConferenceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConferenceScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ConferenceScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ConferenceGroupByOutput']:
        """Group Conference records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Conference fields to group records by
        where
            Conference filter to select records
        take
            Limit the maximum number of Conference records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConferenceGroupByOutput]
            A list of dictionaries representing the Conference record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Conference records by leagueId values
        # and count how many records are in each group
        results = await Conference.prisma().group_by(
            ['leagueId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DivisionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Division]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Division.prisma().query_raw(
            'SELECT * FROM Division WHERE id = $1',
            'jcehcdchh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Division
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Division.prisma().query_first(
            'SELECT * FROM Division WHERE name = $1',
            'bgcbjdhjcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DivisionCreateInput,
        include: Optional[types.DivisionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Division record.

        Parameters
        ----------
        data
            Division record data
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The created Division record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Division record from just the required fields
        division = await Division.prisma().create(
            data={
                # data to create a Division record
                'name': 'bieiidcabj',
                'conferenceId': 'bjcbfcieaa',
                'leagueId': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DivisionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Division records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Division record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Division.prisma().create_many(
            data=[
                {
                    # data to create a Division record
                    'name': 'iejbeaaeg',
                    'conferenceId': 'jcibfcbhf',
                    'leagueId': 'chdadcaga',
                },
                {
                    # data to create a Division record
                    'name': 'jicieifbh',
                    'conferenceId': 'fbahdheji',
                    'leagueId': 'cbbheiicgh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DivisionWhereUniqueInput,
        include: Optional[types.DivisionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Division record.

        Parameters
        ----------
        where
            Division filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The deleted Division record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        division = await Division.prisma().delete(
            where={
                'id': 'beabjeejdg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DivisionWhereUniqueInput,
        include: Optional[types.DivisionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Division record.

        Parameters
        ----------
        where
            Division filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The found Division record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        division = await Division.prisma().find_unique(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DivisionWhereUniqueInput,
        include: Optional[types.DivisionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Division record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Division filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The found Division record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        division = await Division.prisma().find_unique_or_raise(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
        include: Optional[types.DivisionInclude] = None,
        order: Optional[Union[types.DivisionOrderByInput, List[types.DivisionOrderByInput]]] = None,
        distinct: Optional[List[types.DivisionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Division records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Division records returned
        skip
            Ignore the first N results
        where
            Division filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Division model
        order
            Order the returned Division records by any field
        distinct
            Filter Division records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Division]
            The list of all Division records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Division records
        divisions = await Division.prisma().find_many(take=10)

        # find the first 5 Division records ordered by the conferenceId field
        divisions = await Division.prisma().find_many(
            take=5,
            order={
                'conferenceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
        include: Optional[types.DivisionInclude] = None,
        order: Optional[Union[types.DivisionOrderByInput, List[types.DivisionOrderByInput]]] = None,
        distinct: Optional[List[types.DivisionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Division record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Division filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Division model
        order
            Order the returned Division records by any field
        distinct
            Filter Division records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Division
            The first Division record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Division record ordered by the leagueId field
        division = await Division.prisma().find_first(
            skip=1,
            order={
                'leagueId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
        include: Optional[types.DivisionInclude] = None,
        order: Optional[Union[types.DivisionOrderByInput, List[types.DivisionOrderByInput]]] = None,
        distinct: Optional[List[types.DivisionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Division record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Division filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Division model
        order
            Order the returned Division records by any field
        distinct
            Filter Division records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Division
            The first Division record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Division record ordered by the id field
        division = await Division.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DivisionUpdateInput,
        where: types.DivisionWhereUniqueInput,
        include: Optional[types.DivisionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Division record.

        Parameters
        ----------
        data
            Division record data specifying what to update
        where
            Division filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The updated Division record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        division = await Division.prisma().update(
            where={
                'id': 'jhgidcgbf',
            },
            data={
                # data to update the Division record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DivisionWhereUniqueInput,
        data: types.DivisionUpsertInput,
        include: Optional[types.DivisionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Division filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Division model

        Returns
        -------
        prisma.models.Division
            The created or updated Division record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        division = await Division.prisma().upsert(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                'create': {
                    'id': 'bgjgecfejc',
                    'name': 'jicieifbh',
                    'conferenceId': 'fbahdheji',
                    'leagueId': 'cbbheiicgh',
                },
                'update': {
                    'name': 'jicieifbh',
                    'conferenceId': 'fbahdheji',
                    'leagueId': 'cbbheiicgh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DivisionUpdateManyMutationInput,
        where: types.DivisionWhereInput,
    ) -> int:
        """Update multiple Division records

        Parameters
        ----------
        data
            Division data to update the selected Division records to
        where
            Filter to select the Division records to update

        Returns
        -------
        int
            The total number of Division records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Division records
        total = await Division.prisma().update_many(
            data={
                'name': 'bgjcgchib'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Division records present in the database

        Parameters
        ----------
        select
            Select the Division fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Division filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DivisionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Division.prisma().count()

        # results: prisma.types.DivisionCountAggregateOutput
        results = await Division.prisma().count(
            select={
                '_all': True,
                'conferenceId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DivisionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
    ) -> types.DivisionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DivisionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DivisionWhereInput] = None,
        cursor: Optional[types.DivisionWhereUniqueInput] = None,
    ) -> Union[int, types.DivisionCountAggregateOutput]:
        """Count the number of Division records present in the database

        Parameters
        ----------
        select
            Select the Division fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Division filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DivisionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Division.prisma().count()

        # results: prisma.types.DivisionCountAggregateOutput
        results = await Division.prisma().count(
            select={
                '_all': True,
                'leagueId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DivisionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DivisionWhereInput] = None
    ) -> int:
        """Delete multiple Division records.

        Parameters
        ----------
        where
            Optional Division filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Division records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Division records
        total = await Division.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DivisionScalarFieldKeysT'],
        *,
        where: Optional['types.DivisionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DivisionAvgAggregateInput'] = None,
        sum: Optional['types.DivisionSumAggregateInput'] = None,
        min: Optional['types.DivisionMinAggregateInput'] = None,
        max: Optional['types.DivisionMaxAggregateInput'] = None,
        having: Optional['types.DivisionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DivisionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DivisionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.DivisionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.DivisionGroupByOutput']:
        """Group Division records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Division fields to group records by
        where
            Division filter to select records
        take
            Limit the maximum number of Division records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DivisionGroupByOutput]
            A list of dictionaries representing the Division record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Division records by id values
        # and count how many records are in each group
        results = await Division.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Season]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Season.prisma().query_raw(
            'SELECT * FROM Season WHERE id = $1',
            'bacdaibgfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Season
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Season.prisma().query_first(
            'SELECT * FROM Season WHERE seasonNumber = $1',
            327681027,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SeasonCreateInput,
        include: Optional[types.SeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new Season record.

        Parameters
        ----------
        data
            Season record data
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The created Season record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Season record from just the required fields
        season = await Season.prisma().create(
            data={
                # data to create a Season record
                'seasonNumber': 527748992,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Season records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Season record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Season.prisma().create_many(
            data=[
                {
                    # data to create a Season record
                    'seasonNumber': 2029357497,
                },
                {
                    # data to create a Season record
                    'seasonNumber': 1318597118,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Season record.

        Parameters
        ----------
        where
            Season filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The deleted Season record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().delete(
            where={
                'id': 'cbccbbcdfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Season record.

        Parameters
        ----------
        where
            Season filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The found Season record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().find_unique(
            where={
                'id': 'bacejedaca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Season record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Season filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The found Season record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().find_unique_or_raise(
            where={
                'id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Season records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Season records returned
        skip
            Ignore the first N results
        where
            Season filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Season]
            The list of all Season records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Season records
        seasons = await Season.prisma().find_many(take=10)

        # find the first 5 Season records ordered by the isLatest field
        seasons = await Season.prisma().find_many(
            take=5,
            order={
                'isLatest': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Season record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Season filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Season
            The first Season record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Season record ordered by the createdAt field
        season = await Season.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
        include: Optional[types.SeasonInclude] = None,
        order: Optional[Union[types.SeasonOrderByInput, List[types.SeasonOrderByInput]]] = None,
        distinct: Optional[List[types.SeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Season record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Season filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Season model
        order
            Order the returned Season records by any field
        distinct
            Filter Season records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Season
            The first Season record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Season record ordered by the updatedAt field
        season = await Season.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SeasonUpdateInput,
        where: types.SeasonWhereUniqueInput,
        include: Optional[types.SeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Season record.

        Parameters
        ----------
        data
            Season record data specifying what to update
        where
            Season filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The updated Season record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        season = await Season.prisma().update(
            where={
                'id': 'bfjibceaec',
            },
            data={
                # data to update the Season record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SeasonWhereUniqueInput,
        data: types.SeasonUpsertInput,
        include: Optional[types.SeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Season filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Season model

        Returns
        -------
        prisma.models.Season
            The created or updated Season record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        season = await Season.prisma().upsert(
            where={
                'id': 'ibhgcdbgd',
            },
            data={
                'create': {
                    'id': 'ibhgcdbgd',
                    'seasonNumber': 1318597118,
                },
                'update': {
                    'seasonNumber': 1318597118,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SeasonUpdateManyMutationInput,
        where: types.SeasonWhereInput,
    ) -> int:
        """Update multiple Season records

        Parameters
        ----------
        data
            Season data to update the selected Season records to
        where
            Filter to select the Season records to update

        Returns
        -------
        int
            The total number of Season records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Season records
        total = await Season.prisma().update_many(
            data={
                'id': 'badaffhddg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Season records present in the database

        Parameters
        ----------
        select
            Select the Season fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Season filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Season.prisma().count()

        # results: prisma.types.SeasonCountAggregateOutput
        results = await Season.prisma().count(
            select={
                '_all': True,
                'seasonNumber': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> types.SeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SeasonWhereInput] = None,
        cursor: Optional[types.SeasonWhereUniqueInput] = None,
    ) -> Union[int, types.SeasonCountAggregateOutput]:
        """Count the number of Season records present in the database

        Parameters
        ----------
        select
            Select the Season fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Season filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Season.prisma().count()

        # results: prisma.types.SeasonCountAggregateOutput
        results = await Season.prisma().count(
            select={
                '_all': True,
                'isLatest': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SeasonWhereInput] = None
    ) -> int:
        """Delete multiple Season records.

        Parameters
        ----------
        where
            Optional Season filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Season records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Season records
        total = await Season.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SeasonScalarFieldKeysT'],
        *,
        where: Optional['types.SeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SeasonAvgAggregateInput'] = None,
        sum: Optional['types.SeasonSumAggregateInput'] = None,
        min: Optional['types.SeasonMinAggregateInput'] = None,
        max: Optional['types.SeasonMaxAggregateInput'] = None,
        having: Optional['types.SeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SeasonGroupByOutput']:
        """Group Season records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Season fields to group records by
        where
            Season filter to select records
        take
            Limit the maximum number of Season records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SeasonGroupByOutput]
            A list of dictionaries representing the Season record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Season records by createdAt values
        # and count how many records are in each group
        results = await Season.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeagueCommissionerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LeagueCommissioner]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LeagueCommissioner.prisma().query_raw(
            'SELECT * FROM LeagueCommissioner WHERE id = $1',
            'bbdbfcfihd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LeagueCommissioner
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LeagueCommissioner.prisma().query_first(
            'SELECT * FROM LeagueCommissioner WHERE userId = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeagueCommissionerCreateInput,
        include: Optional[types.LeagueCommissionerInclude] = None
    ) -> _PrismaModelT:
        """Create a new LeagueCommissioner record.

        Parameters
        ----------
        data
            LeagueCommissioner record data
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The created LeagueCommissioner record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LeagueCommissioner record from just the required fields
        leaguecommissioner = await LeagueCommissioner.prisma().create(
            data={
                # data to create a LeagueCommissioner record
                'userId': 'bchgafhjed',
                'leagueSeasonId': 'heffgjdei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeagueCommissionerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LeagueCommissioner records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LeagueCommissioner record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LeagueCommissioner.prisma().create_many(
            data=[
                {
                    # data to create a LeagueCommissioner record
                    'userId': 'dahihgbeb',
                    'leagueSeasonId': 'bgheaejbcc',
                },
                {
                    # data to create a LeagueCommissioner record
                    'userId': 'bfcgifeged',
                    'leagueSeasonId': 'jfiahhbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeagueCommissionerWhereUniqueInput,
        include: Optional[types.LeagueCommissionerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LeagueCommissioner record.

        Parameters
        ----------
        where
            LeagueCommissioner filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The deleted LeagueCommissioner record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguecommissioner = await LeagueCommissioner.prisma().delete(
            where={
                'id': 'bfbdafajcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeagueCommissionerWhereUniqueInput,
        include: Optional[types.LeagueCommissionerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LeagueCommissioner record.

        Parameters
        ----------
        where
            LeagueCommissioner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The found LeagueCommissioner record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguecommissioner = await LeagueCommissioner.prisma().find_unique(
            where={
                'id': 'caeghehde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeagueCommissionerWhereUniqueInput,
        include: Optional[types.LeagueCommissionerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LeagueCommissioner record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LeagueCommissioner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The found LeagueCommissioner record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguecommissioner = await LeagueCommissioner.prisma().find_unique_or_raise(
            where={
                'id': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
        include: Optional[types.LeagueCommissionerInclude] = None,
        order: Optional[Union[types.LeagueCommissionerOrderByInput, List[types.LeagueCommissionerOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueCommissionerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LeagueCommissioner records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LeagueCommissioner records returned
        skip
            Ignore the first N results
        where
            LeagueCommissioner filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model
        order
            Order the returned LeagueCommissioner records by any field
        distinct
            Filter LeagueCommissioner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LeagueCommissioner]
            The list of all LeagueCommissioner records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LeagueCommissioner records
        leaguecommissioners = await LeagueCommissioner.prisma().find_many(take=10)

        # find the first 5 LeagueCommissioner records ordered by the leagueSeasonId field
        leaguecommissioners = await LeagueCommissioner.prisma().find_many(
            take=5,
            order={
                'leagueSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
        include: Optional[types.LeagueCommissionerInclude] = None,
        order: Optional[Union[types.LeagueCommissionerOrderByInput, List[types.LeagueCommissionerOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueCommissionerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LeagueCommissioner record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueCommissioner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model
        order
            Order the returned LeagueCommissioner records by any field
        distinct
            Filter LeagueCommissioner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueCommissioner
            The first LeagueCommissioner record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueCommissioner record ordered by the createdAt field
        leaguecommissioner = await LeagueCommissioner.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
        include: Optional[types.LeagueCommissionerInclude] = None,
        order: Optional[Union[types.LeagueCommissionerOrderByInput, List[types.LeagueCommissionerOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueCommissionerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LeagueCommissioner record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueCommissioner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model
        order
            Order the returned LeagueCommissioner records by any field
        distinct
            Filter LeagueCommissioner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueCommissioner
            The first LeagueCommissioner record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueCommissioner record ordered by the updatedAt field
        leaguecommissioner = await LeagueCommissioner.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeagueCommissionerUpdateInput,
        where: types.LeagueCommissionerWhereUniqueInput,
        include: Optional[types.LeagueCommissionerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LeagueCommissioner record.

        Parameters
        ----------
        data
            LeagueCommissioner record data specifying what to update
        where
            LeagueCommissioner filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The updated LeagueCommissioner record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        leaguecommissioner = await LeagueCommissioner.prisma().update(
            where={
                'id': 'bbidjbbjaa',
            },
            data={
                # data to update the LeagueCommissioner record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeagueCommissionerWhereUniqueInput,
        data: types.LeagueCommissionerUpsertInput,
        include: Optional[types.LeagueCommissionerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LeagueCommissioner filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LeagueCommissioner model

        Returns
        -------
        prisma.models.LeagueCommissioner
            The created or updated LeagueCommissioner record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguecommissioner = await LeagueCommissioner.prisma().upsert(
            where={
                'id': 'bfijhaejdd',
            },
            data={
                'create': {
                    'id': 'bfijhaejdd',
                    'userId': 'bfcgifeged',
                    'leagueSeasonId': 'jfiahhbae',
                },
                'update': {
                    'userId': 'bfcgifeged',
                    'leagueSeasonId': 'jfiahhbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeagueCommissionerUpdateManyMutationInput,
        where: types.LeagueCommissionerWhereInput,
    ) -> int:
        """Update multiple LeagueCommissioner records

        Parameters
        ----------
        data
            LeagueCommissioner data to update the selected LeagueCommissioner records to
        where
            Filter to select the LeagueCommissioner records to update

        Returns
        -------
        int
            The total number of LeagueCommissioner records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LeagueCommissioner records
        total = await LeagueCommissioner.prisma().update_many(
            data={
                'id': 'bcedehfiji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LeagueCommissioner records present in the database

        Parameters
        ----------
        select
            Select the LeagueCommissioner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueCommissioner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueCommissionerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueCommissioner.prisma().count()

        # results: prisma.types.LeagueCommissionerCountAggregateOutput
        results = await LeagueCommissioner.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeagueCommissionerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
    ) -> types.LeagueCommissionerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeagueCommissionerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueCommissionerWhereInput] = None,
        cursor: Optional[types.LeagueCommissionerWhereUniqueInput] = None,
    ) -> Union[int, types.LeagueCommissionerCountAggregateOutput]:
        """Count the number of LeagueCommissioner records present in the database

        Parameters
        ----------
        select
            Select the LeagueCommissioner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueCommissioner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueCommissionerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueCommissioner.prisma().count()

        # results: prisma.types.LeagueCommissionerCountAggregateOutput
        results = await LeagueCommissioner.prisma().count(
            select={
                '_all': True,
                'leagueSeasonId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeagueCommissionerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeagueCommissionerWhereInput] = None
    ) -> int:
        """Delete multiple LeagueCommissioner records.

        Parameters
        ----------
        where
            Optional LeagueCommissioner filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LeagueCommissioner records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LeagueCommissioner records
        total = await LeagueCommissioner.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeagueCommissionerScalarFieldKeysT'],
        *,
        where: Optional['types.LeagueCommissionerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeagueCommissionerAvgAggregateInput'] = None,
        sum: Optional['types.LeagueCommissionerSumAggregateInput'] = None,
        min: Optional['types.LeagueCommissionerMinAggregateInput'] = None,
        max: Optional['types.LeagueCommissionerMaxAggregateInput'] = None,
        having: Optional['types.LeagueCommissionerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeagueCommissionerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeagueCommissionerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LeagueCommissionerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LeagueCommissionerGroupByOutput']:
        """Group LeagueCommissioner records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LeagueCommissioner fields to group records by
        where
            LeagueCommissioner filter to select records
        take
            Limit the maximum number of LeagueCommissioner records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeagueCommissionerGroupByOutput]
            A list of dictionaries representing the LeagueCommissioner record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LeagueCommissioner records by createdAt values
        # and count how many records are in each group
        results = await LeagueCommissioner.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeagueBOGActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LeagueBOG]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LeagueBOG.prisma().query_raw(
            'SELECT * FROM LeagueBOG WHERE id = $1',
            'bdgjicijhb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LeagueBOG
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LeagueBOG.prisma().query_first(
            'SELECT * FROM LeagueBOG WHERE userId = $1',
            'bghifjdeia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeagueBOGCreateInput,
        include: Optional[types.LeagueBOGInclude] = None
    ) -> _PrismaModelT:
        """Create a new LeagueBOG record.

        Parameters
        ----------
        data
            LeagueBOG record data
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The created LeagueBOG record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LeagueBOG record from just the required fields
        leaguebog = await LeagueBOG.prisma().create(
            data={
                # data to create a LeagueBOG record
                'userId': 'eadfcbbcb',
                'leagueSeasonId': 'geihgahba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeagueBOGCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LeagueBOG records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LeagueBOG record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LeagueBOG.prisma().create_many(
            data=[
                {
                    # data to create a LeagueBOG record
                    'userId': 'gahdcdhbj',
                    'leagueSeasonId': 'begiijahea',
                },
                {
                    # data to create a LeagueBOG record
                    'userId': 'gcjadjaaf',
                    'leagueSeasonId': 'bcbebgiaic',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeagueBOGWhereUniqueInput,
        include: Optional[types.LeagueBOGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LeagueBOG record.

        Parameters
        ----------
        where
            LeagueBOG filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The deleted LeagueBOG record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguebog = await LeagueBOG.prisma().delete(
            where={
                'id': 'ijigbdcbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeagueBOGWhereUniqueInput,
        include: Optional[types.LeagueBOGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LeagueBOG record.

        Parameters
        ----------
        where
            LeagueBOG filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The found LeagueBOG record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguebog = await LeagueBOG.prisma().find_unique(
            where={
                'id': 'gfidhicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeagueBOGWhereUniqueInput,
        include: Optional[types.LeagueBOGInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LeagueBOG record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LeagueBOG filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The found LeagueBOG record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguebog = await LeagueBOG.prisma().find_unique_or_raise(
            where={
                'id': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
        include: Optional[types.LeagueBOGInclude] = None,
        order: Optional[Union[types.LeagueBOGOrderByInput, List[types.LeagueBOGOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueBOGScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LeagueBOG records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LeagueBOG records returned
        skip
            Ignore the first N results
        where
            LeagueBOG filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueBOG model
        order
            Order the returned LeagueBOG records by any field
        distinct
            Filter LeagueBOG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LeagueBOG]
            The list of all LeagueBOG records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LeagueBOG records
        leaguebogs = await LeagueBOG.prisma().find_many(take=10)

        # find the first 5 LeagueBOG records ordered by the leagueSeasonId field
        leaguebogs = await LeagueBOG.prisma().find_many(
            take=5,
            order={
                'leagueSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
        include: Optional[types.LeagueBOGInclude] = None,
        order: Optional[Union[types.LeagueBOGOrderByInput, List[types.LeagueBOGOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueBOGScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LeagueBOG record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueBOG filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueBOG model
        order
            Order the returned LeagueBOG records by any field
        distinct
            Filter LeagueBOG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueBOG
            The first LeagueBOG record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueBOG record ordered by the createdAt field
        leaguebog = await LeagueBOG.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
        include: Optional[types.LeagueBOGInclude] = None,
        order: Optional[Union[types.LeagueBOGOrderByInput, List[types.LeagueBOGOrderByInput]]] = None,
        distinct: Optional[List[types.LeagueBOGScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LeagueBOG record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeagueBOG filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeagueBOG model
        order
            Order the returned LeagueBOG records by any field
        distinct
            Filter LeagueBOG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeagueBOG
            The first LeagueBOG record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeagueBOG record ordered by the updatedAt field
        leaguebog = await LeagueBOG.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeagueBOGUpdateInput,
        where: types.LeagueBOGWhereUniqueInput,
        include: Optional[types.LeagueBOGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LeagueBOG record.

        Parameters
        ----------
        data
            LeagueBOG record data specifying what to update
        where
            LeagueBOG filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The updated LeagueBOG record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        leaguebog = await LeagueBOG.prisma().update(
            where={
                'id': 'bcbeiajjfa',
            },
            data={
                # data to update the LeagueBOG record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeagueBOGWhereUniqueInput,
        data: types.LeagueBOGUpsertInput,
        include: Optional[types.LeagueBOGInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LeagueBOG filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LeagueBOG model

        Returns
        -------
        prisma.models.LeagueBOG
            The created or updated LeagueBOG record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leaguebog = await LeagueBOG.prisma().upsert(
            where={
                'id': 'baehicaajf',
            },
            data={
                'create': {
                    'id': 'baehicaajf',
                    'userId': 'gcjadjaaf',
                    'leagueSeasonId': 'bcbebgiaic',
                },
                'update': {
                    'userId': 'gcjadjaaf',
                    'leagueSeasonId': 'bcbebgiaic',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeagueBOGUpdateManyMutationInput,
        where: types.LeagueBOGWhereInput,
    ) -> int:
        """Update multiple LeagueBOG records

        Parameters
        ----------
        data
            LeagueBOG data to update the selected LeagueBOG records to
        where
            Filter to select the LeagueBOG records to update

        Returns
        -------
        int
            The total number of LeagueBOG records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LeagueBOG records
        total = await LeagueBOG.prisma().update_many(
            data={
                'id': 'bdachdeiga'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LeagueBOG records present in the database

        Parameters
        ----------
        select
            Select the LeagueBOG fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueBOG filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueBOGCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueBOG.prisma().count()

        # results: prisma.types.LeagueBOGCountAggregateOutput
        results = await LeagueBOG.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeagueBOGCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
    ) -> types.LeagueBOGCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeagueBOGCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeagueBOGWhereInput] = None,
        cursor: Optional[types.LeagueBOGWhereUniqueInput] = None,
    ) -> Union[int, types.LeagueBOGCountAggregateOutput]:
        """Count the number of LeagueBOG records present in the database

        Parameters
        ----------
        select
            Select the LeagueBOG fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeagueBOG filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeagueBOGCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeagueBOG.prisma().count()

        # results: prisma.types.LeagueBOGCountAggregateOutput
        results = await LeagueBOG.prisma().count(
            select={
                '_all': True,
                'leagueSeasonId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeagueBOGCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeagueBOGWhereInput] = None
    ) -> int:
        """Delete multiple LeagueBOG records.

        Parameters
        ----------
        where
            Optional LeagueBOG filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LeagueBOG records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LeagueBOG records
        total = await LeagueBOG.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeagueBOGScalarFieldKeysT'],
        *,
        where: Optional['types.LeagueBOGWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeagueBOGAvgAggregateInput'] = None,
        sum: Optional['types.LeagueBOGSumAggregateInput'] = None,
        min: Optional['types.LeagueBOGMinAggregateInput'] = None,
        max: Optional['types.LeagueBOGMaxAggregateInput'] = None,
        having: Optional['types.LeagueBOGScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeagueBOGCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeagueBOGScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LeagueBOGScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LeagueBOGGroupByOutput']:
        """Group LeagueBOG records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LeagueBOG fields to group records by
        where
            LeagueBOG filter to select records
        take
            Limit the maximum number of LeagueBOG records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeagueBOGGroupByOutput]
            A list of dictionaries representing the LeagueBOG record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LeagueBOG records by createdAt values
        # and count how many records are in each group
        results = await LeagueBOG.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MatchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Match]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Match.prisma().query_raw(
            'SELECT * FROM Match WHERE id = $1',
            'ijdafccef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Match
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Match.prisma().query_first(
            'SELECT * FROM Match WHERE teamSeasonId = $1',
            'ciaaiddag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MatchCreateInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Create a new Match record.

        Parameters
        ----------
        data
            Match record data
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created Match record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Match record from just the required fields
        match = await Match.prisma().create(
            data={
                # data to create a Match record
                'teamSeasonId': 'fejggijff',
                'eaMatchId': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MatchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Match records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Match record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Match.prisma().create_many(
            data=[
                {
                    # data to create a Match record
                    'teamSeasonId': 'cajicjjdef',
                    'eaMatchId': 'cefjaadec',
                },
                {
                    # data to create a Match record
                    'teamSeasonId': 'ibbigdigd',
                    'eaMatchId': 'bdiiiabbii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Match record.

        Parameters
        ----------
        where
            Match filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The deleted Match record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().delete(
            where={
                'id': 'hfcfhhadh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Match record.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().find_unique(
            where={
                'id': 'bbihggdcji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Match record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().find_unique_or_raise(
            where={
                'id': 'hgjgibdgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Match records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N results
        where
            Match filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Match]
            The list of all Match records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Match records
        matchs = await Match.prisma().find_many(take=10)

        # find the first 5 Match records ordered by the eaMatchId field
        matchs = await Match.prisma().find_many(
            take=5,
            order={
                'eaMatchId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Match record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the createdAt field
        match = await Match.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Match record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the updatedAt field
        match = await Match.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MatchUpdateInput,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Match record.

        Parameters
        ----------
        data
            Match record data specifying what to update
        where
            Match filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The updated Match record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        match = await Match.prisma().update(
            where={
                'id': 'bcbecjfice',
            },
            data={
                # data to update the Match record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MatchWhereUniqueInput,
        data: types.MatchUpsertInput,
        include: Optional[types.MatchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Match filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created or updated Match record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = await Match.prisma().upsert(
            where={
                'id': 'bacbebhjjd',
            },
            data={
                'create': {
                    'id': 'bacbebhjjd',
                    'teamSeasonId': 'ibbigdigd',
                    'eaMatchId': 'bdiiiabbii',
                },
                'update': {
                    'teamSeasonId': 'ibbigdigd',
                    'eaMatchId': 'bdiiiabbii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MatchUpdateManyMutationInput,
        where: types.MatchWhereInput,
    ) -> int:
        """Update multiple Match records

        Parameters
        ----------
        data
            Match data to update the selected Match records to
        where
            Filter to select the Match records to update

        Returns
        -------
        int
            The total number of Match records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Match records
        total = await Match.prisma().update_many(
            data={
                'id': 'dfbfaddhe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = await Match.prisma().count(
            select={
                '_all': True,
                'teamSeasonId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MatchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> types.MatchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MatchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> Union[int, types.MatchCountAggregateOutput]:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = await Match.prisma().count(
            select={
                '_all': True,
                'eaMatchId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MatchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MatchWhereInput] = None
    ) -> int:
        """Delete multiple Match records.

        Parameters
        ----------
        where
            Optional Match filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Match records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Match records
        total = await Match.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MatchScalarFieldKeysT'],
        *,
        where: Optional['types.MatchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MatchAvgAggregateInput'] = None,
        sum: Optional['types.MatchSumAggregateInput'] = None,
        min: Optional['types.MatchMinAggregateInput'] = None,
        max: Optional['types.MatchMaxAggregateInput'] = None,
        having: Optional['types.MatchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MatchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MatchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.MatchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.MatchGroupByOutput']:
        """Group Match records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Match fields to group records by
        where
            Match filter to select records
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MatchGroupByOutput]
            A list of dictionaries representing the Match record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Match records by createdAt values
        # and count how many records are in each group
        results = await Match.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClubMatchStatsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ClubMatchStats]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ClubMatchStats.prisma().query_raw(
            'SELECT * FROM ClubMatchStats WHERE id = $1',
            'bdcbbieibf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ClubMatchStats
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ClubMatchStats.prisma().query_first(
            'SELECT * FROM ClubMatchStats WHERE matchId = $1',
            'dgjhdcggi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ClubMatchStatsCreateInput,
        include: Optional[types.ClubMatchStatsInclude] = None
    ) -> _PrismaModelT:
        """Create a new ClubMatchStats record.

        Parameters
        ----------
        data
            ClubMatchStats record data
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The created ClubMatchStats record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ClubMatchStats record from just the required fields
        clubmatchstats = await ClubMatchStats.prisma().create(
            data={
                # data to create a ClubMatchStats record
                'matchId': 'bbjbcdfabd',
                'clubDivision': 627561242,
                'cNhlOnlineGameType': 'bihcjfcjah',
                'goalsAgainstRaw': 1793282088,
                'goalsForRaw': 1814397249,
                'losses': 1923090150,
                'result': 1277244455,
                'score': 1160857300,
                'scoreString': 'dgbcdaegb',
                'winnerByDnf': 1406511986,
                'winnerByGoalieDnf': 1482877891,
                'memberString': 'fgggcdcjg',
                'passesAttempted': 229119865,
                'passesCompleted': 1750011070,
                'powerplayGoals': 410943775,
                'powerplayOpportunities': 909024364,
                'shots': 755610165,
                'teamArtAbbr': 'biacbiieja',
                'teamSide': 294916155,
                'timeOnAttack': 564073304,
                'opponentClubId': 'diageigcf',
                'opponentScore': 1030616470,
                'opponentTeamArtAbbr': 'ibgebbjch',
                'goals': 1084099844,
                'goalsAgainst': 1079702253,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClubMatchStatsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ClubMatchStats records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ClubMatchStats record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ClubMatchStats.prisma().create_many(
            data=[
                {
                    # data to create a ClubMatchStats record
                    'matchId': 'hffhfabhi',
                    'clubDivision': 1128680371,
                    'cNhlOnlineGameType': 'cfjagbbae',
                    'goalsAgainstRaw': 1115738345,
                    'goalsForRaw': 1303781742,
                    'losses': 1573908495,
                    'result': 1195899036,
                    'score': 739021477,
                    'scoreString': 'bhcccbeaba',
                    'winnerByDnf': 1269136939,
                    'winnerByGoalieDnf': 573178504,
                    'memberString': 'beeacgfcej',
                    'passesAttempted': 1185738822,
                    'passesCompleted': 1694224903,
                    'powerplayGoals': 1906360116,
                    'powerplayOpportunities': 1911255389,
                    'shots': 146262738,
                    'teamArtAbbr': 'bhbjceagbb',
                    'teamSide': 1948555936,
                    'timeOnAttack': 1383253593,
                    'opponentClubId': 'dfeggejja',
                    'opponentScore': 647166719,
                    'opponentTeamArtAbbr': 'dfhaijeie',
                    'goals': 612396821,
                    'goalsAgainst': 1808130602,
                },
                {
                    # data to create a ClubMatchStats record
                    'matchId': 'bbfbheibcd',
                    'clubDivision': 78060984,
                    'cNhlOnlineGameType': 'eeejidbif',
                    'goalsAgainstRaw': 45610742,
                    'goalsForRaw': 769084151,
                    'losses': 1334599012,
                    'result': 1116761037,
                    'score': 1172606082,
                    'scoreString': 'ddaabegbb',
                    'winnerByDnf': 1768156112,
                    'winnerByGoalieDnf': 71628745,
                    'memberString': 'ffhgghde',
                    'passesAttempted': 812032495,
                    'passesCompleted': 1323562236,
                    'powerplayGoals': 43796357,
                    'powerplayOpportunities': 1345530330,
                    'shots': 1965387275,
                    'teamArtAbbr': 'iaeihdeei',
                    'teamSide': 1566496513,
                    'timeOnAttack': 850004390,
                    'opponentClubId': 'cbajdjjabf',
                    'opponentScore': 1282664340,
                    'opponentTeamArtAbbr': 'cebcdadjh',
                    'goals': 475863602,
                    'goalsAgainst': 1716228995,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClubMatchStatsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ClubMatchStats record.

        Parameters
        ----------
        where
            ClubMatchStats filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The deleted ClubMatchStats record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstats = await ClubMatchStats.prisma().delete(
            where={
                'id': 'bigjhdgbjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClubMatchStatsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ClubMatchStats record.

        Parameters
        ----------
        where
            ClubMatchStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The found ClubMatchStats record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstats = await ClubMatchStats.prisma().find_unique(
            where={
                'id': 'bfifdebhfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClubMatchStatsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ClubMatchStats record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ClubMatchStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The found ClubMatchStats record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstats = await ClubMatchStats.prisma().find_unique_or_raise(
            where={
                'id': 'cjchbjde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsOrderByInput, List[types.ClubMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ClubMatchStats records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ClubMatchStats records returned
        skip
            Ignore the first N results
        where
            ClubMatchStats filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model
        order
            Order the returned ClubMatchStats records by any field
        distinct
            Filter ClubMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ClubMatchStats]
            The list of all ClubMatchStats records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ClubMatchStats records
        clubmatchstats = await ClubMatchStats.prisma().find_many(take=10)

        # find the first 5 ClubMatchStats records ordered by the clubDivision field
        clubmatchstats = await ClubMatchStats.prisma().find_many(
            take=5,
            order={
                'clubDivision': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsOrderByInput, List[types.ClubMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ClubMatchStats record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubMatchStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model
        order
            Order the returned ClubMatchStats records by any field
        distinct
            Filter ClubMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubMatchStats
            The first ClubMatchStats record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubMatchStats record ordered by the cNhlOnlineGameType field
        clubmatchstats = await ClubMatchStats.prisma().find_first(
            skip=1,
            order={
                'cNhlOnlineGameType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsOrderByInput, List[types.ClubMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ClubMatchStats record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubMatchStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model
        order
            Order the returned ClubMatchStats records by any field
        distinct
            Filter ClubMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubMatchStats
            The first ClubMatchStats record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubMatchStats record ordered by the goalsAgainstRaw field
        clubmatchstats = await ClubMatchStats.prisma().find_first_or_raise(
            skip=1,
            order={
                'goalsAgainstRaw': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClubMatchStatsUpdateInput,
        where: types.ClubMatchStatsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ClubMatchStats record.

        Parameters
        ----------
        data
            ClubMatchStats record data specifying what to update
        where
            ClubMatchStats filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The updated ClubMatchStats record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        clubmatchstats = await ClubMatchStats.prisma().update(
            where={
                'id': 'bfiibjcehj',
            },
            data={
                # data to update the ClubMatchStats record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClubMatchStatsWhereUniqueInput,
        data: types.ClubMatchStatsUpsertInput,
        include: Optional[types.ClubMatchStatsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ClubMatchStats filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ClubMatchStats model

        Returns
        -------
        prisma.models.ClubMatchStats
            The created or updated ClubMatchStats record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstats = await ClubMatchStats.prisma().upsert(
            where={
                'id': 'ijieafghg',
            },
            data={
                'create': {
                    'id': 'ijieafghg',
                    'matchId': 'bbfbheibcd',
                    'clubDivision': 78060984,
                    'cNhlOnlineGameType': 'eeejidbif',
                    'goalsAgainstRaw': 45610742,
                    'goalsForRaw': 769084151,
                    'losses': 1334599012,
                    'result': 1116761037,
                    'score': 1172606082,
                    'scoreString': 'ddaabegbb',
                    'winnerByDnf': 1768156112,
                    'winnerByGoalieDnf': 71628745,
                    'memberString': 'ffhgghde',
                    'passesAttempted': 812032495,
                    'passesCompleted': 1323562236,
                    'powerplayGoals': 43796357,
                    'powerplayOpportunities': 1345530330,
                    'shots': 1965387275,
                    'teamArtAbbr': 'iaeihdeei',
                    'teamSide': 1566496513,
                    'timeOnAttack': 850004390,
                    'opponentClubId': 'cbajdjjabf',
                    'opponentScore': 1282664340,
                    'opponentTeamArtAbbr': 'cebcdadjh',
                    'goals': 475863602,
                    'goalsAgainst': 1716228995,
                },
                'update': {
                    'matchId': 'bbfbheibcd',
                    'clubDivision': 78060984,
                    'cNhlOnlineGameType': 'eeejidbif',
                    'goalsAgainstRaw': 45610742,
                    'goalsForRaw': 769084151,
                    'losses': 1334599012,
                    'result': 1116761037,
                    'score': 1172606082,
                    'scoreString': 'ddaabegbb',
                    'winnerByDnf': 1768156112,
                    'winnerByGoalieDnf': 71628745,
                    'memberString': 'ffhgghde',
                    'passesAttempted': 812032495,
                    'passesCompleted': 1323562236,
                    'powerplayGoals': 43796357,
                    'powerplayOpportunities': 1345530330,
                    'shots': 1965387275,
                    'teamArtAbbr': 'iaeihdeei',
                    'teamSide': 1566496513,
                    'timeOnAttack': 850004390,
                    'opponentClubId': 'cbajdjjabf',
                    'opponentScore': 1282664340,
                    'opponentTeamArtAbbr': 'cebcdadjh',
                    'goals': 475863602,
                    'goalsAgainst': 1716228995,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClubMatchStatsUpdateManyMutationInput,
        where: types.ClubMatchStatsWhereInput,
    ) -> int:
        """Update multiple ClubMatchStats records

        Parameters
        ----------
        data
            ClubMatchStats data to update the selected ClubMatchStats records to
        where
            Filter to select the ClubMatchStats records to update

        Returns
        -------
        int
            The total number of ClubMatchStats records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ClubMatchStats records
        total = await ClubMatchStats.prisma().update_many(
            data={
                'goalsForRaw': 777460725
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ClubMatchStats records present in the database

        Parameters
        ----------
        select
            Select the ClubMatchStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubMatchStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubMatchStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubMatchStats.prisma().count()

        # results: prisma.types.ClubMatchStatsCountAggregateOutput
        results = await ClubMatchStats.prisma().count(
            select={
                '_all': True,
                'losses': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClubMatchStatsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
    ) -> types.ClubMatchStatsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClubMatchStatsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsWhereUniqueInput] = None,
    ) -> Union[int, types.ClubMatchStatsCountAggregateOutput]:
        """Count the number of ClubMatchStats records present in the database

        Parameters
        ----------
        select
            Select the ClubMatchStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubMatchStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubMatchStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubMatchStats.prisma().count()

        # results: prisma.types.ClubMatchStatsCountAggregateOutput
        results = await ClubMatchStats.prisma().count(
            select={
                '_all': True,
                'result': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClubMatchStatsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClubMatchStatsWhereInput] = None
    ) -> int:
        """Delete multiple ClubMatchStats records.

        Parameters
        ----------
        where
            Optional ClubMatchStats filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ClubMatchStats records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ClubMatchStats records
        total = await ClubMatchStats.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClubMatchStatsScalarFieldKeysT'],
        *,
        where: Optional['types.ClubMatchStatsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClubMatchStatsAvgAggregateInput'] = None,
        sum: Optional['types.ClubMatchStatsSumAggregateInput'] = None,
        min: Optional['types.ClubMatchStatsMinAggregateInput'] = None,
        max: Optional['types.ClubMatchStatsMaxAggregateInput'] = None,
        having: Optional['types.ClubMatchStatsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClubMatchStatsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClubMatchStatsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ClubMatchStatsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ClubMatchStatsGroupByOutput']:
        """Group ClubMatchStats records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ClubMatchStats fields to group records by
        where
            ClubMatchStats filter to select records
        take
            Limit the maximum number of ClubMatchStats records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClubMatchStatsGroupByOutput]
            A list of dictionaries representing the ClubMatchStats record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ClubMatchStats records by score values
        # and count how many records are in each group
        results = await ClubMatchStats.prisma().group_by(
            ['score'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClubMatchStatsDetailsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ClubMatchStatsDetails]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ClubMatchStatsDetails.prisma().query_raw(
            'SELECT * FROM ClubMatchStatsDetails WHERE id = $1',
            'edhijefdi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ClubMatchStatsDetails.prisma().query_first(
            'SELECT * FROM ClubMatchStatsDetails WHERE clubMatchStatsId = $1',
            'djddecjhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ClubMatchStatsDetailsCreateInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None
    ) -> _PrismaModelT:
        """Create a new ClubMatchStatsDetails record.

        Parameters
        ----------
        data
            ClubMatchStatsDetails record data
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The created ClubMatchStatsDetails record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ClubMatchStatsDetails record from just the required fields
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().create(
            data={
                # data to create a ClubMatchStatsDetails record
                'clubMatchStatsId': 'bgdicjhie',
                'name': 'ceibfcgij',
                'eaClubId': 341715030,
                'regionId': 1692766423,
                'teamId': 86662596,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClubMatchStatsDetailsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ClubMatchStatsDetails records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ClubMatchStatsDetails record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ClubMatchStatsDetails.prisma().create_many(
            data=[
                {
                    # data to create a ClubMatchStatsDetails record
                    'clubMatchStatsId': 'bgjhijffjh',
                    'name': 'bcigdhache',
                    'eaClubId': 864576371,
                    'regionId': 491885104,
                    'teamId': 392564393,
                },
                {
                    # data to create a ClubMatchStatsDetails record
                    'clubMatchStatsId': 'bdbjcdegag',
                    'name': 'hbchfebch',
                    'eaClubId': 1299554652,
                    'regionId': 2070408293,
                    'teamId': 811900218,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClubMatchStatsDetailsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ClubMatchStatsDetails record.

        Parameters
        ----------
        where
            ClubMatchStatsDetails filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The deleted ClubMatchStatsDetails record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().delete(
            where={
                'id': 'djgacbcch',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClubMatchStatsDetailsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ClubMatchStatsDetails record.

        Parameters
        ----------
        where
            ClubMatchStatsDetails filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The found ClubMatchStatsDetails record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_unique(
            where={
                'id': 'geeeegace',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClubMatchStatsDetailsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ClubMatchStatsDetails record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ClubMatchStatsDetails filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The found ClubMatchStatsDetails record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_unique_or_raise(
            where={
                'id': 'bbgdigchd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsDetailsOrderByInput, List[types.ClubMatchStatsDetailsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsDetailsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ClubMatchStatsDetails records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ClubMatchStatsDetails records returned
        skip
            Ignore the first N results
        where
            ClubMatchStatsDetails filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model
        order
            Order the returned ClubMatchStatsDetails records by any field
        distinct
            Filter ClubMatchStatsDetails records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ClubMatchStatsDetails]
            The list of all ClubMatchStatsDetails records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ClubMatchStatsDetails records
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_many(take=10)

        # find the first 5 ClubMatchStatsDetails records ordered by the name field
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsDetailsOrderByInput, List[types.ClubMatchStatsDetailsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsDetailsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ClubMatchStatsDetails record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubMatchStatsDetails filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model
        order
            Order the returned ClubMatchStatsDetails records by any field
        distinct
            Filter ClubMatchStatsDetails records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The first ClubMatchStatsDetails record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubMatchStatsDetails record ordered by the eaClubId field
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_first(
            skip=1,
            order={
                'eaClubId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None,
        order: Optional[Union[types.ClubMatchStatsDetailsOrderByInput, List[types.ClubMatchStatsDetailsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubMatchStatsDetailsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ClubMatchStatsDetails record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubMatchStatsDetails filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model
        order
            Order the returned ClubMatchStatsDetails records by any field
        distinct
            Filter ClubMatchStatsDetails records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The first ClubMatchStatsDetails record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubMatchStatsDetails record ordered by the regionId field
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().find_first_or_raise(
            skip=1,
            order={
                'regionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClubMatchStatsDetailsUpdateInput,
        where: types.ClubMatchStatsDetailsWhereUniqueInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ClubMatchStatsDetails record.

        Parameters
        ----------
        data
            ClubMatchStatsDetails record data specifying what to update
        where
            ClubMatchStatsDetails filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The updated ClubMatchStatsDetails record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().update(
            where={
                'id': 'dajcifgdi',
            },
            data={
                # data to update the ClubMatchStatsDetails record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClubMatchStatsDetailsWhereUniqueInput,
        data: types.ClubMatchStatsDetailsUpsertInput,
        include: Optional[types.ClubMatchStatsDetailsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ClubMatchStatsDetails filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ClubMatchStatsDetails model

        Returns
        -------
        prisma.models.ClubMatchStatsDetails
            The created or updated ClubMatchStatsDetails record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubmatchstatsdetails = await ClubMatchStatsDetails.prisma().upsert(
            where={
                'id': 'ccedhdbj',
            },
            data={
                'create': {
                    'id': 'ccedhdbj',
                    'clubMatchStatsId': 'bdbjcdegag',
                    'name': 'hbchfebch',
                    'eaClubId': 1299554652,
                    'regionId': 2070408293,
                    'teamId': 811900218,
                },
                'update': {
                    'clubMatchStatsId': 'bdbjcdegag',
                    'name': 'hbchfebch',
                    'eaClubId': 1299554652,
                    'regionId': 2070408293,
                    'teamId': 811900218,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClubMatchStatsDetailsUpdateManyMutationInput,
        where: types.ClubMatchStatsDetailsWhereInput,
    ) -> int:
        """Update multiple ClubMatchStatsDetails records

        Parameters
        ----------
        data
            ClubMatchStatsDetails data to update the selected ClubMatchStatsDetails records to
        where
            Filter to select the ClubMatchStatsDetails records to update

        Returns
        -------
        int
            The total number of ClubMatchStatsDetails records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ClubMatchStatsDetails records
        total = await ClubMatchStatsDetails.prisma().update_many(
            data={
                'teamId': 1900199924
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ClubMatchStatsDetails records present in the database

        Parameters
        ----------
        select
            Select the ClubMatchStatsDetails fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubMatchStatsDetails filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubMatchStatsDetailsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubMatchStatsDetails.prisma().count()

        # results: prisma.types.ClubMatchStatsDetailsCountAggregateOutput
        results = await ClubMatchStatsDetails.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClubMatchStatsDetailsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
    ) -> types.ClubMatchStatsDetailsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClubMatchStatsDetailsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None,
        cursor: Optional[types.ClubMatchStatsDetailsWhereUniqueInput] = None,
    ) -> Union[int, types.ClubMatchStatsDetailsCountAggregateOutput]:
        """Count the number of ClubMatchStatsDetails records present in the database

        Parameters
        ----------
        select
            Select the ClubMatchStatsDetails fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubMatchStatsDetails filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubMatchStatsDetailsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubMatchStatsDetails.prisma().count()

        # results: prisma.types.ClubMatchStatsDetailsCountAggregateOutput
        results = await ClubMatchStatsDetails.prisma().count(
            select={
                '_all': True,
                'clubMatchStatsId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClubMatchStatsDetailsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClubMatchStatsDetailsWhereInput] = None
    ) -> int:
        """Delete multiple ClubMatchStatsDetails records.

        Parameters
        ----------
        where
            Optional ClubMatchStatsDetails filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ClubMatchStatsDetails records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ClubMatchStatsDetails records
        total = await ClubMatchStatsDetails.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClubMatchStatsDetailsScalarFieldKeysT'],
        *,
        where: Optional['types.ClubMatchStatsDetailsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClubMatchStatsDetailsAvgAggregateInput'] = None,
        sum: Optional['types.ClubMatchStatsDetailsSumAggregateInput'] = None,
        min: Optional['types.ClubMatchStatsDetailsMinAggregateInput'] = None,
        max: Optional['types.ClubMatchStatsDetailsMaxAggregateInput'] = None,
        having: Optional['types.ClubMatchStatsDetailsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClubMatchStatsDetailsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClubMatchStatsDetailsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ClubMatchStatsDetailsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ClubMatchStatsDetailsGroupByOutput']:
        """Group ClubMatchStatsDetails records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ClubMatchStatsDetails fields to group records by
        where
            ClubMatchStatsDetails filter to select records
        take
            Limit the maximum number of ClubMatchStatsDetails records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClubMatchStatsDetailsGroupByOutput]
            A list of dictionaries representing the ClubMatchStatsDetails record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ClubMatchStatsDetails records by name values
        # and count how many records are in each group
        results = await ClubMatchStatsDetails.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CustomKitActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CustomKit]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CustomKit.prisma().query_raw(
            'SELECT * FROM CustomKit WHERE id = $1',
            'cafhdcdcjd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CustomKit
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CustomKit.prisma().query_first(
            'SELECT * FROM CustomKit WHERE detailsId = $1',
            'bdeebbhbdi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CustomKitCreateInput,
        include: Optional[types.CustomKitInclude] = None
    ) -> _PrismaModelT:
        """Create a new CustomKit record.

        Parameters
        ----------
        data
            CustomKit record data
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The created CustomKit record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CustomKit record from just the required fields
        customkit = await CustomKit.prisma().create(
            data={
                # data to create a CustomKit record
                'detailsId': 'cafcbdchah',
                'isCustomTeam': 1355147104,
                'crestAssetId': 84079641,
                'useBaseAsset': 754433246,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CustomKitCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CustomKit records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CustomKit record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CustomKit.prisma().create_many(
            data=[
                {
                    # data to create a CustomKit record
                    'detailsId': 'dbecgbbid',
                    'isCustomTeam': 227678604,
                    'crestAssetId': 423999701,
                    'useBaseAsset': 180275434,
                },
                {
                    # data to create a CustomKit record
                    'detailsId': 'fhgaibff',
                    'isCustomTeam': 2030912120,
                    'crestAssetId': 1974865233,
                    'useBaseAsset': 1949862326,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CustomKitWhereUniqueInput,
        include: Optional[types.CustomKitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CustomKit record.

        Parameters
        ----------
        where
            CustomKit filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The deleted CustomKit record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customkit = await CustomKit.prisma().delete(
            where={
                'id': 'bifiiibcah',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CustomKitWhereUniqueInput,
        include: Optional[types.CustomKitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CustomKit record.

        Parameters
        ----------
        where
            CustomKit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The found CustomKit record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customkit = await CustomKit.prisma().find_unique(
            where={
                'id': 'dbjibjdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CustomKitWhereUniqueInput,
        include: Optional[types.CustomKitInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CustomKit record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CustomKit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The found CustomKit record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customkit = await CustomKit.prisma().find_unique_or_raise(
            where={
                'id': 'dgijbdiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
        include: Optional[types.CustomKitInclude] = None,
        order: Optional[Union[types.CustomKitOrderByInput, List[types.CustomKitOrderByInput]]] = None,
        distinct: Optional[List[types.CustomKitScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CustomKit records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CustomKit records returned
        skip
            Ignore the first N results
        where
            CustomKit filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CustomKit model
        order
            Order the returned CustomKit records by any field
        distinct
            Filter CustomKit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CustomKit]
            The list of all CustomKit records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CustomKit records
        customkits = await CustomKit.prisma().find_many(take=10)

        # find the first 5 CustomKit records ordered by the isCustomTeam field
        customkits = await CustomKit.prisma().find_many(
            take=5,
            order={
                'isCustomTeam': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
        include: Optional[types.CustomKitInclude] = None,
        order: Optional[Union[types.CustomKitOrderByInput, List[types.CustomKitOrderByInput]]] = None,
        distinct: Optional[List[types.CustomKitScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CustomKit record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CustomKit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CustomKit model
        order
            Order the returned CustomKit records by any field
        distinct
            Filter CustomKit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CustomKit
            The first CustomKit record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CustomKit record ordered by the crestAssetId field
        customkit = await CustomKit.prisma().find_first(
            skip=1,
            order={
                'crestAssetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
        include: Optional[types.CustomKitInclude] = None,
        order: Optional[Union[types.CustomKitOrderByInput, List[types.CustomKitOrderByInput]]] = None,
        distinct: Optional[List[types.CustomKitScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CustomKit record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CustomKit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CustomKit model
        order
            Order the returned CustomKit records by any field
        distinct
            Filter CustomKit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CustomKit
            The first CustomKit record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CustomKit record ordered by the useBaseAsset field
        customkit = await CustomKit.prisma().find_first_or_raise(
            skip=1,
            order={
                'useBaseAsset': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CustomKitUpdateInput,
        where: types.CustomKitWhereUniqueInput,
        include: Optional[types.CustomKitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CustomKit record.

        Parameters
        ----------
        data
            CustomKit record data specifying what to update
        where
            CustomKit filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The updated CustomKit record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        customkit = await CustomKit.prisma().update(
            where={
                'id': 'begfaigba',
            },
            data={
                # data to update the CustomKit record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CustomKitWhereUniqueInput,
        data: types.CustomKitUpsertInput,
        include: Optional[types.CustomKitInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CustomKit filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CustomKit model

        Returns
        -------
        prisma.models.CustomKit
            The created or updated CustomKit record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customkit = await CustomKit.prisma().upsert(
            where={
                'id': 'bdjiafcgjb',
            },
            data={
                'create': {
                    'id': 'bdjiafcgjb',
                    'detailsId': 'fhgaibff',
                    'isCustomTeam': 2030912120,
                    'crestAssetId': 1974865233,
                    'useBaseAsset': 1949862326,
                },
                'update': {
                    'detailsId': 'fhgaibff',
                    'isCustomTeam': 2030912120,
                    'crestAssetId': 1974865233,
                    'useBaseAsset': 1949862326,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CustomKitUpdateManyMutationInput,
        where: types.CustomKitWhereInput,
    ) -> int:
        """Update multiple CustomKit records

        Parameters
        ----------
        data
            CustomKit data to update the selected CustomKit records to
        where
            Filter to select the CustomKit records to update

        Returns
        -------
        int
            The total number of CustomKit records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CustomKit records
        total = await CustomKit.prisma().update_many(
            data={
                'id': 'bficecgcfg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CustomKit records present in the database

        Parameters
        ----------
        select
            Select the CustomKit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CustomKit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomKitCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CustomKit.prisma().count()

        # results: prisma.types.CustomKitCountAggregateOutput
        results = await CustomKit.prisma().count(
            select={
                '_all': True,
                'detailsId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CustomKitCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
    ) -> types.CustomKitCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CustomKitCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomKitWhereInput] = None,
        cursor: Optional[types.CustomKitWhereUniqueInput] = None,
    ) -> Union[int, types.CustomKitCountAggregateOutput]:
        """Count the number of CustomKit records present in the database

        Parameters
        ----------
        select
            Select the CustomKit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CustomKit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomKitCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CustomKit.prisma().count()

        # results: prisma.types.CustomKitCountAggregateOutput
        results = await CustomKit.prisma().count(
            select={
                '_all': True,
                'isCustomTeam': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CustomKitCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CustomKitWhereInput] = None
    ) -> int:
        """Delete multiple CustomKit records.

        Parameters
        ----------
        where
            Optional CustomKit filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CustomKit records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CustomKit records
        total = await CustomKit.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CustomKitScalarFieldKeysT'],
        *,
        where: Optional['types.CustomKitWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CustomKitAvgAggregateInput'] = None,
        sum: Optional['types.CustomKitSumAggregateInput'] = None,
        min: Optional['types.CustomKitMinAggregateInput'] = None,
        max: Optional['types.CustomKitMaxAggregateInput'] = None,
        having: Optional['types.CustomKitScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CustomKitCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CustomKitScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.CustomKitScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.CustomKitGroupByOutput']:
        """Group CustomKit records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CustomKit fields to group records by
        where
            CustomKit filter to select records
        take
            Limit the maximum number of CustomKit records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CustomKitGroupByOutput]
            A list of dictionaries representing the CustomKit record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CustomKit records by crestAssetId values
        # and count how many records are in each group
        results = await CustomKit.prisma().group_by(
            ['crestAssetId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClubAggregateMatchStatsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ClubAggregateMatchStats]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ClubAggregateMatchStats.prisma().query_raw(
            'SELECT * FROM ClubAggregateMatchStats WHERE id = $1',
            'cbjjeedcj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ClubAggregateMatchStats.prisma().query_first(
            'SELECT * FROM ClubAggregateMatchStats WHERE matchId = $1',
            'dedgbbhja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ClubAggregateMatchStatsCreateInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None
    ) -> _PrismaModelT:
        """Create a new ClubAggregateMatchStats record.

        Parameters
        ----------
        data
            ClubAggregateMatchStats record data
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The created ClubAggregateMatchStats record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ClubAggregateMatchStats record from just the required fields
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().create(
            data={
                # data to create a ClubAggregateMatchStats record
                'matchId': 'cabiahchj',
                'clubLevel': 261422524,
                'position': 52920645,
                'posSorted': 1637040282,
                'isGuest': 2055052747,
                'playerDnf': 59914664,
                'playerLevel': 1388571841,
                'eaTeamId': 232049766,
                'teamSide': 918965159,
                'opponentEaClubId': 665143380,
                'opponentEaTeamId': 39949309,
                'opponentScore': 1901152498,
                'score': 1627519811,
                'ratingDefense': 1094227392.35602,
                'ratingOffense': 1638335038.189156,
                'ratingTeamplay': 1072778732.187932,
                'toi': 1577911370,
                'toiSeconds': 504729531,
                'assists': 110845144,
                'blockedShots': 1300269105,
                'deflections': 1881086742,
                'faceoffsLost': 1082354839,
                'faceoffPct': 1456828036.212470,
                'faceoffsWon': 1298780834,
                'giveaways': 1065892659,
                'goals': 1266478832,
                'hits': 1923026025,
                'interceptions': 95844078,
                'passAttempts': 1895913359,
                'passes': 232393244,
                'passPct': 1116931621.124302,
                'penaltiesDrawn': 21355947,
                'penaltyMinutes': 831237128,
                'skaterPkClearZone': 1024647073,
                'plusMinus': 414348742,
                'possession': 1090693511,
                'powerPlayGoals': 1664319668,
                'saucerPasses': 761058525,
                'shortHandedGoals': 1498425426,
                'shotAttempts': 1960204067,
                'shotOnNetPct': 1440871456.151564,
                'shots': 916748190,
                'takeaways': 44909183,
                'breakawaySavePct': 457323084.203494,
                'breakawaySaves': 1079799722,
                'breakawayShots': 417171355,
                'desperationSaves': 1384523576,
                'goalsAgainst': 274854673,
                'goalsAgainstAverage': 568974454.72161,
                'penaltyShotSavePct': 1511161572.8189,
                'penaltyShotSaves': 2047822338,
                'goaliePkClearZone': 1620791059,
                'pokeChecks': 1877648720,
                'savePct': 1361507145.52297,
                'totalSaves': 1365363055,
                'totalShotsFaced': 1826408060,
                'shutoutPeriods': 509770501,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClubAggregateMatchStatsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ClubAggregateMatchStats records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ClubAggregateMatchStats record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ClubAggregateMatchStats.prisma().create_many(
            data=[
                {
                    # data to create a ClubAggregateMatchStats record
                    'matchId': 'bfeiccieec',
                    'clubLevel': 728468875,
                    'position': 107859560,
                    'posSorted': 1041547905,
                    'isGuest': 1927302950,
                    'playerDnf': 520320871,
                    'playerLevel': 1132816660,
                    'eaTeamId': 1061815741,
                    'teamSide': 1836201906,
                    'opponentEaClubId': 742793987,
                    'opponentEaTeamId': 265945728,
                    'opponentScore': 462831801,
                    'score': 247995646,
                    'ratingDefense': 780004447.43809,
                    'ratingOffense': 936456053.177871,
                    'ratingTeamplay': 1094643579.175987,
                    'toi': 882003441,
                    'toiSeconds': 1869663702,
                    'assists': 1531119703,
                    'blockedShots': 1381973828,
                    'deflections': 1248647213,
                    'faceoffsLost': 2047078754,
                    'faceoffPct': 990237427.111903,
                    'faceoffsWon': 770427433,
                    'giveaways': 699646382,
                    'goals': 18918223,
                    'hits': 2100638428,
                    'interceptions': 927850469,
                    'passAttempts': 377375418,
                    'passes': 342273387,
                    'passPct': 1146134728.124161,
                    'penaltiesDrawn': 674650246,
                    'penaltyMinutes': 734049607,
                    'skaterPkClearZone': 338887028,
                    'plusMinus': 937502365,
                    'possession': 521107218,
                    'powerPlayGoals': 432627427,
                    'saucerPasses': 1547223264,
                    'shortHandedGoals': 472813465,
                    'shotAttempts': 417985118,
                    'shotOnNetPct': 908658239.166258,
                    'shots': 1783598165,
                    'takeaways': 526308970,
                    'breakawaySavePct': 11650907.110426,
                    'breakawaySaves': 743020753,
                    'breakawayShots': 176942902,
                    'desperationSaves': 1513848375,
                    'goalsAgainst': 559132580,
                    'goalsAgainstAverage': 754839821.115132,
                    'penaltyShotSavePct': 1866450643.65314,
                    'penaltyShotSaves': 170234121,
                    'goaliePkClearZone': 975548174,
                    'pokeChecks': 808844591,
                    'savePct': 997936956.177925,
                    'totalSaves': 51490330,
                    'totalShotsFaced': 1940864331,
                    'shutoutPeriods': 424420136,
                },
                {
                    # data to create a ClubAggregateMatchStats record
                    'matchId': 'bdgaajbcab',
                    'clubLevel': 277647846,
                    'position': 506618663,
                    'posSorted': 1288980948,
                    'isGuest': 1390032765,
                    'playerDnf': 1803544178,
                    'playerLevel': 1809320643,
                    'eaTeamId': 336998208,
                    'teamSide': 458739321,
                    'opponentEaClubId': 1340209086,
                    'opponentEaTeamId': 933662751,
                    'opponentScore': 1221525356,
                    'score': 192796981,
                    'ratingDefense': 818008522.155491,
                    'ratingOffense': 1096984152.170707,
                    'ratingTeamplay': 1897087126.21629,
                    'toi': 1418186756,
                    'toiSeconds': 1179449837,
                    'assists': 1564135458,
                    'blockedShots': 968960691,
                    'deflections': 1806952560,
                    'faceoffsLost': 1661749225,
                    'faceoffPct': 827968622.178846,
                    'faceoffsWon': 1346837404,
                    'giveaways': 1331198373,
                    'goals': 945439098,
                    'hits': 482164011,
                    'interceptions': 527979912,
                    'passAttempts': 1065093921,
                    'passes': 1337654086,
                    'passPct': 156270855.28529,
                    'penaltiesDrawn': 132986973,
                    'penaltyMinutes': 1545307602,
                    'skaterPkClearZone': 1827284643,
                    'plusMinus': 2089438624,
                    'possession': 1414135129,
                    'powerPlayGoals': 2055744798,
                    'saucerPasses': 753830399,
                    'shortHandedGoals': 1238803404,
                    'shotAttempts': 1377048085,
                    'shotOnNetPct': 2055601450.199096,
                    'shots': 934293688,
                    'takeaways': 1261239953,
                    'breakawaySavePct': 1826537974.87593,
                    'breakawaySaves': 630431844,
                    'breakawayShots': 1813115597,
                    'desperationSaves': 1395459970,
                    'goalsAgainst': 1929510547,
                    'goalsAgainstAverage': 1276927696.83623,
                    'penaltyShotSavePct': 1009261006.40710,
                    'penaltyShotSaves': 271620092,
                    'goaliePkClearZone': 1005039237,
                    'pokeChecks': 1487930586,
                    'savePct': 2131275019.155905,
                    'totalSaves': 2105126401,
                    'totalShotsFaced': 1436128422,
                    'shutoutPeriods': 1544752871,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClubAggregateMatchStatsWhereUniqueInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ClubAggregateMatchStats record.

        Parameters
        ----------
        where
            ClubAggregateMatchStats filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The deleted ClubAggregateMatchStats record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().delete(
            where={
                'id': 'ibagheidg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClubAggregateMatchStatsWhereUniqueInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ClubAggregateMatchStats record.

        Parameters
        ----------
        where
            ClubAggregateMatchStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The found ClubAggregateMatchStats record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_unique(
            where={
                'id': 'bibfefchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClubAggregateMatchStatsWhereUniqueInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ClubAggregateMatchStats record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ClubAggregateMatchStats filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The found ClubAggregateMatchStats record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_unique_or_raise(
            where={
                'id': 'baeeigbje',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None,
        order: Optional[Union[types.ClubAggregateMatchStatsOrderByInput, List[types.ClubAggregateMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubAggregateMatchStatsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ClubAggregateMatchStats records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ClubAggregateMatchStats records returned
        skip
            Ignore the first N results
        where
            ClubAggregateMatchStats filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model
        order
            Order the returned ClubAggregateMatchStats records by any field
        distinct
            Filter ClubAggregateMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ClubAggregateMatchStats]
            The list of all ClubAggregateMatchStats records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ClubAggregateMatchStats records
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_many(take=10)

        # find the first 5 ClubAggregateMatchStats records ordered by the clubLevel field
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_many(
            take=5,
            order={
                'clubLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None,
        order: Optional[Union[types.ClubAggregateMatchStatsOrderByInput, List[types.ClubAggregateMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubAggregateMatchStatsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ClubAggregateMatchStats record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubAggregateMatchStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model
        order
            Order the returned ClubAggregateMatchStats records by any field
        distinct
            Filter ClubAggregateMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The first ClubAggregateMatchStats record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubAggregateMatchStats record ordered by the position field
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_first(
            skip=1,
            order={
                'position': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None,
        order: Optional[Union[types.ClubAggregateMatchStatsOrderByInput, List[types.ClubAggregateMatchStatsOrderByInput]]] = None,
        distinct: Optional[List[types.ClubAggregateMatchStatsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ClubAggregateMatchStats record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClubAggregateMatchStats filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model
        order
            Order the returned ClubAggregateMatchStats records by any field
        distinct
            Filter ClubAggregateMatchStats records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The first ClubAggregateMatchStats record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClubAggregateMatchStats record ordered by the posSorted field
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().find_first_or_raise(
            skip=1,
            order={
                'posSorted': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClubAggregateMatchStatsUpdateInput,
        where: types.ClubAggregateMatchStatsWhereUniqueInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ClubAggregateMatchStats record.

        Parameters
        ----------
        data
            ClubAggregateMatchStats record data specifying what to update
        where
            ClubAggregateMatchStats filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The updated ClubAggregateMatchStats record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().update(
            where={
                'id': 'fibhgbdb',
            },
            data={
                # data to update the ClubAggregateMatchStats record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClubAggregateMatchStatsWhereUniqueInput,
        data: types.ClubAggregateMatchStatsUpsertInput,
        include: Optional[types.ClubAggregateMatchStatsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ClubAggregateMatchStats filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ClubAggregateMatchStats model

        Returns
        -------
        prisma.models.ClubAggregateMatchStats
            The created or updated ClubAggregateMatchStats record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clubaggregatematchstats = await ClubAggregateMatchStats.prisma().upsert(
            where={
                'id': 'bbifhfaabg',
            },
            data={
                'create': {
                    'id': 'bbifhfaabg',
                    'matchId': 'bdgaajbcab',
                    'clubLevel': 277647846,
                    'position': 506618663,
                    'posSorted': 1288980948,
                    'isGuest': 1390032765,
                    'playerDnf': 1803544178,
                    'playerLevel': 1809320643,
                    'eaTeamId': 336998208,
                    'teamSide': 458739321,
                    'opponentEaClubId': 1340209086,
                    'opponentEaTeamId': 933662751,
                    'opponentScore': 1221525356,
                    'score': 192796981,
                    'ratingDefense': 818008522.155491,
                    'ratingOffense': 1096984152.170707,
                    'ratingTeamplay': 1897087126.21629,
                    'toi': 1418186756,
                    'toiSeconds': 1179449837,
                    'assists': 1564135458,
                    'blockedShots': 968960691,
                    'deflections': 1806952560,
                    'faceoffsLost': 1661749225,
                    'faceoffPct': 827968622.178846,
                    'faceoffsWon': 1346837404,
                    'giveaways': 1331198373,
                    'goals': 945439098,
                    'hits': 482164011,
                    'interceptions': 527979912,
                    'passAttempts': 1065093921,
                    'passes': 1337654086,
                    'passPct': 156270855.28529,
                    'penaltiesDrawn': 132986973,
                    'penaltyMinutes': 1545307602,
                    'skaterPkClearZone': 1827284643,
                    'plusMinus': 2089438624,
                    'possession': 1414135129,
                    'powerPlayGoals': 2055744798,
                    'saucerPasses': 753830399,
                    'shortHandedGoals': 1238803404,
                    'shotAttempts': 1377048085,
                    'shotOnNetPct': 2055601450.199096,
                    'shots': 934293688,
                    'takeaways': 1261239953,
                    'breakawaySavePct': 1826537974.87593,
                    'breakawaySaves': 630431844,
                    'breakawayShots': 1813115597,
                    'desperationSaves': 1395459970,
                    'goalsAgainst': 1929510547,
                    'goalsAgainstAverage': 1276927696.83623,
                    'penaltyShotSavePct': 1009261006.40710,
                    'penaltyShotSaves': 271620092,
                    'goaliePkClearZone': 1005039237,
                    'pokeChecks': 1487930586,
                    'savePct': 2131275019.155905,
                    'totalSaves': 2105126401,
                    'totalShotsFaced': 1436128422,
                    'shutoutPeriods': 1544752871,
                },
                'update': {
                    'matchId': 'bdgaajbcab',
                    'clubLevel': 277647846,
                    'position': 506618663,
                    'posSorted': 1288980948,
                    'isGuest': 1390032765,
                    'playerDnf': 1803544178,
                    'playerLevel': 1809320643,
                    'eaTeamId': 336998208,
                    'teamSide': 458739321,
                    'opponentEaClubId': 1340209086,
                    'opponentEaTeamId': 933662751,
                    'opponentScore': 1221525356,
                    'score': 192796981,
                    'ratingDefense': 818008522.155491,
                    'ratingOffense': 1096984152.170707,
                    'ratingTeamplay': 1897087126.21629,
                    'toi': 1418186756,
                    'toiSeconds': 1179449837,
                    'assists': 1564135458,
                    'blockedShots': 968960691,
                    'deflections': 1806952560,
                    'faceoffsLost': 1661749225,
                    'faceoffPct': 827968622.178846,
                    'faceoffsWon': 1346837404,
                    'giveaways': 1331198373,
                    'goals': 945439098,
                    'hits': 482164011,
                    'interceptions': 527979912,
                    'passAttempts': 1065093921,
                    'passes': 1337654086,
                    'passPct': 156270855.28529,
                    'penaltiesDrawn': 132986973,
                    'penaltyMinutes': 1545307602,
                    'skaterPkClearZone': 1827284643,
                    'plusMinus': 2089438624,
                    'possession': 1414135129,
                    'powerPlayGoals': 2055744798,
                    'saucerPasses': 753830399,
                    'shortHandedGoals': 1238803404,
                    'shotAttempts': 1377048085,
                    'shotOnNetPct': 2055601450.199096,
                    'shots': 934293688,
                    'takeaways': 1261239953,
                    'breakawaySavePct': 1826537974.87593,
                    'breakawaySaves': 630431844,
                    'breakawayShots': 1813115597,
                    'desperationSaves': 1395459970,
                    'goalsAgainst': 1929510547,
                    'goalsAgainstAverage': 1276927696.83623,
                    'penaltyShotSavePct': 1009261006.40710,
                    'penaltyShotSaves': 271620092,
                    'goaliePkClearZone': 1005039237,
                    'pokeChecks': 1487930586,
                    'savePct': 2131275019.155905,
                    'totalSaves': 2105126401,
                    'totalShotsFaced': 1436128422,
                    'shutoutPeriods': 1544752871,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClubAggregateMatchStatsUpdateManyMutationInput,
        where: types.ClubAggregateMatchStatsWhereInput,
    ) -> int:
        """Update multiple ClubAggregateMatchStats records

        Parameters
        ----------
        data
            ClubAggregateMatchStats data to update the selected ClubAggregateMatchStats records to
        where
            Filter to select the ClubAggregateMatchStats records to update

        Returns
        -------
        int
            The total number of ClubAggregateMatchStats records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ClubAggregateMatchStats records
        total = await ClubAggregateMatchStats.prisma().update_many(
            data={
                'isGuest': 2117934137
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ClubAggregateMatchStats records present in the database

        Parameters
        ----------
        select
            Select the ClubAggregateMatchStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubAggregateMatchStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubAggregateMatchStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubAggregateMatchStats.prisma().count()

        # results: prisma.types.ClubAggregateMatchStatsCountAggregateOutput
        results = await ClubAggregateMatchStats.prisma().count(
            select={
                '_all': True,
                'playerDnf': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClubAggregateMatchStatsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
    ) -> types.ClubAggregateMatchStatsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClubAggregateMatchStatsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None,
        cursor: Optional[types.ClubAggregateMatchStatsWhereUniqueInput] = None,
    ) -> Union[int, types.ClubAggregateMatchStatsCountAggregateOutput]:
        """Count the number of ClubAggregateMatchStats records present in the database

        Parameters
        ----------
        select
            Select the ClubAggregateMatchStats fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClubAggregateMatchStats filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClubAggregateMatchStatsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClubAggregateMatchStats.prisma().count()

        # results: prisma.types.ClubAggregateMatchStatsCountAggregateOutput
        results = await ClubAggregateMatchStats.prisma().count(
            select={
                '_all': True,
                'playerLevel': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClubAggregateMatchStatsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClubAggregateMatchStatsWhereInput] = None
    ) -> int:
        """Delete multiple ClubAggregateMatchStats records.

        Parameters
        ----------
        where
            Optional ClubAggregateMatchStats filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ClubAggregateMatchStats records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ClubAggregateMatchStats records
        total = await ClubAggregateMatchStats.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClubAggregateMatchStatsScalarFieldKeysT'],
        *,
        where: Optional['types.ClubAggregateMatchStatsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClubAggregateMatchStatsAvgAggregateInput'] = None,
        sum: Optional['types.ClubAggregateMatchStatsSumAggregateInput'] = None,
        min: Optional['types.ClubAggregateMatchStatsMinAggregateInput'] = None,
        max: Optional['types.ClubAggregateMatchStatsMaxAggregateInput'] = None,
        having: Optional['types.ClubAggregateMatchStatsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClubAggregateMatchStatsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClubAggregateMatchStatsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ClubAggregateMatchStatsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ClubAggregateMatchStatsGroupByOutput']:
        """Group ClubAggregateMatchStats records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ClubAggregateMatchStats fields to group records by
        where
            ClubAggregateMatchStats filter to select records
        take
            Limit the maximum number of ClubAggregateMatchStats records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClubAggregateMatchStatsGroupByOutput]
            A list of dictionaries representing the ClubAggregateMatchStats record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ClubAggregateMatchStats records by eaTeamId values
        # and count how many records are in each group
        results = await ClubAggregateMatchStats.prisma().group_by(
            ['eaTeamId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MatchAnalyticsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MatchAnalytics]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MatchAnalytics.prisma().query_raw(
            'SELECT * FROM MatchAnalytics WHERE id = $1',
            'hddcfecha',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MatchAnalytics
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MatchAnalytics.prisma().query_first(
            'SELECT * FROM MatchAnalytics WHERE matchId = $1',
            'bibbehhehb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MatchAnalyticsCreateInput,
        include: Optional[types.MatchAnalyticsInclude] = None
    ) -> _PrismaModelT:
        """Create a new MatchAnalytics record.

        Parameters
        ----------
        data
            MatchAnalytics record data
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The created MatchAnalytics record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MatchAnalytics record from just the required fields
        matchanalytics = await MatchAnalytics.prisma().create(
            data={
                # data to create a MatchAnalytics record
                'matchId': 'cibfeagfc',
                'possessionDifferential': 818561781,
                'possessionPercentageHome': 1694718090.20361,
                'possessionPercentageAway': 1624402712.112047,
                'homeShootingEfficiency': 331772758.183130,
                'awayShootingEfficiency': 2047811780.80562,
                'homePassingEfficiency': 1104047842.25967,
                'awayPassingEfficiency': 1866433840.180777,
                'homePossessionEfficiency': 1399363374.210007,
                'awayPossessionEfficiency': 2077213788.108126,
                'homePowerPlayPct': 309000250.63816,
                'awayPowerPlayPct': 1136839240.186661,
                'homePenaltyKillPct': 1577082374.163486,
                'awayPenaltyKillPct': 643711732.126255,
                'homeScore': 187978898.83838,
                'awayScore': 261528160.128196,
                'shotDifferential': 1111435230,
                'hitDifferential': 649973183,
                'takeawayDifferential': 1950022796,
                'scoringChancesDifferential': 1448632277,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MatchAnalyticsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MatchAnalytics records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MatchAnalytics record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MatchAnalytics.prisma().create_many(
            data=[
                {
                    # data to create a MatchAnalytics record
                    'matchId': 'bgihcicggg',
                    'possessionDifferential': 1988855515,
                    'possessionPercentageHome': 1692489080.78513,
                    'possessionPercentageAway': 1201820854.81695,
                    'homeShootingEfficiency': 1670533412.160836,
                    'awayShootingEfficiency': 1349977666.53070,
                    'homePassingEfficiency': 1748327312.3342,
                    'awayPassingEfficiency': 1005798542.96125,
                    'homePossessionEfficiency': 1069326524.69952,
                    'awayPossessionEfficiency': 534977434.95996,
                    'homePowerPlayPct': 839978152.196383,
                    'awayPowerPlayPct': 1892112230.108039,
                    'homePenaltyKillPct': 448678740.196200,
                    'awayPenaltyKillPct': 409043954.38411,
                    'homeScore': 1616824512.184589,
                    'awayScore': 1761602878.179864,
                    'shotDifferential': 1992798444,
                    'hitDifferential': 762735797,
                    'takeawayDifferential': 2039062346,
                    'scoringChancesDifferential': 727551675,
                },
                {
                    # data to create a MatchAnalytics record
                    'matchId': 'behfggjjhg',
                    'possessionDifferential': 1835933489,
                    'possessionPercentageHome': 910845462.140590,
                    'possessionPercentageAway': 531968388.8942,
                    'homeShootingEfficiency': 847170978.134120,
                    'awayShootingEfficiency': 907403760.164053,
                    'homePassingEfficiency': 111157742.121799,
                    'awayPassingEfficiency': 881798428.609,
                    'homePossessionEfficiency': 1198550778.208113,
                    'awayPossessionEfficiency': 1911553800.179648,
                    'homePowerPlayPct': 1640399046.207862,
                    'awayPowerPlayPct': 1628046260.187253,
                    'homePenaltyKillPct': 1729749842.182379,
                    'awayPenaltyKillPct': 773695264.23986,
                    'homeScore': 382657182.59289,
                    'awayScore': 1191581004.155794,
                    'shotDifferential': 809667242,
                    'hitDifferential': 1007748763,
                    'takeawayDifferential': 975518264,
                    'scoringChancesDifferential': 1491536401,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MatchAnalyticsWhereUniqueInput,
        include: Optional[types.MatchAnalyticsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MatchAnalytics record.

        Parameters
        ----------
        where
            MatchAnalytics filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The deleted MatchAnalytics record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        matchanalytics = await MatchAnalytics.prisma().delete(
            where={
                'id': 'bfadaefeje',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MatchAnalyticsWhereUniqueInput,
        include: Optional[types.MatchAnalyticsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MatchAnalytics record.

        Parameters
        ----------
        where
            MatchAnalytics filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The found MatchAnalytics record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        matchanalytics = await MatchAnalytics.prisma().find_unique(
            where={
                'id': 'bceheeaff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MatchAnalyticsWhereUniqueInput,
        include: Optional[types.MatchAnalyticsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MatchAnalytics record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MatchAnalytics filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The found MatchAnalytics record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        matchanalytics = await MatchAnalytics.prisma().find_unique_or_raise(
            where={
                'id': 'eadgifiga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
        include: Optional[types.MatchAnalyticsInclude] = None,
        order: Optional[Union[types.MatchAnalyticsOrderByInput, List[types.MatchAnalyticsOrderByInput]]] = None,
        distinct: Optional[List[types.MatchAnalyticsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MatchAnalytics records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MatchAnalytics records returned
        skip
            Ignore the first N results
        where
            MatchAnalytics filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model
        order
            Order the returned MatchAnalytics records by any field
        distinct
            Filter MatchAnalytics records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MatchAnalytics]
            The list of all MatchAnalytics records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MatchAnalytics records
        matchanalytics = await MatchAnalytics.prisma().find_many(take=10)

        # find the first 5 MatchAnalytics records ordered by the possessionDifferential field
        matchanalytics = await MatchAnalytics.prisma().find_many(
            take=5,
            order={
                'possessionDifferential': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
        include: Optional[types.MatchAnalyticsInclude] = None,
        order: Optional[Union[types.MatchAnalyticsOrderByInput, List[types.MatchAnalyticsOrderByInput]]] = None,
        distinct: Optional[List[types.MatchAnalyticsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MatchAnalytics record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MatchAnalytics filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model
        order
            Order the returned MatchAnalytics records by any field
        distinct
            Filter MatchAnalytics records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MatchAnalytics
            The first MatchAnalytics record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MatchAnalytics record ordered by the possessionPercentageHome field
        matchanalytics = await MatchAnalytics.prisma().find_first(
            skip=1,
            order={
                'possessionPercentageHome': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
        include: Optional[types.MatchAnalyticsInclude] = None,
        order: Optional[Union[types.MatchAnalyticsOrderByInput, List[types.MatchAnalyticsOrderByInput]]] = None,
        distinct: Optional[List[types.MatchAnalyticsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MatchAnalytics record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MatchAnalytics filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model
        order
            Order the returned MatchAnalytics records by any field
        distinct
            Filter MatchAnalytics records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MatchAnalytics
            The first MatchAnalytics record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MatchAnalytics record ordered by the possessionPercentageAway field
        matchanalytics = await MatchAnalytics.prisma().find_first_or_raise(
            skip=1,
            order={
                'possessionPercentageAway': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MatchAnalyticsUpdateInput,
        where: types.MatchAnalyticsWhereUniqueInput,
        include: Optional[types.MatchAnalyticsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MatchAnalytics record.

        Parameters
        ----------
        data
            MatchAnalytics record data specifying what to update
        where
            MatchAnalytics filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The updated MatchAnalytics record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        matchanalytics = await MatchAnalytics.prisma().update(
            where={
                'id': 'bhbdefcgcb',
            },
            data={
                # data to update the MatchAnalytics record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MatchAnalyticsWhereUniqueInput,
        data: types.MatchAnalyticsUpsertInput,
        include: Optional[types.MatchAnalyticsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MatchAnalytics filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MatchAnalytics model

        Returns
        -------
        prisma.models.MatchAnalytics
            The created or updated MatchAnalytics record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        matchanalytics = await MatchAnalytics.prisma().upsert(
            where={
                'id': 'gfidfjffe',
            },
            data={
                'create': {
                    'id': 'gfidfjffe',
                    'matchId': 'behfggjjhg',
                    'possessionDifferential': 1835933489,
                    'possessionPercentageHome': 910845462.140590,
                    'possessionPercentageAway': 531968388.8942,
                    'homeShootingEfficiency': 847170978.134120,
                    'awayShootingEfficiency': 907403760.164053,
                    'homePassingEfficiency': 111157742.121799,
                    'awayPassingEfficiency': 881798428.609,
                    'homePossessionEfficiency': 1198550778.208113,
                    'awayPossessionEfficiency': 1911553800.179648,
                    'homePowerPlayPct': 1640399046.207862,
                    'awayPowerPlayPct': 1628046260.187253,
                    'homePenaltyKillPct': 1729749842.182379,
                    'awayPenaltyKillPct': 773695264.23986,
                    'homeScore': 382657182.59289,
                    'awayScore': 1191581004.155794,
                    'shotDifferential': 809667242,
                    'hitDifferential': 1007748763,
                    'takeawayDifferential': 975518264,
                    'scoringChancesDifferential': 1491536401,
                },
                'update': {
                    'matchId': 'behfggjjhg',
                    'possessionDifferential': 1835933489,
                    'possessionPercentageHome': 910845462.140590,
                    'possessionPercentageAway': 531968388.8942,
                    'homeShootingEfficiency': 847170978.134120,
                    'awayShootingEfficiency': 907403760.164053,
                    'homePassingEfficiency': 111157742.121799,
                    'awayPassingEfficiency': 881798428.609,
                    'homePossessionEfficiency': 1198550778.208113,
                    'awayPossessionEfficiency': 1911553800.179648,
                    'homePowerPlayPct': 1640399046.207862,
                    'awayPowerPlayPct': 1628046260.187253,
                    'homePenaltyKillPct': 1729749842.182379,
                    'awayPenaltyKillPct': 773695264.23986,
                    'homeScore': 382657182.59289,
                    'awayScore': 1191581004.155794,
                    'shotDifferential': 809667242,
                    'hitDifferential': 1007748763,
                    'takeawayDifferential': 975518264,
                    'scoringChancesDifferential': 1491536401,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MatchAnalyticsUpdateManyMutationInput,
        where: types.MatchAnalyticsWhereInput,
    ) -> int:
        """Update multiple MatchAnalytics records

        Parameters
        ----------
        data
            MatchAnalytics data to update the selected MatchAnalytics records to
        where
            Filter to select the MatchAnalytics records to update

        Returns
        -------
        int
            The total number of MatchAnalytics records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MatchAnalytics records
        total = await MatchAnalytics.prisma().update_many(
            data={
                'homeShootingEfficiency': 1759489555.114039
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MatchAnalytics records present in the database

        Parameters
        ----------
        select
            Select the MatchAnalytics fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MatchAnalytics filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchAnalyticsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MatchAnalytics.prisma().count()

        # results: prisma.types.MatchAnalyticsCountAggregateOutput
        results = await MatchAnalytics.prisma().count(
            select={
                '_all': True,
                'awayShootingEfficiency': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MatchAnalyticsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
    ) -> types.MatchAnalyticsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MatchAnalyticsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchAnalyticsWhereInput] = None,
        cursor: Optional[types.MatchAnalyticsWhereUniqueInput] = None,
    ) -> Union[int, types.MatchAnalyticsCountAggregateOutput]:
        """Count the number of MatchAnalytics records present in the database

        Parameters
        ----------
        select
            Select the MatchAnalytics fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MatchAnalytics filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchAnalyticsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MatchAnalytics.prisma().count()

        # results: prisma.types.MatchAnalyticsCountAggregateOutput
        results = await MatchAnalytics.prisma().count(
            select={
                '_all': True,
                'homePassingEfficiency': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MatchAnalyticsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MatchAnalyticsWhereInput] = None
    ) -> int:
        """Delete multiple MatchAnalytics records.

        Parameters
        ----------
        where
            Optional MatchAnalytics filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MatchAnalytics records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MatchAnalytics records
        total = await MatchAnalytics.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MatchAnalyticsScalarFieldKeysT'],
        *,
        where: Optional['types.MatchAnalyticsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MatchAnalyticsAvgAggregateInput'] = None,
        sum: Optional['types.MatchAnalyticsSumAggregateInput'] = None,
        min: Optional['types.MatchAnalyticsMinAggregateInput'] = None,
        max: Optional['types.MatchAnalyticsMaxAggregateInput'] = None,
        having: Optional['types.MatchAnalyticsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MatchAnalyticsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MatchAnalyticsScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.MatchAnalyticsScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.MatchAnalyticsGroupByOutput']:
        """Group MatchAnalytics records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MatchAnalytics fields to group records by
        where
            MatchAnalytics filter to select records
        take
            Limit the maximum number of MatchAnalytics records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MatchAnalyticsGroupByOutput]
            A list of dictionaries representing the MatchAnalytics record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MatchAnalytics records by awayPassingEfficiency values
        # and count how many records are in each group
        results = await MatchAnalytics.prisma().group_by(
            ['awayPassingEfficiency'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerMatchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerMatch]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerMatch.prisma().query_raw(
            'SELECT * FROM PlayerMatch WHERE id = $1',
            'bjfbjbiggf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerMatch
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerMatch.prisma().query_first(
            'SELECT * FROM PlayerMatch WHERE matchId = $1',
            'chdbaagcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerMatchCreateInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerMatch record.

        Parameters
        ----------
        data
            PlayerMatch record data
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The created PlayerMatch record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerMatch record from just the required fields
        playermatch = await PlayerMatch.prisma().create(
            data={
                # data to create a PlayerMatch record
                'matchId': 'fbbijihb',
                'playerTeamSeasonId': 'bfjbgjjidg',
                'playerSeasonId': 'bfdihaifd',
                'playerLevel': 1533735514,
                'position': 'bdaiebdagh',
                'posSorted': 964141416,
                'playerName': 'gjhbefhcj',
                'clientPlatform': 'bdfgbjccje',
                'playerLevelDisplay': 1927915111,
                'isGuest': True,
                'playerDnf': False,
                'pNhlOnlineGameType': 'babifceddi',
                'eaTeamId': 'bgfgjbjah',
                'teamSide': 1508586880,
                'opponentClubId': 'bebgicaggf',
                'opponentEaTeamId': 'cedfddicc',
                'opponentScore': 354089823,
                'score': 1066281388,
                'ratingDefense': 1195529845.55500,
                'ratingOffense': 1444802171.200554,
                'ratingTeamplay': 1198449905.200272,
                'toi': 1486026583,
                'toiSeconds': 1647968836,
                'assists': 66838317,
                'blockedShots': 2047601762,
                'deflections': 1323676147,
                'faceoffsLost': 1761017520,
                'faceoffPct': 518275369.2938,
                'faceoffsWon': 480213583,
                'giveaways': 1866814940,
                'goals': 1154926309,
                'gameWinningGoals': 975873466,
                'hits': 713256043,
                'interceptions': 717222856,
                'passAttempts': 78769249,
                'passes': 701326214,
                'passPct': 1617585223.23098,
                'penaltiesDrawn': 583003549,
                'penaltyMinutes': 1787572754,
                'skaterPkClearZone': 1625226723,
                'plusMinus': 819950560,
                'possessionSeconds': 1672660633,
                'powerPlayGoals': 1593269598,
                'saucerPasses': 1652135231,
                'shortHandedGoals': 1727524364,
                'shotAttempts': 190853973,
                'shotsOnNetPct': 1884811626.112382,
                'shootingPct': 1748754168.18859,
                'shotsOnGoal': 561756726,
                'takeaways': 808381751,
                'points': 1070330532,
                'faceoffsTotal': 480016397,
                'shotsMissed': 37831618,
                'passesMissed': 41625043,
                'passingPct': 1747424528.111814,
                'majorPenalties': 1340332558,
                'minorPenalties': 625495087,
                'totalPenalties': 1113125436,
                'pointsPer60': 1880464325.130911,
                'possessionPerMinute': 689405003.140725,
                'shotEfficiency': 1287204673.61270,
                'tkawayGvawayRatio': 1532989991.200299,
                'penaltyDifferential': 1453883005,
                'defActionsPerMinute': 1307976050.269,
                'offImpact': 1813144128.153115,
                'defImpact': 1661002430.15798,
                'detailedPosition': 'bihggeiffg',
                'positionAbbreviation': 'gfjcjcgj',
                'gameImpactScore': 1315204298.174719,
                'puckManagementRating': 1347565912.192173,
                'possessionEfficiency': 902073238.139639,
                'netDefContribution': 509448964.70012,
                'timeAdjustedRating': 590727970.53844,
                'shotGenerationRate': 1889721200.102050,
                'offZonePresence': 998864750.15096,
                'twoWayRating': 1622294172.6084,
                'breakawaySavePct': 223976570.210036,
                'breakawaySaves': 787654792,
                'breakawayShots': 1306223137,
                'desperationSaves': 1154811462,
                'goalsAgainst': 1455501319,
                'goalsAgainstAverage': 961398068.138274,
                'penaltyShotSavePct': 1347109074.30557,
                'penaltyShotSaves': 815530144,
                'penaltyShotsFaced': 1448948825,
                'goaliePkClearZone': 1098422302,
                'pokeChecks': 1676024063,
                'savePct': 953190092.120191,
                'totalSaves': 2006063146,
                'totalShotsFaced': 1192052251,
                'shutoutPeriods': 1608860600,
                'goalsSaved': 1200625041,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerMatchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerMatch records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerMatch record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerMatch.prisma().create_many(
            data=[
                {
                    # data to create a PlayerMatch record
                    'matchId': 'bfhicaifac',
                    'playerTeamSeasonId': 'bgffhbbjjb',
                    'playerSeasonId': 'djehbgaae',
                    'playerLevel': 1628404173,
                    'position': 'bchjdgbggg',
                    'posSorted': 1614044563,
                    'playerName': 'ejejibfie',
                    'clientPlatform': 'bhcccbdidd',
                    'playerLevelDisplay': 1367950542,
                    'isGuest': False,
                    'playerDnf': True,
                    'pNhlOnlineGameType': 'ihffaajdd',
                    'eaTeamId': 'cafehebjhi',
                    'teamSide': 1984424971,
                    'opponentClubId': 'fhbciabae',
                    'opponentEaTeamId': 'bdehefecaj',
                    'opponentScore': 1519722406,
                    'score': 562511335,
                    'ratingDefense': 52161940.70041,
                    'ratingOffense': 1726189618.156865,
                    'ratingTeamplay': 261377792.181559,
                    'toi': 1832287614,
                    'toiSeconds': 669254367,
                    'assists': 1282366252,
                    'blockedShots': 691628533,
                    'deflections': 876147594,
                    'faceoffsLost': 2100293115,
                    'faceoffPct': 856489496.135080,
                    'faceoffsWon': 272285270,
                    'giveaways': 1535471319,
                    'goals': 1893721028,
                    'gameWinningGoals': 877781677,
                    'hits': 2025613794,
                    'interceptions': 390603123,
                    'passAttempts': 1977186352,
                    'passes': 358022313,
                    'passPct': 1790657070.156823,
                    'penaltiesDrawn': 2106976092,
                    'penaltyMinutes': 1920580197,
                    'skaterPkClearZone': 599610170,
                    'plusMinus': 2144619499,
                    'possessionSeconds': 2135432520,
                    'powerPlayGoals': 407934945,
                    'saucerPasses': 27093254,
                    'shortHandedGoals': 1722399687,
                    'shotAttempts': 811976180,
                    'shotsOnNetPct': 744345885.32027,
                    'shootingPct': 1148996963.10192,
                    'shotsOnGoal': 806052377,
                    'takeaways': 621974238,
                    'points': 1734106303,
                    'faceoffsTotal': 1632624524,
                    'shotsMissed': 929498837,
                    'passesMissed': 1487994602,
                    'passingPct': 1141114331.137372,
                    'majorPenalties': 1335769937,
                    'minorPenalties': 236462006,
                    'totalPenalties': 380839095,
                    'pointsPer60': 469799972.136277,
                    'possessionPerMinute': 805208386.90251,
                    'shotEfficiency': 1824837264.43804,
                    'tkawayGvawayRatio': 737636238.191548,
                    'penaltyDifferential': 1766867900,
                    'defActionsPerMinute': 1798852421.59552,
                    'offImpact': 558767051.7942,
                    'defImpact': 1712560833.56661,
                    'detailedPosition': 'hfhbbfdad',
                    'positionAbbreviation': 'bccahfjbce',
                    'gameImpactScore': 1711153661.164821,
                    'puckManagementRating': 1168390467.210036,
                    'possessionEfficiency': 823124217.194437,
                    'netDefContribution': 273098399.151060,
                    'timeAdjustedRating': 1021612981.116301,
                    'shotGenerationRate': 1895927227.81333,
                    'offZonePresence': 51885617.170299,
                    'twoWayRating': 1227967127.91442,
                    'breakawaySavePct': 562070637.9016,
                    'breakawaySaves': 1211496755,
                    'breakawayShots': 1633342704,
                    'desperationSaves': 1110309481,
                    'goalsAgainst': 102092014,
                    'goalsAgainstAverage': 701298063.205837,
                    'penaltyShotSavePct': 119723045.53829,
                    'penaltyShotSaves': 2116901803,
                    'penaltyShotsFaced': 1551913480,
                    'goaliePkClearZone': 1976667553,
                    'pokeChecks': 1860602822,
                    'savePct': 1474561927.214411,
                    'totalSaves': 509108957,
                    'totalShotsFaced': 1840225874,
                    'shutoutPeriods': 2070910243,
                    'goalsSaved': 1241864736,
                },
                {
                    # data to create a PlayerMatch record
                    'matchId': 'caffadchjd',
                    'playerTeamSeasonId': 'ibeaecfcg',
                    'playerSeasonId': 'biccbihgeh',
                    'playerLevel': 1161164876,
                    'position': 'baiagjciif',
                    'posSorted': 1718920618,
                    'playerName': 'bjhdefecdf',
                    'clientPlatform': 'hihfaadee',
                    'playerLevelDisplay': 623386897,
                    'isGuest': True,
                    'playerDnf': False,
                    'pNhlOnlineGameType': 'bghdbegga',
                    'eaTeamId': 'bcffjiadgf',
                    'teamSide': 406339586,
                    'opponentClubId': 'bjjgejcafb',
                    'opponentEaTeamId': 'fbfaidaii',
                    'opponentScore': 1455743305,
                    'score': 904813134,
                    'ratingDefense': 1012164463.37421,
                    'ratingOffense': 1794197765.127256,
                    'ratingTeamplay': 1441401739.48112,
                    'toi': 2143449217,
                    'toiSeconds': 1758946598,
                    'assists': 636212583,
                    'blockedShots': 890859284,
                    'deflections': 1495569341,
                    'faceoffsLost': 1522838962,
                    'faceoffPct': 475422979.76601,
                    'faceoffsWon': 327921337,
                    'giveaways': 2110518014,
                    'goals': 575933023,
                    'gameWinningGoals': 1567329452,
                    'hits': 78609781,
                    'interceptions': 879771914,
                    'passAttempts': 1599663483,
                    'passes': 425379736,
                    'passPct': 1812429809.141514,
                    'penaltiesDrawn': 872343127,
                    'penaltyMinutes': 201377092,
                    'skaterPkClearZone': 788981293,
                    'plusMinus': 333440866,
                    'possessionSeconds': 111251699,
                    'powerPlayGoals': 1541861808,
                    'saucerPasses': 488159273,
                    'shortHandedGoals': 1146689454,
                    'shotAttempts': 1035618639,
                    'shotsOnNetPct': 1287747804.200249,
                    'shootingPct': 1696792762.6685,
                    'shotsOnGoal': 1197164232,
                    'takeaways': 941507425,
                    'points': 1534094982,
                    'faceoffsTotal': 842011463,
                    'shotsMissed': 1950484340,
                    'passesMissed': 1444590749,
                    'passingPct': 1523903762.206049,
                    'majorPenalties': 1429350112,
                    'minorPenalties': 2138242457,
                    'totalPenalties': 1251002462,
                    'pointsPer60': 862331967.15537,
                    'possessionPerMinute': 141351509.86593,
                    'shotEfficiency': 1470285147.66807,
                    'tkawayGvawayRatio': 166577873.5816,
                    'penaltyDifferential': 574512183,
                    'defActionsPerMinute': 1580217764.180715,
                    'offImpact': 799981250.146922,
                    'defImpact': 1007486992.144923,
                    'detailedPosition': 'badghjceg',
                    'positionAbbreviation': 'fachaaieh',
                    'gameImpactScore': 1520604476.122644,
                    'puckManagementRating': 910779418.214510,
                    'possessionEfficiency': 1252116776.132730,
                    'netDefContribution': 1586079718.194043,
                    'timeAdjustedRating': 1960726484.28434,
                    'shotGenerationRate': 725113970.8954,
                    'offZonePresence': 1505400128.103043,
                    'twoWayRating': 1370213822.211043,
                    'breakawaySavePct': 1532216684.10657,
                    'breakawaySaves': 1951598538,
                    'breakawayShots': 603327803,
                    'desperationSaves': 2121124952,
                    'goalsAgainst': 756220337,
                    'goalsAgainstAverage': 998364822.194080,
                    'penaltyShotSavePct': 1310676484.152076,
                    'penaltyShotSaves': 788317730,
                    'penaltyShotsFaced': 1716185267,
                    'goaliePkClearZone': 1312673392,
                    'pokeChecks': 1071068649,
                    'savePct': 474292846.68795,
                    'totalSaves': 680092060,
                    'totalShotsFaced': 954484645,
                    'shutoutPeriods': 363132794,
                    'goalsSaved': 1560329003,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerMatch record.

        Parameters
        ----------
        where
            PlayerMatch filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The deleted PlayerMatch record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().delete(
            where={
                'id': 'baacfige',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerMatch record.

        Parameters
        ----------
        where
            PlayerMatch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The found PlayerMatch record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().find_unique(
            where={
                'id': 'bijfcbheeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerMatch record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerMatch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The found PlayerMatch record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().find_unique_or_raise(
            where={
                'id': 'beecfbhdbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerMatch records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerMatch records returned
        skip
            Ignore the first N results
        where
            PlayerMatch filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerMatch]
            The list of all PlayerMatch records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerMatch records
        playermatchs = await PlayerMatch.prisma().find_many(take=10)

        # find the first 5 PlayerMatch records ordered by the playerTeamSeasonId field
        playermatchs = await PlayerMatch.prisma().find_many(
            take=5,
            order={
                'playerTeamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerMatch record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerMatch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerMatch
            The first PlayerMatch record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerMatch record ordered by the playerSeasonId field
        playermatch = await PlayerMatch.prisma().find_first(
            skip=1,
            order={
                'playerSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
        include: Optional[types.PlayerMatchInclude] = None,
        order: Optional[Union[types.PlayerMatchOrderByInput, List[types.PlayerMatchOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerMatchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerMatch record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerMatch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerMatch model
        order
            Order the returned PlayerMatch records by any field
        distinct
            Filter PlayerMatch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerMatch
            The first PlayerMatch record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerMatch record ordered by the playerLevel field
        playermatch = await PlayerMatch.prisma().find_first_or_raise(
            skip=1,
            order={
                'playerLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerMatchUpdateInput,
        where: types.PlayerMatchWhereUniqueInput,
        include: Optional[types.PlayerMatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerMatch record.

        Parameters
        ----------
        data
            PlayerMatch record data specifying what to update
        where
            PlayerMatch filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The updated PlayerMatch record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().update(
            where={
                'id': 'bacifbdfed',
            },
            data={
                # data to update the PlayerMatch record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerMatchWhereUniqueInput,
        data: types.PlayerMatchUpsertInput,
        include: Optional[types.PlayerMatchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerMatch filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerMatch model

        Returns
        -------
        prisma.models.PlayerMatch
            The created or updated PlayerMatch record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playermatch = await PlayerMatch.prisma().upsert(
            where={
                'id': 'eefaahjce',
            },
            data={
                'create': {
                    'id': 'eefaahjce',
                    'matchId': 'caffadchjd',
                    'playerTeamSeasonId': 'ibeaecfcg',
                    'playerSeasonId': 'biccbihgeh',
                    'playerLevel': 1161164876,
                    'position': 'baiagjciif',
                    'posSorted': 1718920618,
                    'playerName': 'bjhdefecdf',
                    'clientPlatform': 'hihfaadee',
                    'playerLevelDisplay': 623386897,
                    'isGuest': True,
                    'playerDnf': False,
                    'pNhlOnlineGameType': 'bghdbegga',
                    'eaTeamId': 'bcffjiadgf',
                    'teamSide': 406339586,
                    'opponentClubId': 'bjjgejcafb',
                    'opponentEaTeamId': 'fbfaidaii',
                    'opponentScore': 1455743305,
                    'score': 904813134,
                    'ratingDefense': 1012164463.37421,
                    'ratingOffense': 1794197765.127256,
                    'ratingTeamplay': 1441401739.48112,
                    'toi': 2143449217,
                    'toiSeconds': 1758946598,
                    'assists': 636212583,
                    'blockedShots': 890859284,
                    'deflections': 1495569341,
                    'faceoffsLost': 1522838962,
                    'faceoffPct': 475422979.76601,
                    'faceoffsWon': 327921337,
                    'giveaways': 2110518014,
                    'goals': 575933023,
                    'gameWinningGoals': 1567329452,
                    'hits': 78609781,
                    'interceptions': 879771914,
                    'passAttempts': 1599663483,
                    'passes': 425379736,
                    'passPct': 1812429809.141514,
                    'penaltiesDrawn': 872343127,
                    'penaltyMinutes': 201377092,
                    'skaterPkClearZone': 788981293,
                    'plusMinus': 333440866,
                    'possessionSeconds': 111251699,
                    'powerPlayGoals': 1541861808,
                    'saucerPasses': 488159273,
                    'shortHandedGoals': 1146689454,
                    'shotAttempts': 1035618639,
                    'shotsOnNetPct': 1287747804.200249,
                    'shootingPct': 1696792762.6685,
                    'shotsOnGoal': 1197164232,
                    'takeaways': 941507425,
                    'points': 1534094982,
                    'faceoffsTotal': 842011463,
                    'shotsMissed': 1950484340,
                    'passesMissed': 1444590749,
                    'passingPct': 1523903762.206049,
                    'majorPenalties': 1429350112,
                    'minorPenalties': 2138242457,
                    'totalPenalties': 1251002462,
                    'pointsPer60': 862331967.15537,
                    'possessionPerMinute': 141351509.86593,
                    'shotEfficiency': 1470285147.66807,
                    'tkawayGvawayRatio': 166577873.5816,
                    'penaltyDifferential': 574512183,
                    'defActionsPerMinute': 1580217764.180715,
                    'offImpact': 799981250.146922,
                    'defImpact': 1007486992.144923,
                    'detailedPosition': 'badghjceg',
                    'positionAbbreviation': 'fachaaieh',
                    'gameImpactScore': 1520604476.122644,
                    'puckManagementRating': 910779418.214510,
                    'possessionEfficiency': 1252116776.132730,
                    'netDefContribution': 1586079718.194043,
                    'timeAdjustedRating': 1960726484.28434,
                    'shotGenerationRate': 725113970.8954,
                    'offZonePresence': 1505400128.103043,
                    'twoWayRating': 1370213822.211043,
                    'breakawaySavePct': 1532216684.10657,
                    'breakawaySaves': 1951598538,
                    'breakawayShots': 603327803,
                    'desperationSaves': 2121124952,
                    'goalsAgainst': 756220337,
                    'goalsAgainstAverage': 998364822.194080,
                    'penaltyShotSavePct': 1310676484.152076,
                    'penaltyShotSaves': 788317730,
                    'penaltyShotsFaced': 1716185267,
                    'goaliePkClearZone': 1312673392,
                    'pokeChecks': 1071068649,
                    'savePct': 474292846.68795,
                    'totalSaves': 680092060,
                    'totalShotsFaced': 954484645,
                    'shutoutPeriods': 363132794,
                    'goalsSaved': 1560329003,
                },
                'update': {
                    'matchId': 'caffadchjd',
                    'playerTeamSeasonId': 'ibeaecfcg',
                    'playerSeasonId': 'biccbihgeh',
                    'playerLevel': 1161164876,
                    'position': 'baiagjciif',
                    'posSorted': 1718920618,
                    'playerName': 'bjhdefecdf',
                    'clientPlatform': 'hihfaadee',
                    'playerLevelDisplay': 623386897,
                    'isGuest': True,
                    'playerDnf': False,
                    'pNhlOnlineGameType': 'bghdbegga',
                    'eaTeamId': 'bcffjiadgf',
                    'teamSide': 406339586,
                    'opponentClubId': 'bjjgejcafb',
                    'opponentEaTeamId': 'fbfaidaii',
                    'opponentScore': 1455743305,
                    'score': 904813134,
                    'ratingDefense': 1012164463.37421,
                    'ratingOffense': 1794197765.127256,
                    'ratingTeamplay': 1441401739.48112,
                    'toi': 2143449217,
                    'toiSeconds': 1758946598,
                    'assists': 636212583,
                    'blockedShots': 890859284,
                    'deflections': 1495569341,
                    'faceoffsLost': 1522838962,
                    'faceoffPct': 475422979.76601,
                    'faceoffsWon': 327921337,
                    'giveaways': 2110518014,
                    'goals': 575933023,
                    'gameWinningGoals': 1567329452,
                    'hits': 78609781,
                    'interceptions': 879771914,
                    'passAttempts': 1599663483,
                    'passes': 425379736,
                    'passPct': 1812429809.141514,
                    'penaltiesDrawn': 872343127,
                    'penaltyMinutes': 201377092,
                    'skaterPkClearZone': 788981293,
                    'plusMinus': 333440866,
                    'possessionSeconds': 111251699,
                    'powerPlayGoals': 1541861808,
                    'saucerPasses': 488159273,
                    'shortHandedGoals': 1146689454,
                    'shotAttempts': 1035618639,
                    'shotsOnNetPct': 1287747804.200249,
                    'shootingPct': 1696792762.6685,
                    'shotsOnGoal': 1197164232,
                    'takeaways': 941507425,
                    'points': 1534094982,
                    'faceoffsTotal': 842011463,
                    'shotsMissed': 1950484340,
                    'passesMissed': 1444590749,
                    'passingPct': 1523903762.206049,
                    'majorPenalties': 1429350112,
                    'minorPenalties': 2138242457,
                    'totalPenalties': 1251002462,
                    'pointsPer60': 862331967.15537,
                    'possessionPerMinute': 141351509.86593,
                    'shotEfficiency': 1470285147.66807,
                    'tkawayGvawayRatio': 166577873.5816,
                    'penaltyDifferential': 574512183,
                    'defActionsPerMinute': 1580217764.180715,
                    'offImpact': 799981250.146922,
                    'defImpact': 1007486992.144923,
                    'detailedPosition': 'badghjceg',
                    'positionAbbreviation': 'fachaaieh',
                    'gameImpactScore': 1520604476.122644,
                    'puckManagementRating': 910779418.214510,
                    'possessionEfficiency': 1252116776.132730,
                    'netDefContribution': 1586079718.194043,
                    'timeAdjustedRating': 1960726484.28434,
                    'shotGenerationRate': 725113970.8954,
                    'offZonePresence': 1505400128.103043,
                    'twoWayRating': 1370213822.211043,
                    'breakawaySavePct': 1532216684.10657,
                    'breakawaySaves': 1951598538,
                    'breakawayShots': 603327803,
                    'desperationSaves': 2121124952,
                    'goalsAgainst': 756220337,
                    'goalsAgainstAverage': 998364822.194080,
                    'penaltyShotSavePct': 1310676484.152076,
                    'penaltyShotSaves': 788317730,
                    'penaltyShotsFaced': 1716185267,
                    'goaliePkClearZone': 1312673392,
                    'pokeChecks': 1071068649,
                    'savePct': 474292846.68795,
                    'totalSaves': 680092060,
                    'totalShotsFaced': 954484645,
                    'shutoutPeriods': 363132794,
                    'goalsSaved': 1560329003,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerMatchUpdateManyMutationInput,
        where: types.PlayerMatchWhereInput,
    ) -> int:
        """Update multiple PlayerMatch records

        Parameters
        ----------
        data
            PlayerMatch data to update the selected PlayerMatch records to
        where
            Filter to select the PlayerMatch records to update

        Returns
        -------
        int
            The total number of PlayerMatch records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerMatch records
        total = await PlayerMatch.prisma().update_many(
            data={
                'position': 'bajhbcdecb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerMatch records present in the database

        Parameters
        ----------
        select
            Select the PlayerMatch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerMatch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerMatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerMatch.prisma().count()

        # results: prisma.types.PlayerMatchCountAggregateOutput
        results = await PlayerMatch.prisma().count(
            select={
                '_all': True,
                'posSorted': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerMatchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> types.PlayerMatchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerMatchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerMatchWhereInput] = None,
        cursor: Optional[types.PlayerMatchWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerMatchCountAggregateOutput]:
        """Count the number of PlayerMatch records present in the database

        Parameters
        ----------
        select
            Select the PlayerMatch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerMatch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerMatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerMatch.prisma().count()

        # results: prisma.types.PlayerMatchCountAggregateOutput
        results = await PlayerMatch.prisma().count(
            select={
                '_all': True,
                'playerName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerMatchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerMatchWhereInput] = None
    ) -> int:
        """Delete multiple PlayerMatch records.

        Parameters
        ----------
        where
            Optional PlayerMatch filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerMatch records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerMatch records
        total = await PlayerMatch.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerMatchScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerMatchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerMatchAvgAggregateInput'] = None,
        sum: Optional['types.PlayerMatchSumAggregateInput'] = None,
        min: Optional['types.PlayerMatchMinAggregateInput'] = None,
        max: Optional['types.PlayerMatchMaxAggregateInput'] = None,
        having: Optional['types.PlayerMatchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerMatchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerMatchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerMatchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerMatchGroupByOutput']:
        """Group PlayerMatch records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerMatch fields to group records by
        where
            PlayerMatch filter to select records
        take
            Limit the maximum number of PlayerMatch records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerMatchGroupByOutput]
            A list of dictionaries representing the PlayerMatch record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerMatch records by clientPlatform values
        # and count how many records are in each group
        results = await PlayerMatch.prisma().group_by(
            ['clientPlatform'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerSeason.prisma().query_raw(
            'SELECT * FROM PlayerSeason WHERE id = $1',
            'dfgjhdfcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerSeason.prisma().query_first(
            'SELECT * FROM PlayerSeason WHERE userId = $1',
            'bbiagfgiad',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerSeasonCreateInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerSeason record.

        Parameters
        ----------
        data
            PlayerSeason record data
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The created PlayerSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerSeason record from just the required fields
        playerseason = await PlayerSeason.prisma().create(
            data={
                # data to create a PlayerSeason record
                'userId': 'bahjgcafbc',
                'seasonId': 'bcbjcfjccf',
                'contractId': 'edfeihfbi',
                'primaryPosition': enums.PlayerPosition.LW,
                'positionGroup': enums.PositionGroup.FORWARD,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerSeason.prisma().create_many(
            data=[
                {
                    # data to create a PlayerSeason record
                    'userId': 'jjhicigah',
                    'seasonId': 'daffffjbg',
                    'contractId': 'bjggaeaaif',
                    'primaryPosition': enums.PlayerPosition.LW,
                    'positionGroup': enums.PositionGroup.FORWARD,
                },
                {
                    # data to create a PlayerSeason record
                    'userId': 'dbhddieba',
                    'seasonId': 'gdeaefhcd',
                    'contractId': 'hfjfieeea',
                    'primaryPosition': enums.PlayerPosition.LW,
                    'positionGroup': enums.PositionGroup.FORWARD,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerSeason record.

        Parameters
        ----------
        where
            PlayerSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The deleted PlayerSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().delete(
            where={
                'id': 'cbecbiggeb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerSeason record.

        Parameters
        ----------
        where
            PlayerSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The found PlayerSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().find_unique(
            where={
                'id': 'bafjcigje',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The found PlayerSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().find_unique_or_raise(
            where={
                'id': 'gjcejcchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerSeason records returned
        skip
            Ignore the first N results
        where
            PlayerSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerSeason]
            The list of all PlayerSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerSeason records
        playerseasons = await PlayerSeason.prisma().find_many(take=10)

        # find the first 5 PlayerSeason records ordered by the seasonId field
        playerseasons = await PlayerSeason.prisma().find_many(
            take=5,
            order={
                'seasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerSeason
            The first PlayerSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerSeason record ordered by the contractId field
        playerseason = await PlayerSeason.prisma().find_first(
            skip=1,
            order={
                'contractId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerSeasonInclude] = None,
        order: Optional[Union[types.PlayerSeasonOrderByInput, List[types.PlayerSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerSeason model
        order
            Order the returned PlayerSeason records by any field
        distinct
            Filter PlayerSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerSeason
            The first PlayerSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerSeason record ordered by the primaryPosition field
        playerseason = await PlayerSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'primaryPosition': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerSeasonUpdateInput,
        where: types.PlayerSeasonWhereUniqueInput,
        include: Optional[types.PlayerSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerSeason record.

        Parameters
        ----------
        data
            PlayerSeason record data specifying what to update
        where
            PlayerSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The updated PlayerSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().update(
            where={
                'id': 'bedchfhiga',
            },
            data={
                # data to update the PlayerSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerSeasonWhereUniqueInput,
        data: types.PlayerSeasonUpsertInput,
        include: Optional[types.PlayerSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerSeason model

        Returns
        -------
        prisma.models.PlayerSeason
            The created or updated PlayerSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerseason = await PlayerSeason.prisma().upsert(
            where={
                'id': 'cjebjbdaj',
            },
            data={
                'create': {
                    'id': 'cjebjbdaj',
                    'userId': 'dbhddieba',
                    'seasonId': 'gdeaefhcd',
                    'contractId': 'hfjfieeea',
                    'primaryPosition': enums.PlayerPosition.LW,
                    'positionGroup': enums.PositionGroup.FORWARD,
                },
                'update': {
                    'userId': 'dbhddieba',
                    'seasonId': 'gdeaefhcd',
                    'contractId': 'hfjfieeea',
                    'primaryPosition': enums.PlayerPosition.LW,
                    'positionGroup': enums.PositionGroup.FORWARD,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerSeasonUpdateManyMutationInput,
        where: types.PlayerSeasonWhereInput,
    ) -> int:
        """Update multiple PlayerSeason records

        Parameters
        ----------
        data
            PlayerSeason data to update the selected PlayerSeason records to
        where
            Filter to select the PlayerSeason records to update

        Returns
        -------
        int
            The total number of PlayerSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerSeason records
        total = await PlayerSeason.prisma().update_many(
            data={
                'positionGroup': enums.PositionGroup.FORWARD
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerSeason.prisma().count()

        # results: prisma.types.PlayerSeasonCountAggregateOutput
        results = await PlayerSeason.prisma().count(
            select={
                '_all': True,
                'isInBidding': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> types.PlayerSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerSeasonWhereInput] = None,
        cursor: Optional[types.PlayerSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerSeasonCountAggregateOutput]:
        """Count the number of PlayerSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerSeason.prisma().count()

        # results: prisma.types.PlayerSeasonCountAggregateOutput
        results = await PlayerSeason.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerSeasonWhereInput] = None
    ) -> int:
        """Delete multiple PlayerSeason records.

        Parameters
        ----------
        where
            Optional PlayerSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerSeason records
        total = await PlayerSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerSeasonAvgAggregateInput'] = None,
        sum: Optional['types.PlayerSeasonSumAggregateInput'] = None,
        min: Optional['types.PlayerSeasonMinAggregateInput'] = None,
        max: Optional['types.PlayerSeasonMaxAggregateInput'] = None,
        having: Optional['types.PlayerSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerSeasonGroupByOutput']:
        """Group PlayerSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerSeason fields to group records by
        where
            PlayerSeason filter to select records
        take
            Limit the maximum number of PlayerSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerSeasonGroupByOutput]
            A list of dictionaries representing the PlayerSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerSeason records by updatedAt values
        # and count how many records are in each group
        results = await PlayerSeason.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerTeamSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerTeamSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerTeamSeason.prisma().query_raw(
            'SELECT * FROM PlayerTeamSeason WHERE id = $1',
            'bgcjgbhfdi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerTeamSeason.prisma().query_first(
            'SELECT * FROM PlayerTeamSeason WHERE playerSeasonId = $1',
            'bcgcggeifb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerTeamSeasonCreateInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerTeamSeason record.

        Parameters
        ----------
        data
            PlayerTeamSeason record data
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The created PlayerTeamSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerTeamSeason record from just the required fields
        playerteamseason = await PlayerTeamSeason.prisma().create(
            data={
                # data to create a PlayerTeamSeason record
                'playerSeasonId': 'cchgcebee',
                'teamSeasonId': 'dbdgegcib',
                'leagueType': enums.LeagueType.NHL,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerTeamSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerTeamSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerTeamSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerTeamSeason.prisma().create_many(
            data=[
                {
                    # data to create a PlayerTeamSeason record
                    'playerSeasonId': 'bjdhbebhba',
                    'teamSeasonId': 'bbeegceeh',
                    'leagueType': enums.LeagueType.NHL,
                },
                {
                    # data to create a PlayerTeamSeason record
                    'playerSeasonId': 'bcfjbjjjjg',
                    'teamSeasonId': 'bfdeccjgdh',
                    'leagueType': enums.LeagueType.NHL,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerTeamSeason record.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The deleted PlayerTeamSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().delete(
            where={
                'id': 'bhadhihccg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerTeamSeason record.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The found PlayerTeamSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().find_unique(
            where={
                'id': 'bcfgeabghf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerTeamSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerTeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The found PlayerTeamSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().find_unique_or_raise(
            where={
                'id': 'hjedfdbci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerTeamSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerTeamSeason records returned
        skip
            Ignore the first N results
        where
            PlayerTeamSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerTeamSeason]
            The list of all PlayerTeamSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerTeamSeason records
        playerteamseasons = await PlayerTeamSeason.prisma().find_many(take=10)

        # find the first 5 PlayerTeamSeason records ordered by the teamSeasonId field
        playerteamseasons = await PlayerTeamSeason.prisma().find_many(
            take=5,
            order={
                'teamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerTeamSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first PlayerTeamSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTeamSeason record ordered by the leagueType field
        playerteamseason = await PlayerTeamSeason.prisma().find_first(
            skip=1,
            order={
                'leagueType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
        order: Optional[Union[types.PlayerTeamSeasonOrderByInput, List[types.PlayerTeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerTeamSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerTeamSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model
        order
            Order the returned PlayerTeamSeason records by any field
        distinct
            Filter PlayerTeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The first PlayerTeamSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerTeamSeason record ordered by the rosterTeamId field
        playerteamseason = await PlayerTeamSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'rosterTeamId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerTeamSeasonUpdateInput,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerTeamSeason record.

        Parameters
        ----------
        data
            PlayerTeamSeason record data specifying what to update
        where
            PlayerTeamSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The updated PlayerTeamSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().update(
            where={
                'id': 'bbhcfcibcj',
            },
            data={
                # data to update the PlayerTeamSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerTeamSeasonWhereUniqueInput,
        data: types.PlayerTeamSeasonUpsertInput,
        include: Optional[types.PlayerTeamSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerTeamSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerTeamSeason model

        Returns
        -------
        prisma.models.PlayerTeamSeason
            The created or updated PlayerTeamSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerteamseason = await PlayerTeamSeason.prisma().upsert(
            where={
                'id': 'bjagajchba',
            },
            data={
                'create': {
                    'id': 'bjagajchba',
                    'playerSeasonId': 'bcfjbjjjjg',
                    'teamSeasonId': 'bfdeccjgdh',
                    'leagueType': enums.LeagueType.NHL,
                },
                'update': {
                    'playerSeasonId': 'bcfjbjjjjg',
                    'teamSeasonId': 'bfdeccjgdh',
                    'leagueType': enums.LeagueType.NHL,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerTeamSeasonUpdateManyMutationInput,
        where: types.PlayerTeamSeasonWhereInput,
    ) -> int:
        """Update multiple PlayerTeamSeason records

        Parameters
        ----------
        data
            PlayerTeamSeason data to update the selected PlayerTeamSeason records to
        where
            Filter to select the PlayerTeamSeason records to update

        Returns
        -------
        int
            The total number of PlayerTeamSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerTeamSeason records
        total = await PlayerTeamSeason.prisma().update_many(
            data={
                'trainingCampTeamId': 'baebhccfjj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerTeamSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerTeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTeamSeason.prisma().count()

        # results: prisma.types.PlayerTeamSeasonCountAggregateOutput
        results = await PlayerTeamSeason.prisma().count(
            select={
                '_all': True,
                'inactiveTeamId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerTeamSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> types.PlayerTeamSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerTeamSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None,
        cursor: Optional[types.PlayerTeamSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerTeamSeasonCountAggregateOutput]:
        """Count the number of PlayerTeamSeason records present in the database

        Parameters
        ----------
        select
            Select the PlayerTeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerTeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerTeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerTeamSeason.prisma().count()

        # results: prisma.types.PlayerTeamSeasonCountAggregateOutput
        results = await PlayerTeamSeason.prisma().count(
            select={
                '_all': True,
                'isRosterPlayer': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerTeamSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerTeamSeasonWhereInput] = None
    ) -> int:
        """Delete multiple PlayerTeamSeason records.

        Parameters
        ----------
        where
            Optional PlayerTeamSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerTeamSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerTeamSeason records
        total = await PlayerTeamSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerTeamSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerTeamSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerTeamSeasonAvgAggregateInput'] = None,
        sum: Optional['types.PlayerTeamSeasonSumAggregateInput'] = None,
        min: Optional['types.PlayerTeamSeasonMinAggregateInput'] = None,
        max: Optional['types.PlayerTeamSeasonMaxAggregateInput'] = None,
        having: Optional['types.PlayerTeamSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerTeamSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerTeamSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerTeamSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerTeamSeasonGroupByOutput']:
        """Group PlayerTeamSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerTeamSeason fields to group records by
        where
            PlayerTeamSeason filter to select records
        take
            Limit the maximum number of PlayerTeamSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerTeamSeasonGroupByOutput]
            A list of dictionaries representing the PlayerTeamSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerTeamSeason records by isTrainingCampPlayer values
        # and count how many records are in each group
        results = await PlayerTeamSeason.prisma().group_by(
            ['isTrainingCampPlayer'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlayerLeagueHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PlayerLeagueHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PlayerLeagueHistory.prisma().query_raw(
            'SELECT * FROM PlayerLeagueHistory WHERE id = $1',
            'bjfjjbfggi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PlayerLeagueHistory.prisma().query_first(
            'SELECT * FROM PlayerLeagueHistory WHERE playerSeasonId = $1',
            'bfcjdjfaaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlayerLeagueHistoryCreateInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new PlayerLeagueHistory record.

        Parameters
        ----------
        data
            PlayerLeagueHistory record data
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The created PlayerLeagueHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PlayerLeagueHistory record from just the required fields
        playerleaguehistory = await PlayerLeagueHistory.prisma().create(
            data={
                # data to create a PlayerLeagueHistory record
                'playerSeasonId': 'bifbdbcjeg',
                'leagueSeasonId': 'bgiechbcdf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlayerLeagueHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PlayerLeagueHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PlayerLeagueHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PlayerLeagueHistory.prisma().create_many(
            data=[
                {
                    # data to create a PlayerLeagueHistory record
                    'playerSeasonId': 'caejeajfdg',
                    'leagueSeasonId': 'eajijhfcj',
                },
                {
                    # data to create a PlayerLeagueHistory record
                    'playerSeasonId': 'bjiebjegig',
                    'leagueSeasonId': 'eafhbdfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlayerLeagueHistoryWhereUniqueInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PlayerLeagueHistory record.

        Parameters
        ----------
        where
            PlayerLeagueHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The deleted PlayerLeagueHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerleaguehistory = await PlayerLeagueHistory.prisma().delete(
            where={
                'id': 'ebbccbfei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlayerLeagueHistoryWhereUniqueInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PlayerLeagueHistory record.

        Parameters
        ----------
        where
            PlayerLeagueHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The found PlayerLeagueHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerleaguehistory = await PlayerLeagueHistory.prisma().find_unique(
            where={
                'id': 'bciccffcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlayerLeagueHistoryWhereUniqueInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PlayerLeagueHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PlayerLeagueHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The found PlayerLeagueHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerleaguehistory = await PlayerLeagueHistory.prisma().find_unique_or_raise(
            where={
                'id': 'jdejhdagg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerLeagueHistoryInclude] = None,
        order: Optional[Union[types.PlayerLeagueHistoryOrderByInput, List[types.PlayerLeagueHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerLeagueHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PlayerLeagueHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PlayerLeagueHistory records returned
        skip
            Ignore the first N results
        where
            PlayerLeagueHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model
        order
            Order the returned PlayerLeagueHistory records by any field
        distinct
            Filter PlayerLeagueHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PlayerLeagueHistory]
            The list of all PlayerLeagueHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PlayerLeagueHistory records
        playerleaguehistorys = await PlayerLeagueHistory.prisma().find_many(take=10)

        # find the first 5 PlayerLeagueHistory records ordered by the leagueSeasonId field
        playerleaguehistorys = await PlayerLeagueHistory.prisma().find_many(
            take=5,
            order={
                'leagueSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerLeagueHistoryInclude] = None,
        order: Optional[Union[types.PlayerLeagueHistoryOrderByInput, List[types.PlayerLeagueHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerLeagueHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PlayerLeagueHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerLeagueHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model
        order
            Order the returned PlayerLeagueHistory records by any field
        distinct
            Filter PlayerLeagueHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The first PlayerLeagueHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerLeagueHistory record ordered by the startDate field
        playerleaguehistory = await PlayerLeagueHistory.prisma().find_first(
            skip=1,
            order={
                'startDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
        include: Optional[types.PlayerLeagueHistoryInclude] = None,
        order: Optional[Union[types.PlayerLeagueHistoryOrderByInput, List[types.PlayerLeagueHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.PlayerLeagueHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PlayerLeagueHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PlayerLeagueHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model
        order
            Order the returned PlayerLeagueHistory records by any field
        distinct
            Filter PlayerLeagueHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The first PlayerLeagueHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PlayerLeagueHistory record ordered by the endDate field
        playerleaguehistory = await PlayerLeagueHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'endDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlayerLeagueHistoryUpdateInput,
        where: types.PlayerLeagueHistoryWhereUniqueInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PlayerLeagueHistory record.

        Parameters
        ----------
        data
            PlayerLeagueHistory record data specifying what to update
        where
            PlayerLeagueHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The updated PlayerLeagueHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        playerleaguehistory = await PlayerLeagueHistory.prisma().update(
            where={
                'id': 'bfbjjhbfhj',
            },
            data={
                # data to update the PlayerLeagueHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlayerLeagueHistoryWhereUniqueInput,
        data: types.PlayerLeagueHistoryUpsertInput,
        include: Optional[types.PlayerLeagueHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PlayerLeagueHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PlayerLeagueHistory model

        Returns
        -------
        prisma.models.PlayerLeagueHistory
            The created or updated PlayerLeagueHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        playerleaguehistory = await PlayerLeagueHistory.prisma().upsert(
            where={
                'id': 'ibciiabfc',
            },
            data={
                'create': {
                    'id': 'ibciiabfc',
                    'playerSeasonId': 'bjiebjegig',
                    'leagueSeasonId': 'eafhbdfj',
                },
                'update': {
                    'playerSeasonId': 'bjiebjegig',
                    'leagueSeasonId': 'eafhbdfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlayerLeagueHistoryUpdateManyMutationInput,
        where: types.PlayerLeagueHistoryWhereInput,
    ) -> int:
        """Update multiple PlayerLeagueHistory records

        Parameters
        ----------
        data
            PlayerLeagueHistory data to update the selected PlayerLeagueHistory records to
        where
            Filter to select the PlayerLeagueHistory records to update

        Returns
        -------
        int
            The total number of PlayerLeagueHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PlayerLeagueHistory records
        total = await PlayerLeagueHistory.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PlayerLeagueHistory records present in the database

        Parameters
        ----------
        select
            Select the PlayerLeagueHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerLeagueHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerLeagueHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerLeagueHistory.prisma().count()

        # results: prisma.types.PlayerLeagueHistoryCountAggregateOutput
        results = await PlayerLeagueHistory.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlayerLeagueHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
    ) -> types.PlayerLeagueHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlayerLeagueHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None,
        cursor: Optional[types.PlayerLeagueHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.PlayerLeagueHistoryCountAggregateOutput]:
        """Count the number of PlayerLeagueHistory records present in the database

        Parameters
        ----------
        select
            Select the PlayerLeagueHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PlayerLeagueHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlayerLeagueHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PlayerLeagueHistory.prisma().count()

        # results: prisma.types.PlayerLeagueHistoryCountAggregateOutput
        results = await PlayerLeagueHistory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlayerLeagueHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlayerLeagueHistoryWhereInput] = None
    ) -> int:
        """Delete multiple PlayerLeagueHistory records.

        Parameters
        ----------
        where
            Optional PlayerLeagueHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PlayerLeagueHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PlayerLeagueHistory records
        total = await PlayerLeagueHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlayerLeagueHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.PlayerLeagueHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlayerLeagueHistoryAvgAggregateInput'] = None,
        sum: Optional['types.PlayerLeagueHistorySumAggregateInput'] = None,
        min: Optional['types.PlayerLeagueHistoryMinAggregateInput'] = None,
        max: Optional['types.PlayerLeagueHistoryMaxAggregateInput'] = None,
        having: Optional['types.PlayerLeagueHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlayerLeagueHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlayerLeagueHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlayerLeagueHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlayerLeagueHistoryGroupByOutput']:
        """Group PlayerLeagueHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PlayerLeagueHistory fields to group records by
        where
            PlayerLeagueHistory filter to select records
        take
            Limit the maximum number of PlayerLeagueHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlayerLeagueHistoryGroupByOutput]
            A list of dictionaries representing the PlayerLeagueHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PlayerLeagueHistory records by playerSeasonId values
        # and count how many records are in each group
        results = await PlayerLeagueHistory.prisma().group_by(
            ['playerSeasonId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNProfile.prisma().query_raw(
            'SELECT * FROM PSNProfile WHERE id = $1',
            'ghahbdhbd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNProfile.prisma().query_first(
            'SELECT * FROM PSNProfile WHERE userId = $1',
            'jgiffijde',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNProfileCreateInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNProfile record.

        Parameters
        ----------
        data
            PSNProfile record data
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The created PSNProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNProfile record from just the required fields
        psnprofile = await PSNProfile.prisma().create(
            data={
                # data to create a PSNProfile record
                'userId': 'fdgicjdjj',
                'onlineId': 'ecjgjghai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNProfile.prisma().create_many(
            data=[
                {
                    # data to create a PSNProfile record
                    'userId': 'bgefjdajcf',
                    'onlineId': 'fgbeahcac',
                },
                {
                    # data to create a PSNProfile record
                    'userId': 'jiijdidff',
                    'onlineId': 'bgcjeejaai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNProfile record.

        Parameters
        ----------
        where
            PSNProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The deleted PSNProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().delete(
            where={
                'id': 'gjicfeej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNProfile record.

        Parameters
        ----------
        where
            PSNProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The found PSNProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().find_unique(
            where={
                'id': 'bbfajdiebe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The found PSNProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().find_unique_or_raise(
            where={
                'id': 'jjgcjahgh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNProfile records returned
        skip
            Ignore the first N results
        where
            PSNProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNProfile]
            The list of all PSNProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNProfile records
        psnprofiles = await PSNProfile.prisma().find_many(take=10)

        # find the first 5 PSNProfile records ordered by the onlineId field
        psnprofiles = await PSNProfile.prisma().find_many(
            take=5,
            order={
                'onlineId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNProfile
            The first PSNProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNProfile record ordered by the accountId field
        psnprofile = await PSNProfile.prisma().find_first(
            skip=1,
            order={
                'accountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
        include: Optional[types.PSNProfileInclude] = None,
        order: Optional[Union[types.PSNProfileOrderByInput, List[types.PSNProfileOrderByInput]]] = None,
        distinct: Optional[List[types.PSNProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNProfile model
        order
            Order the returned PSNProfile records by any field
        distinct
            Filter PSNProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNProfile
            The first PSNProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNProfile record ordered by the aboutMe field
        psnprofile = await PSNProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'aboutMe': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNProfileUpdateInput,
        where: types.PSNProfileWhereUniqueInput,
        include: Optional[types.PSNProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNProfile record.

        Parameters
        ----------
        data
            PSNProfile record data specifying what to update
        where
            PSNProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The updated PSNProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().update(
            where={
                'id': 'egggecie',
            },
            data={
                # data to update the PSNProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNProfileWhereUniqueInput,
        data: types.PSNProfileUpsertInput,
        include: Optional[types.PSNProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNProfile model

        Returns
        -------
        prisma.models.PSNProfile
            The created or updated PSNProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnprofile = await PSNProfile.prisma().upsert(
            where={
                'id': 'cejeejjh',
            },
            data={
                'create': {
                    'id': 'cejeejjh',
                    'userId': 'jiijdidff',
                    'onlineId': 'bgcjeejaai',
                },
                'update': {
                    'userId': 'jiijdidff',
                    'onlineId': 'bgcjeejaai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNProfileUpdateManyMutationInput,
        where: types.PSNProfileWhereInput,
    ) -> int:
        """Update multiple PSNProfile records

        Parameters
        ----------
        data
            PSNProfile data to update the selected PSNProfile records to
        where
            Filter to select the PSNProfile records to update

        Returns
        -------
        int
            The total number of PSNProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNProfile records
        total = await PSNProfile.prisma().update_many(
            data={
                'languages': ['debffcgji']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNProfile records present in the database

        Parameters
        ----------
        select
            Select the PSNProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNProfile.prisma().count()

        # results: prisma.types.PSNProfileCountAggregateOutput
        results = await PSNProfile.prisma().count(
            select={
                '_all': True,
                'isPlus': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> types.PSNProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNProfileWhereInput] = None,
        cursor: Optional[types.PSNProfileWhereUniqueInput] = None,
    ) -> Union[int, types.PSNProfileCountAggregateOutput]:
        """Count the number of PSNProfile records present in the database

        Parameters
        ----------
        select
            Select the PSNProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNProfile.prisma().count()

        # results: prisma.types.PSNProfileCountAggregateOutput
        results = await PSNProfile.prisma().count(
            select={
                '_all': True,
                'isOfficiallyVerified': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNProfileWhereInput] = None
    ) -> int:
        """Delete multiple PSNProfile records.

        Parameters
        ----------
        where
            Optional PSNProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNProfile records
        total = await PSNProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNProfileScalarFieldKeysT'],
        *,
        where: Optional['types.PSNProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNProfileAvgAggregateInput'] = None,
        sum: Optional['types.PSNProfileSumAggregateInput'] = None,
        min: Optional['types.PSNProfileMinAggregateInput'] = None,
        max: Optional['types.PSNProfileMaxAggregateInput'] = None,
        having: Optional['types.PSNProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNProfileScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNProfileScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNProfileGroupByOutput']:
        """Group PSNProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNProfile fields to group records by
        where
            PSNProfile filter to select records
        take
            Limit the maximum number of PSNProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNProfileGroupByOutput]
            A list of dictionaries representing the PSNProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNProfile records by friendsCount values
        # and count how many records are in each group
        results = await PSNProfile.prisma().group_by(
            ['friendsCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNAvatarActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNAvatar]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNAvatar.prisma().query_raw(
            'SELECT * FROM PSNAvatar WHERE id = $1',
            'dfbjjggfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNAvatar
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNAvatar.prisma().query_first(
            'SELECT * FROM PSNAvatar WHERE profileId = $1',
            'bfafgejdg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNAvatarCreateInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNAvatar record.

        Parameters
        ----------
        data
            PSNAvatar record data
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The created PSNAvatar record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNAvatar record from just the required fields
        psnavatar = await PSNAvatar.prisma().create(
            data={
                # data to create a PSNAvatar record
                'profileId': 'bjbedghhbd',
                'size': 'hfjfjbjec',
                'url': 'bggahjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNAvatarCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNAvatar records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNAvatar record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNAvatar.prisma().create_many(
            data=[
                {
                    # data to create a PSNAvatar record
                    'profileId': 'bagcibfjii',
                    'size': 'cdecgegaf',
                    'url': 'djiidiebi',
                },
                {
                    # data to create a PSNAvatar record
                    'profileId': 'fgiagbach',
                    'size': 'bgibgfdifg',
                    'url': 'fdfeachhh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNAvatar record.

        Parameters
        ----------
        where
            PSNAvatar filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The deleted PSNAvatar record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().delete(
            where={
                'id': 'jbdfggdi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNAvatar record.

        Parameters
        ----------
        where
            PSNAvatar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The found PSNAvatar record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().find_unique(
            where={
                'id': 'bbfahebedj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNAvatar record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNAvatar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The found PSNAvatar record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().find_unique_or_raise(
            where={
                'id': 'iahjabfg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNAvatar records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNAvatar records returned
        skip
            Ignore the first N results
        where
            PSNAvatar filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNAvatar]
            The list of all PSNAvatar records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNAvatar records
        psnavatars = await PSNAvatar.prisma().find_many(take=10)

        # find the first 5 PSNAvatar records ordered by the size field
        psnavatars = await PSNAvatar.prisma().find_many(
            take=5,
            order={
                'size': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNAvatar record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNAvatar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNAvatar
            The first PSNAvatar record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNAvatar record ordered by the url field
        psnavatar = await PSNAvatar.prisma().find_first(
            skip=1,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
        include: Optional[types.PSNAvatarInclude] = None,
        order: Optional[Union[types.PSNAvatarOrderByInput, List[types.PSNAvatarOrderByInput]]] = None,
        distinct: Optional[List[types.PSNAvatarScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNAvatar record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNAvatar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNAvatar model
        order
            Order the returned PSNAvatar records by any field
        distinct
            Filter PSNAvatar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNAvatar
            The first PSNAvatar record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNAvatar record ordered by the createdAt field
        psnavatar = await PSNAvatar.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNAvatarUpdateInput,
        where: types.PSNAvatarWhereUniqueInput,
        include: Optional[types.PSNAvatarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNAvatar record.

        Parameters
        ----------
        data
            PSNAvatar record data specifying what to update
        where
            PSNAvatar filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The updated PSNAvatar record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().update(
            where={
                'id': 'hefgehfhd',
            },
            data={
                # data to update the PSNAvatar record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNAvatarWhereUniqueInput,
        data: types.PSNAvatarUpsertInput,
        include: Optional[types.PSNAvatarInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNAvatar filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNAvatar model

        Returns
        -------
        prisma.models.PSNAvatar
            The created or updated PSNAvatar record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnavatar = await PSNAvatar.prisma().upsert(
            where={
                'id': 'dihhbhgba',
            },
            data={
                'create': {
                    'id': 'dihhbhgba',
                    'profileId': 'fgiagbach',
                    'size': 'bgibgfdifg',
                    'url': 'fdfeachhh',
                },
                'update': {
                    'profileId': 'fgiagbach',
                    'size': 'bgibgfdifg',
                    'url': 'fdfeachhh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNAvatarUpdateManyMutationInput,
        where: types.PSNAvatarWhereInput,
    ) -> int:
        """Update multiple PSNAvatar records

        Parameters
        ----------
        data
            PSNAvatar data to update the selected PSNAvatar records to
        where
            Filter to select the PSNAvatar records to update

        Returns
        -------
        int
            The total number of PSNAvatar records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNAvatar records
        total = await PSNAvatar.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNAvatar records present in the database

        Parameters
        ----------
        select
            Select the PSNAvatar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNAvatar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNAvatarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNAvatar.prisma().count()

        # results: prisma.types.PSNAvatarCountAggregateOutput
        results = await PSNAvatar.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNAvatarCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> types.PSNAvatarCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNAvatarCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNAvatarWhereInput] = None,
        cursor: Optional[types.PSNAvatarWhereUniqueInput] = None,
    ) -> Union[int, types.PSNAvatarCountAggregateOutput]:
        """Count the number of PSNAvatar records present in the database

        Parameters
        ----------
        select
            Select the PSNAvatar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNAvatar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNAvatarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNAvatar.prisma().count()

        # results: prisma.types.PSNAvatarCountAggregateOutput
        results = await PSNAvatar.prisma().count(
            select={
                '_all': True,
                'profileId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNAvatarCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNAvatarWhereInput] = None
    ) -> int:
        """Delete multiple PSNAvatar records.

        Parameters
        ----------
        where
            Optional PSNAvatar filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNAvatar records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNAvatar records
        total = await PSNAvatar.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNAvatarScalarFieldKeysT'],
        *,
        where: Optional['types.PSNAvatarWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNAvatarAvgAggregateInput'] = None,
        sum: Optional['types.PSNAvatarSumAggregateInput'] = None,
        min: Optional['types.PSNAvatarMinAggregateInput'] = None,
        max: Optional['types.PSNAvatarMaxAggregateInput'] = None,
        having: Optional['types.PSNAvatarScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNAvatarCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNAvatarScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNAvatarScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNAvatarGroupByOutput']:
        """Group PSNAvatar records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNAvatar fields to group records by
        where
            PSNAvatar filter to select records
        take
            Limit the maximum number of PSNAvatar records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNAvatarGroupByOutput]
            A list of dictionaries representing the PSNAvatar record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNAvatar records by size values
        # and count how many records are in each group
        results = await PSNAvatar.prisma().group_by(
            ['size'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNTrophyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNTrophy]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNTrophy.prisma().query_raw(
            'SELECT * FROM PSNTrophy WHERE id = $1',
            'bfeajbgeed',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNTrophy
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNTrophy.prisma().query_first(
            'SELECT * FROM PSNTrophy WHERE profileId = $1',
            'bihjjdbhgi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNTrophyCreateInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNTrophy record.

        Parameters
        ----------
        data
            PSNTrophy record data
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The created PSNTrophy record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNTrophy record from just the required fields
        psntrophy = await PSNTrophy.prisma().create(
            data={
                # data to create a PSNTrophy record
                'profileId': 'bcbaigecaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNTrophyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNTrophy records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNTrophy record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNTrophy.prisma().create_many(
            data=[
                {
                    # data to create a PSNTrophy record
                    'profileId': 'caagfhfhji',
                },
                {
                    # data to create a PSNTrophy record
                    'profileId': 'cicbaehfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNTrophy record.

        Parameters
        ----------
        where
            PSNTrophy filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The deleted PSNTrophy record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().delete(
            where={
                'id': 'bibhijcgee',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNTrophy record.

        Parameters
        ----------
        where
            PSNTrophy filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The found PSNTrophy record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().find_unique(
            where={
                'id': 'bfbbbhiijd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNTrophy record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNTrophy filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The found PSNTrophy record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().find_unique_or_raise(
            where={
                'id': 'begejjahig',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNTrophy records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNTrophy records returned
        skip
            Ignore the first N results
        where
            PSNTrophy filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNTrophy]
            The list of all PSNTrophy records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNTrophy records
        psntrophys = await PSNTrophy.prisma().find_many(take=10)

        # find the first 5 PSNTrophy records ordered by the trophyLevel field
        psntrophys = await PSNTrophy.prisma().find_many(
            take=5,
            order={
                'trophyLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNTrophy record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNTrophy filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNTrophy
            The first PSNTrophy record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNTrophy record ordered by the progress field
        psntrophy = await PSNTrophy.prisma().find_first(
            skip=1,
            order={
                'progress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
        include: Optional[types.PSNTrophyInclude] = None,
        order: Optional[Union[types.PSNTrophyOrderByInput, List[types.PSNTrophyOrderByInput]]] = None,
        distinct: Optional[List[types.PSNTrophyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNTrophy record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNTrophy filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNTrophy model
        order
            Order the returned PSNTrophy records by any field
        distinct
            Filter PSNTrophy records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNTrophy
            The first PSNTrophy record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNTrophy record ordered by the tier field
        psntrophy = await PSNTrophy.prisma().find_first_or_raise(
            skip=1,
            order={
                'tier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNTrophyUpdateInput,
        where: types.PSNTrophyWhereUniqueInput,
        include: Optional[types.PSNTrophyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNTrophy record.

        Parameters
        ----------
        data
            PSNTrophy record data specifying what to update
        where
            PSNTrophy filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The updated PSNTrophy record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().update(
            where={
                'id': 'jhfgdhdb',
            },
            data={
                # data to update the PSNTrophy record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNTrophyWhereUniqueInput,
        data: types.PSNTrophyUpsertInput,
        include: Optional[types.PSNTrophyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNTrophy filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNTrophy model

        Returns
        -------
        prisma.models.PSNTrophy
            The created or updated PSNTrophy record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psntrophy = await PSNTrophy.prisma().upsert(
            where={
                'id': 'egjhhiidc',
            },
            data={
                'create': {
                    'id': 'egjhhiidc',
                    'profileId': 'cicbaehfj',
                },
                'update': {
                    'profileId': 'cicbaehfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNTrophyUpdateManyMutationInput,
        where: types.PSNTrophyWhereInput,
    ) -> int:
        """Update multiple PSNTrophy records

        Parameters
        ----------
        data
            PSNTrophy data to update the selected PSNTrophy records to
        where
            Filter to select the PSNTrophy records to update

        Returns
        -------
        int
            The total number of PSNTrophy records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNTrophy records
        total = await PSNTrophy.prisma().update_many(
            data={
                'platinumCount': 1165359753
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNTrophy records present in the database

        Parameters
        ----------
        select
            Select the PSNTrophy fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNTrophy filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNTrophyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNTrophy.prisma().count()

        # results: prisma.types.PSNTrophyCountAggregateOutput
        results = await PSNTrophy.prisma().count(
            select={
                '_all': True,
                'goldCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNTrophyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> types.PSNTrophyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNTrophyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNTrophyWhereInput] = None,
        cursor: Optional[types.PSNTrophyWhereUniqueInput] = None,
    ) -> Union[int, types.PSNTrophyCountAggregateOutput]:
        """Count the number of PSNTrophy records present in the database

        Parameters
        ----------
        select
            Select the PSNTrophy fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNTrophy filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNTrophyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNTrophy.prisma().count()

        # results: prisma.types.PSNTrophyCountAggregateOutput
        results = await PSNTrophy.prisma().count(
            select={
                '_all': True,
                'silverCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNTrophyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNTrophyWhereInput] = None
    ) -> int:
        """Delete multiple PSNTrophy records.

        Parameters
        ----------
        where
            Optional PSNTrophy filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNTrophy records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNTrophy records
        total = await PSNTrophy.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNTrophyScalarFieldKeysT'],
        *,
        where: Optional['types.PSNTrophyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNTrophyAvgAggregateInput'] = None,
        sum: Optional['types.PSNTrophySumAggregateInput'] = None,
        min: Optional['types.PSNTrophyMinAggregateInput'] = None,
        max: Optional['types.PSNTrophyMaxAggregateInput'] = None,
        having: Optional['types.PSNTrophyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNTrophyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNTrophyScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNTrophyScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNTrophyGroupByOutput']:
        """Group PSNTrophy records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNTrophy fields to group records by
        where
            PSNTrophy filter to select records
        take
            Limit the maximum number of PSNTrophy records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNTrophyGroupByOutput]
            A list of dictionaries representing the PSNTrophy record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNTrophy records by bronzeCount values
        # and count how many records are in each group
        results = await PSNTrophy.prisma().group_by(
            ['bronzeCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNGameActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNGame]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNGame.prisma().query_raw(
            'SELECT * FROM PSNGame WHERE id = $1',
            'deeedbceg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNGame
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNGame.prisma().query_first(
            'SELECT * FROM PSNGame WHERE profileId = $1',
            'geifgbdch',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNGameCreateInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNGame record.

        Parameters
        ----------
        data
            PSNGame record data
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The created PSNGame record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNGame record from just the required fields
        psngame = await PSNGame.prisma().create(
            data={
                # data to create a PSNGame record
                'profileId': 'babbigjdhc',
                'name': 'jdejidcdh',
                'titleId': 'ehgfaadhi',
                'platform': 'fidadbejj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNGameCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNGame records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNGame record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNGame.prisma().create_many(
            data=[
                {
                    # data to create a PSNGame record
                    'profileId': 'hdbadecia',
                    'name': 'dggdajicf',
                    'titleId': 'bdffidghhe',
                    'platform': 'bicibicbid',
                },
                {
                    # data to create a PSNGame record
                    'profileId': 'bgdjcahcfc',
                    'name': 'bbggedggaf',
                    'titleId': 'cbcjaaajeg',
                    'platform': 'bfgeedcefb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNGame record.

        Parameters
        ----------
        where
            PSNGame filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The deleted PSNGame record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().delete(
            where={
                'id': 'bcacggdbae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNGame record.

        Parameters
        ----------
        where
            PSNGame filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The found PSNGame record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().find_unique(
            where={
                'id': 'bdbecdcdbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNGame record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNGame filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The found PSNGame record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().find_unique_or_raise(
            where={
                'id': 'ieeeibdec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNGame records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNGame records returned
        skip
            Ignore the first N results
        where
            PSNGame filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNGame]
            The list of all PSNGame records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNGame records
        psngames = await PSNGame.prisma().find_many(take=10)

        # find the first 5 PSNGame records ordered by the name field
        psngames = await PSNGame.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNGame record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGame filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGame
            The first PSNGame record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGame record ordered by the titleId field
        psngame = await PSNGame.prisma().find_first(
            skip=1,
            order={
                'titleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
        include: Optional[types.PSNGameInclude] = None,
        order: Optional[Union[types.PSNGameOrderByInput, List[types.PSNGameOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNGame record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGame filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGame model
        order
            Order the returned PSNGame records by any field
        distinct
            Filter PSNGame records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGame
            The first PSNGame record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGame record ordered by the platform field
        psngame = await PSNGame.prisma().find_first_or_raise(
            skip=1,
            order={
                'platform': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNGameUpdateInput,
        where: types.PSNGameWhereUniqueInput,
        include: Optional[types.PSNGameInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNGame record.

        Parameters
        ----------
        data
            PSNGame record data specifying what to update
        where
            PSNGame filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The updated PSNGame record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().update(
            where={
                'id': 'bdebehabbb',
            },
            data={
                # data to update the PSNGame record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNGameWhereUniqueInput,
        data: types.PSNGameUpsertInput,
        include: Optional[types.PSNGameInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNGame filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNGame model

        Returns
        -------
        prisma.models.PSNGame
            The created or updated PSNGame record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngame = await PSNGame.prisma().upsert(
            where={
                'id': 'edbfbjegi',
            },
            data={
                'create': {
                    'id': 'edbfbjegi',
                    'profileId': 'bgdjcahcfc',
                    'name': 'bbggedggaf',
                    'titleId': 'cbcjaaajeg',
                    'platform': 'bfgeedcefb',
                },
                'update': {
                    'profileId': 'bgdjcahcfc',
                    'name': 'bbggedggaf',
                    'titleId': 'cbcjaaajeg',
                    'platform': 'bfgeedcefb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNGameUpdateManyMutationInput,
        where: types.PSNGameWhereInput,
    ) -> int:
        """Update multiple PSNGame records

        Parameters
        ----------
        data
            PSNGame data to update the selected PSNGame records to
        where
            Filter to select the PSNGame records to update

        Returns
        -------
        int
            The total number of PSNGame records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNGame records
        total = await PSNGame.prisma().update_many(
            data={
                'imageUrl': 'ceaaeagcj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNGame records present in the database

        Parameters
        ----------
        select
            Select the PSNGame fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGame filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGame.prisma().count()

        # results: prisma.types.PSNGameCountAggregateOutput
        results = await PSNGame.prisma().count(
            select={
                '_all': True,
                'playCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNGameCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> types.PSNGameCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNGameCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameWhereInput] = None,
        cursor: Optional[types.PSNGameWhereUniqueInput] = None,
    ) -> Union[int, types.PSNGameCountAggregateOutput]:
        """Count the number of PSNGame records present in the database

        Parameters
        ----------
        select
            Select the PSNGame fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGame filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGame.prisma().count()

        # results: prisma.types.PSNGameCountAggregateOutput
        results = await PSNGame.prisma().count(
            select={
                '_all': True,
                'firstPlayed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNGameCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNGameWhereInput] = None
    ) -> int:
        """Delete multiple PSNGame records.

        Parameters
        ----------
        where
            Optional PSNGame filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNGame records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNGame records
        total = await PSNGame.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNGameScalarFieldKeysT'],
        *,
        where: Optional['types.PSNGameWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNGameAvgAggregateInput'] = None,
        sum: Optional['types.PSNGameSumAggregateInput'] = None,
        min: Optional['types.PSNGameMinAggregateInput'] = None,
        max: Optional['types.PSNGameMaxAggregateInput'] = None,
        having: Optional['types.PSNGameScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNGameCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNGameScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNGameScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNGameGroupByOutput']:
        """Group PSNGame records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNGame fields to group records by
        where
            PSNGame filter to select records
        take
            Limit the maximum number of PSNGame records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNGameGroupByOutput]
            A list of dictionaries representing the PSNGame record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNGame records by lastPlayed values
        # and count how many records are in each group
        results = await PSNGame.prisma().group_by(
            ['lastPlayed'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNSyncLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNSyncLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNSyncLog.prisma().query_raw(
            'SELECT * FROM PSNSyncLog WHERE id = $1',
            'bjacfgegic',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNSyncLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNSyncLog.prisma().query_first(
            'SELECT * FROM PSNSyncLog WHERE profileId = $1',
            'bfjdjdhaid',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNSyncLogCreateInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNSyncLog record.

        Parameters
        ----------
        data
            PSNSyncLog record data
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The created PSNSyncLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNSyncLog record from just the required fields
        psnsynclog = await PSNSyncLog.prisma().create(
            data={
                # data to create a PSNSyncLog record
                'profileId': 'bahggdbaaa',
                'syncType': enums.PSNSyncType.PROFILE,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNSyncLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNSyncLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNSyncLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNSyncLog.prisma().create_many(
            data=[
                {
                    # data to create a PSNSyncLog record
                    'profileId': 'cbccbeajhh',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
                {
                    # data to create a PSNSyncLog record
                    'profileId': 'hghiiedba',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNSyncLog record.

        Parameters
        ----------
        where
            PSNSyncLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The deleted PSNSyncLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().delete(
            where={
                'id': 'ciabbfgah',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNSyncLog record.

        Parameters
        ----------
        where
            PSNSyncLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The found PSNSyncLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().find_unique(
            where={
                'id': 'bcgcaaibjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNSyncLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNSyncLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The found PSNSyncLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().find_unique_or_raise(
            where={
                'id': 'bbcghdagaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNSyncLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNSyncLog records returned
        skip
            Ignore the first N results
        where
            PSNSyncLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNSyncLog]
            The list of all PSNSyncLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNSyncLog records
        psnsynclogs = await PSNSyncLog.prisma().find_many(take=10)

        # find the first 5 PSNSyncLog records ordered by the syncType field
        psnsynclogs = await PSNSyncLog.prisma().find_many(
            take=5,
            order={
                'syncType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNSyncLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNSyncLog
            The first PSNSyncLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNSyncLog record ordered by the status field
        psnsynclog = await PSNSyncLog.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
        include: Optional[types.PSNSyncLogInclude] = None,
        order: Optional[Union[types.PSNSyncLogOrderByInput, List[types.PSNSyncLogOrderByInput]]] = None,
        distinct: Optional[List[types.PSNSyncLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNSyncLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model
        order
            Order the returned PSNSyncLog records by any field
        distinct
            Filter PSNSyncLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNSyncLog
            The first PSNSyncLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNSyncLog record ordered by the startedAt field
        psnsynclog = await PSNSyncLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'startedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNSyncLogUpdateInput,
        where: types.PSNSyncLogWhereUniqueInput,
        include: Optional[types.PSNSyncLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNSyncLog record.

        Parameters
        ----------
        data
            PSNSyncLog record data specifying what to update
        where
            PSNSyncLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The updated PSNSyncLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().update(
            where={
                'id': 'bjiafeiaac',
            },
            data={
                # data to update the PSNSyncLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNSyncLogWhereUniqueInput,
        data: types.PSNSyncLogUpsertInput,
        include: Optional[types.PSNSyncLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNSyncLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNSyncLog model

        Returns
        -------
        prisma.models.PSNSyncLog
            The created or updated PSNSyncLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psnsynclog = await PSNSyncLog.prisma().upsert(
            where={
                'id': 'eaideegch',
            },
            data={
                'create': {
                    'id': 'eaideegch',
                    'profileId': 'hghiiedba',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
                'update': {
                    'profileId': 'hghiiedba',
                    'syncType': enums.PSNSyncType.PROFILE,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNSyncLogUpdateManyMutationInput,
        where: types.PSNSyncLogWhereInput,
    ) -> int:
        """Update multiple PSNSyncLog records

        Parameters
        ----------
        data
            PSNSyncLog data to update the selected PSNSyncLog records to
        where
            Filter to select the PSNSyncLog records to update

        Returns
        -------
        int
            The total number of PSNSyncLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNSyncLog records
        total = await PSNSyncLog.prisma().update_many(
            data={
                'completedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNSyncLog records present in the database

        Parameters
        ----------
        select
            Select the PSNSyncLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNSyncLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNSyncLog.prisma().count()

        # results: prisma.types.PSNSyncLogCountAggregateOutput
        results = await PSNSyncLog.prisma().count(
            select={
                '_all': True,
                'errorMessage': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNSyncLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> types.PSNSyncLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNSyncLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNSyncLogWhereInput] = None,
        cursor: Optional[types.PSNSyncLogWhereUniqueInput] = None,
    ) -> Union[int, types.PSNSyncLogCountAggregateOutput]:
        """Count the number of PSNSyncLog records present in the database

        Parameters
        ----------
        select
            Select the PSNSyncLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNSyncLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNSyncLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNSyncLog.prisma().count()

        # results: prisma.types.PSNSyncLogCountAggregateOutput
        results = await PSNSyncLog.prisma().count(
            select={
                '_all': True,
                'recordsUpdated': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNSyncLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNSyncLogWhereInput] = None
    ) -> int:
        """Delete multiple PSNSyncLog records.

        Parameters
        ----------
        where
            Optional PSNSyncLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNSyncLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNSyncLog records
        total = await PSNSyncLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNSyncLogScalarFieldKeysT'],
        *,
        where: Optional['types.PSNSyncLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNSyncLogAvgAggregateInput'] = None,
        sum: Optional['types.PSNSyncLogSumAggregateInput'] = None,
        min: Optional['types.PSNSyncLogMinAggregateInput'] = None,
        max: Optional['types.PSNSyncLogMaxAggregateInput'] = None,
        having: Optional['types.PSNSyncLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNSyncLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNSyncLogScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNSyncLogScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNSyncLogGroupByOutput']:
        """Group PSNSyncLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNSyncLog fields to group records by
        where
            PSNSyncLog filter to select records
        take
            Limit the maximum number of PSNSyncLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNSyncLogGroupByOutput]
            A list of dictionaries representing the PSNSyncLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNSyncLog records by id values
        # and count how many records are in each group
        results = await PSNSyncLog.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PSNGameTrophiesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PSNGameTrophies]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PSNGameTrophies.prisma().query_raw(
            'SELECT * FROM PSNGameTrophies WHERE id = $1',
            'cbacbbidie',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PSNGameTrophies.prisma().query_first(
            'SELECT * FROM PSNGameTrophies WHERE profileId = $1',
            'gdjcggdd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PSNGameTrophiesCreateInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> _PrismaModelT:
        """Create a new PSNGameTrophies record.

        Parameters
        ----------
        data
            PSNGameTrophies record data
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The created PSNGameTrophies record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PSNGameTrophies record from just the required fields
        psngametrophies = await PSNGameTrophies.prisma().create(
            data={
                # data to create a PSNGameTrophies record
                'profileId': 'ihdjfdcgc',
                'gameId': 'hhdichjj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PSNGameTrophiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PSNGameTrophies records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PSNGameTrophies record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PSNGameTrophies.prisma().create_many(
            data=[
                {
                    # data to create a PSNGameTrophies record
                    'profileId': 'chcegcgca',
                    'gameId': 'bbijdjfcdh',
                },
                {
                    # data to create a PSNGameTrophies record
                    'profileId': 'ghfhhaic',
                    'gameId': 'caahhacbih',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PSNGameTrophies record.

        Parameters
        ----------
        where
            PSNGameTrophies filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The deleted PSNGameTrophies record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().delete(
            where={
                'id': 'ffhgccfdg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PSNGameTrophies record.

        Parameters
        ----------
        where
            PSNGameTrophies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The found PSNGameTrophies record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().find_unique(
            where={
                'id': 'bcjghfdicf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PSNGameTrophies record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PSNGameTrophies filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The found PSNGameTrophies record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().find_unique_or_raise(
            where={
                'id': 'biiacggedi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PSNGameTrophies records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PSNGameTrophies records returned
        skip
            Ignore the first N results
        where
            PSNGameTrophies filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PSNGameTrophies]
            The list of all PSNGameTrophies records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PSNGameTrophies records
        psngametrophies = await PSNGameTrophies.prisma().find_many(take=10)

        # find the first 5 PSNGameTrophies records ordered by the gameId field
        psngametrophies = await PSNGameTrophies.prisma().find_many(
            take=5,
            order={
                'gameId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PSNGameTrophies record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first PSNGameTrophies record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGameTrophies record ordered by the trophiesEarned field
        psngametrophies = await PSNGameTrophies.prisma().find_first(
            skip=1,
            order={
                'trophiesEarned': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
        include: Optional[types.PSNGameTrophiesInclude] = None,
        order: Optional[Union[types.PSNGameTrophiesOrderByInput, List[types.PSNGameTrophiesOrderByInput]]] = None,
        distinct: Optional[List[types.PSNGameTrophiesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PSNGameTrophies record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model
        order
            Order the returned PSNGameTrophies records by any field
        distinct
            Filter PSNGameTrophies records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PSNGameTrophies
            The first PSNGameTrophies record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PSNGameTrophies record ordered by the trophiesTotal field
        psngametrophies = await PSNGameTrophies.prisma().find_first_or_raise(
            skip=1,
            order={
                'trophiesTotal': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PSNGameTrophiesUpdateInput,
        where: types.PSNGameTrophiesWhereUniqueInput,
        include: Optional[types.PSNGameTrophiesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PSNGameTrophies record.

        Parameters
        ----------
        data
            PSNGameTrophies record data specifying what to update
        where
            PSNGameTrophies filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The updated PSNGameTrophies record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().update(
            where={
                'id': 'bbfhfedffj',
            },
            data={
                # data to update the PSNGameTrophies record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PSNGameTrophiesWhereUniqueInput,
        data: types.PSNGameTrophiesUpsertInput,
        include: Optional[types.PSNGameTrophiesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PSNGameTrophies filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PSNGameTrophies model

        Returns
        -------
        prisma.models.PSNGameTrophies
            The created or updated PSNGameTrophies record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psngametrophies = await PSNGameTrophies.prisma().upsert(
            where={
                'id': 'bihaddedii',
            },
            data={
                'create': {
                    'id': 'bihaddedii',
                    'profileId': 'ghfhhaic',
                    'gameId': 'caahhacbih',
                },
                'update': {
                    'profileId': 'ghfhhaic',
                    'gameId': 'caahhacbih',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PSNGameTrophiesUpdateManyMutationInput,
        where: types.PSNGameTrophiesWhereInput,
    ) -> int:
        """Update multiple PSNGameTrophies records

        Parameters
        ----------
        data
            PSNGameTrophies data to update the selected PSNGameTrophies records to
        where
            Filter to select the PSNGameTrophies records to update

        Returns
        -------
        int
            The total number of PSNGameTrophies records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PSNGameTrophies records
        total = await PSNGameTrophies.prisma().update_many(
            data={
                'progress': 697313757
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PSNGameTrophies records present in the database

        Parameters
        ----------
        select
            Select the PSNGameTrophies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameTrophiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGameTrophies.prisma().count()

        # results: prisma.types.PSNGameTrophiesCountAggregateOutput
        results = await PSNGameTrophies.prisma().count(
            select={
                '_all': True,
                'platinumEarned': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PSNGameTrophiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> types.PSNGameTrophiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PSNGameTrophiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PSNGameTrophiesWhereInput] = None,
        cursor: Optional[types.PSNGameTrophiesWhereUniqueInput] = None,
    ) -> Union[int, types.PSNGameTrophiesCountAggregateOutput]:
        """Count the number of PSNGameTrophies records present in the database

        Parameters
        ----------
        select
            Select the PSNGameTrophies fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PSNGameTrophies filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PSNGameTrophiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PSNGameTrophies.prisma().count()

        # results: prisma.types.PSNGameTrophiesCountAggregateOutput
        results = await PSNGameTrophies.prisma().count(
            select={
                '_all': True,
                'goldEarned': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PSNGameTrophiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PSNGameTrophiesWhereInput] = None
    ) -> int:
        """Delete multiple PSNGameTrophies records.

        Parameters
        ----------
        where
            Optional PSNGameTrophies filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PSNGameTrophies records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PSNGameTrophies records
        total = await PSNGameTrophies.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PSNGameTrophiesScalarFieldKeysT'],
        *,
        where: Optional['types.PSNGameTrophiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PSNGameTrophiesAvgAggregateInput'] = None,
        sum: Optional['types.PSNGameTrophiesSumAggregateInput'] = None,
        min: Optional['types.PSNGameTrophiesMinAggregateInput'] = None,
        max: Optional['types.PSNGameTrophiesMaxAggregateInput'] = None,
        having: Optional['types.PSNGameTrophiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PSNGameTrophiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PSNGameTrophiesScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PSNGameTrophiesScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PSNGameTrophiesGroupByOutput']:
        """Group PSNGameTrophies records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PSNGameTrophies fields to group records by
        where
            PSNGameTrophies filter to select records
        take
            Limit the maximum number of PSNGameTrophies records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PSNGameTrophiesGroupByOutput]
            A list of dictionaries representing the PSNGameTrophies record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PSNGameTrophies records by silverEarned values
        # and count how many records are in each group
        results = await PSNGameTrophies.prisma().group_by(
            ['silverEarned'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Team]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Team.prisma().query_raw(
            'SELECT * FROM Team WHERE id = $1',
            'eihghgcec',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Team
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Team.prisma().query_first(
            'SELECT * FROM Team WHERE eaClubId = $1',
            'cifgbjcdf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamCreateInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Create a new Team record.

        Parameters
        ----------
        data
            Team record data
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created Team record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Team record from just the required fields
        team = await Team.prisma().create(
            data={
                # data to create a Team record
                'eaClubId': 'bfadcacfjc',
                'eaClubName': 'cfacfajgj',
                'fullTeamName': 'igihcgjec',
                'teamAbbreviation': 'bdbgihgbfj',
                'leagueId': 'bbhbdibagi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Team records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Team record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Team.prisma().create_many(
            data=[
                {
                    # data to create a Team record
                    'eaClubId': 'ddehdjdej',
                    'eaClubName': 'dbhijijcc',
                    'fullTeamName': 'ijidgiggh',
                    'teamAbbreviation': 'bgcfhhgbie',
                    'leagueId': 'bgjgjdiaab',
                },
                {
                    # data to create a Team record
                    'eaClubId': 'dhaecfcag',
                    'eaClubName': 'chighjebf',
                    'fullTeamName': 'bgahdfedea',
                    'teamAbbreviation': 'fiifdahgf',
                    'leagueId': 'cajhagiiac',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Team record.

        Parameters
        ----------
        where
            Team filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The deleted Team record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().delete(
            where={
                'id': 'cagddgdajb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Team record.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique(
            where={
                'id': 'iahaajihc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Team record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique_or_raise(
            where={
                'id': 'bhfcacjcfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Team records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N results
        where
            Team filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Team]
            The list of all Team records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Team records
        teams = await Team.prisma().find_many(take=10)

        # find the first 5 Team records ordered by the eaClubName field
        teams = await Team.prisma().find_many(
            take=5,
            order={
                'eaClubName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Team record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the fullTeamName field
        team = await Team.prisma().find_first(
            skip=1,
            order={
                'fullTeamName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Team record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the teamAbbreviation field
        team = await Team.prisma().find_first_or_raise(
            skip=1,
            order={
                'teamAbbreviation': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamUpdateInput,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Team record.

        Parameters
        ----------
        data
            Team record data specifying what to update
        where
            Team filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The updated Team record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        team = await Team.prisma().update(
            where={
                'id': 'bahfjdigdi',
            },
            data={
                # data to update the Team record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamWhereUniqueInput,
        data: types.TeamUpsertInput,
        include: Optional[types.TeamInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Team filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created or updated Team record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().upsert(
            where={
                'id': 'bidcdghhch',
            },
            data={
                'create': {
                    'id': 'bidcdghhch',
                    'eaClubId': 'dhaecfcag',
                    'eaClubName': 'chighjebf',
                    'fullTeamName': 'bgahdfedea',
                    'teamAbbreviation': 'fiifdahgf',
                    'leagueId': 'cajhagiiac',
                },
                'update': {
                    'eaClubId': 'dhaecfcag',
                    'eaClubName': 'chighjebf',
                    'fullTeamName': 'bgahdfedea',
                    'teamAbbreviation': 'fiifdahgf',
                    'leagueId': 'cajhagiiac',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamUpdateManyMutationInput,
        where: types.TeamWhereInput,
    ) -> int:
        """Update multiple Team records

        Parameters
        ----------
        data
            Team data to update the selected Team records to
        where
            Filter to select the Team records to update

        Returns
        -------
        int
            The total number of Team records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Team records
        total = await Team.prisma().update_many(
            data={
                'logoPath': 'bbcghdjidg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'leagueId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> types.TeamCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> Union[int, types.TeamCountAggregateOutput]:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'divisionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamWhereInput] = None
    ) -> int:
        """Delete multiple Team records.

        Parameters
        ----------
        where
            Optional Team filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Team records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Team records
        total = await Team.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamScalarFieldKeysT'],
        *,
        where: Optional['types.TeamWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamAvgAggregateInput'] = None,
        sum: Optional['types.TeamSumAggregateInput'] = None,
        min: Optional['types.TeamMinAggregateInput'] = None,
        max: Optional['types.TeamMaxAggregateInput'] = None,
        having: Optional['types.TeamScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamGroupByOutput']:
        """Group Team records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Team fields to group records by
        where
            Team filter to select records
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamGroupByOutput]
            A list of dictionaries representing the Team record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Team records by primaryColor values
        # and count how many records are in each group
        results = await Team.prisma().group_by(
            ['primaryColor'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamSeasonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamSeason]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TeamSeason.prisma().query_raw(
            'SELECT * FROM TeamSeason WHERE id = $1',
            'ighdeieif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamSeason
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TeamSeason.prisma().query_first(
            'SELECT * FROM TeamSeason WHERE teamId = $1',
            'bfhaacdfbe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamSeasonCreateInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamSeason record.

        Parameters
        ----------
        data
            TeamSeason record data
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The created TeamSeason record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamSeason record from just the required fields
        teamseason = await TeamSeason.prisma().create(
            data={
                # data to create a TeamSeason record
                'teamId': 'ifijjjedf',
                'leagueSeasonId': 'bgbbgbeafg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamSeasonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamSeason records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamSeason record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TeamSeason.prisma().create_many(
            data=[
                {
                    # data to create a TeamSeason record
                    'teamId': 'ibhaffgbh',
                    'leagueSeasonId': 'bhjddiific',
                },
                {
                    # data to create a TeamSeason record
                    'teamId': 'ghbhefbch',
                    'leagueSeasonId': 'ghfgdjici',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamSeason record.

        Parameters
        ----------
        where
            TeamSeason filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The deleted TeamSeason record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().delete(
            where={
                'id': 'ejjijjagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamSeason record.

        Parameters
        ----------
        where
            TeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The found TeamSeason record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().find_unique(
            where={
                'id': 'caagjgieji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamSeason record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamSeason filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The found TeamSeason record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().find_unique_or_raise(
            where={
                'id': 'beadffbheh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamSeason records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamSeason records returned
        skip
            Ignore the first N results
        where
            TeamSeason filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamSeason]
            The list of all TeamSeason records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamSeason records
        teamseasons = await TeamSeason.prisma().find_many(take=10)

        # find the first 5 TeamSeason records ordered by the leagueSeasonId field
        teamseasons = await TeamSeason.prisma().find_many(
            take=5,
            order={
                'leagueSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamSeason record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamSeason
            The first TeamSeason record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamSeason record ordered by the forwardCount field
        teamseason = await TeamSeason.prisma().find_first(
            skip=1,
            order={
                'forwardCount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
        include: Optional[types.TeamSeasonInclude] = None,
        order: Optional[Union[types.TeamSeasonOrderByInput, List[types.TeamSeasonOrderByInput]]] = None,
        distinct: Optional[List[types.TeamSeasonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamSeason record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamSeason filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamSeason model
        order
            Order the returned TeamSeason records by any field
        distinct
            Filter TeamSeason records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamSeason
            The first TeamSeason record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamSeason record ordered by the defenseCount field
        teamseason = await TeamSeason.prisma().find_first_or_raise(
            skip=1,
            order={
                'defenseCount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamSeasonUpdateInput,
        where: types.TeamSeasonWhereUniqueInput,
        include: Optional[types.TeamSeasonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamSeason record.

        Parameters
        ----------
        data
            TeamSeason record data specifying what to update
        where
            TeamSeason filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The updated TeamSeason record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().update(
            where={
                'id': 'jjbaajgge',
            },
            data={
                # data to update the TeamSeason record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamSeasonWhereUniqueInput,
        data: types.TeamSeasonUpsertInput,
        include: Optional[types.TeamSeasonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamSeason filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamSeason model

        Returns
        -------
        prisma.models.TeamSeason
            The created or updated TeamSeason record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamseason = await TeamSeason.prisma().upsert(
            where={
                'id': 'bcccggfgfh',
            },
            data={
                'create': {
                    'id': 'bcccggfgfh',
                    'teamId': 'ghbhefbch',
                    'leagueSeasonId': 'ghfgdjici',
                },
                'update': {
                    'teamId': 'ghbhefbch',
                    'leagueSeasonId': 'ghfgdjici',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamSeasonUpdateManyMutationInput,
        where: types.TeamSeasonWhereInput,
    ) -> int:
        """Update multiple TeamSeason records

        Parameters
        ----------
        data
            TeamSeason data to update the selected TeamSeason records to
        where
            Filter to select the TeamSeason records to update

        Returns
        -------
        int
            The total number of TeamSeason records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamSeason records
        total = await TeamSeason.prisma().update_many(
            data={
                'goalieCount': 211803646
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamSeason records present in the database

        Parameters
        ----------
        select
            Select the TeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamSeason.prisma().count()

        # results: prisma.types.TeamSeasonCountAggregateOutput
        results = await TeamSeason.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamSeasonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> types.TeamSeasonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamSeasonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamSeasonWhereInput] = None,
        cursor: Optional[types.TeamSeasonWhereUniqueInput] = None,
    ) -> Union[int, types.TeamSeasonCountAggregateOutput]:
        """Count the number of TeamSeason records present in the database

        Parameters
        ----------
        select
            Select the TeamSeason fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamSeason filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamSeasonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamSeason.prisma().count()

        # results: prisma.types.TeamSeasonCountAggregateOutput
        results = await TeamSeason.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamSeasonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamSeasonWhereInput] = None
    ) -> int:
        """Delete multiple TeamSeason records.

        Parameters
        ----------
        where
            Optional TeamSeason filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamSeason records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamSeason records
        total = await TeamSeason.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamSeasonScalarFieldKeysT'],
        *,
        where: Optional['types.TeamSeasonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamSeasonAvgAggregateInput'] = None,
        sum: Optional['types.TeamSeasonSumAggregateInput'] = None,
        min: Optional['types.TeamSeasonMinAggregateInput'] = None,
        max: Optional['types.TeamSeasonMaxAggregateInput'] = None,
        having: Optional['types.TeamSeasonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamSeasonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamSeasonScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamSeasonScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamSeasonGroupByOutput']:
        """Group TeamSeason records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamSeason fields to group records by
        where
            TeamSeason filter to select records
        take
            Limit the maximum number of TeamSeason records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamSeasonGroupByOutput]
            A list of dictionaries representing the TeamSeason record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamSeason records by id values
        # and count how many records are in each group
        results = await TeamSeason.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamManagerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamManager]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TeamManager.prisma().query_raw(
            'SELECT * FROM TeamManager WHERE id = $1',
            'bbhhajifjb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamManager
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TeamManager.prisma().query_first(
            'SELECT * FROM TeamManager WHERE userId = $1',
            'fjjagadjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamManagerCreateInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamManager record.

        Parameters
        ----------
        data
            TeamManager record data
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The created TeamManager record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamManager record from just the required fields
        teammanager = await TeamManager.prisma().create(
            data={
                # data to create a TeamManager record
                'userId': 'bgbccchhab',
                'teamSeasonId': 'bebaiejiac',
                'role': enums.TeamManagementRole.OWNER,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamManagerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamManager records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamManager record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TeamManager.prisma().create_many(
            data=[
                {
                    # data to create a TeamManager record
                    'userId': 'bcjahjcafj',
                    'teamSeasonId': 'cbbjgfeaea',
                    'role': enums.TeamManagementRole.OWNER,
                },
                {
                    # data to create a TeamManager record
                    'userId': 'daiaceaej',
                    'teamSeasonId': 'jbcceadec',
                    'role': enums.TeamManagementRole.OWNER,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamManager record.

        Parameters
        ----------
        where
            TeamManager filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The deleted TeamManager record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().delete(
            where={
                'id': 'bfgjbbhfch',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamManager record.

        Parameters
        ----------
        where
            TeamManager filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The found TeamManager record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().find_unique(
            where={
                'id': 'cbecehccga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamManager record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamManager filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The found TeamManager record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().find_unique_or_raise(
            where={
                'id': 'jjjbfhadh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamManager records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamManager records returned
        skip
            Ignore the first N results
        where
            TeamManager filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamManager]
            The list of all TeamManager records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamManager records
        teammanagers = await TeamManager.prisma().find_many(take=10)

        # find the first 5 TeamManager records ordered by the teamSeasonId field
        teammanagers = await TeamManager.prisma().find_many(
            take=5,
            order={
                'teamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamManager record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamManager filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamManager
            The first TeamManager record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamManager record ordered by the role field
        teammanager = await TeamManager.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
        include: Optional[types.TeamManagerInclude] = None,
        order: Optional[Union[types.TeamManagerOrderByInput, List[types.TeamManagerOrderByInput]]] = None,
        distinct: Optional[List[types.TeamManagerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamManager record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamManager filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamManager model
        order
            Order the returned TeamManager records by any field
        distinct
            Filter TeamManager records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamManager
            The first TeamManager record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamManager record ordered by the createdAt field
        teammanager = await TeamManager.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamManagerUpdateInput,
        where: types.TeamManagerWhereUniqueInput,
        include: Optional[types.TeamManagerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamManager record.

        Parameters
        ----------
        data
            TeamManager record data specifying what to update
        where
            TeamManager filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The updated TeamManager record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().update(
            where={
                'id': 'caaeigjhda',
            },
            data={
                # data to update the TeamManager record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamManagerWhereUniqueInput,
        data: types.TeamManagerUpsertInput,
        include: Optional[types.TeamManagerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamManager filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamManager model

        Returns
        -------
        prisma.models.TeamManager
            The created or updated TeamManager record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teammanager = await TeamManager.prisma().upsert(
            where={
                'id': 'bdhjejfjcd',
            },
            data={
                'create': {
                    'id': 'bdhjejfjcd',
                    'userId': 'daiaceaej',
                    'teamSeasonId': 'jbcceadec',
                    'role': enums.TeamManagementRole.OWNER,
                },
                'update': {
                    'userId': 'daiaceaej',
                    'teamSeasonId': 'jbcceadec',
                    'role': enums.TeamManagementRole.OWNER,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamManagerUpdateManyMutationInput,
        where: types.TeamManagerWhereInput,
    ) -> int:
        """Update multiple TeamManager records

        Parameters
        ----------
        data
            TeamManager data to update the selected TeamManager records to
        where
            Filter to select the TeamManager records to update

        Returns
        -------
        int
            The total number of TeamManager records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamManager records
        total = await TeamManager.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamManager records present in the database

        Parameters
        ----------
        select
            Select the TeamManager fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamManager filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamManagerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamManager.prisma().count()

        # results: prisma.types.TeamManagerCountAggregateOutput
        results = await TeamManager.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamManagerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> types.TeamManagerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamManagerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamManagerWhereInput] = None,
        cursor: Optional[types.TeamManagerWhereUniqueInput] = None,
    ) -> Union[int, types.TeamManagerCountAggregateOutput]:
        """Count the number of TeamManager records present in the database

        Parameters
        ----------
        select
            Select the TeamManager fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamManager filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamManagerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TeamManager.prisma().count()

        # results: prisma.types.TeamManagerCountAggregateOutput
        results = await TeamManager.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamManagerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamManagerWhereInput] = None
    ) -> int:
        """Delete multiple TeamManager records.

        Parameters
        ----------
        where
            Optional TeamManager filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamManager records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamManager records
        total = await TeamManager.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamManagerScalarFieldKeysT'],
        *,
        where: Optional['types.TeamManagerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamManagerAvgAggregateInput'] = None,
        sum: Optional['types.TeamManagerSumAggregateInput'] = None,
        min: Optional['types.TeamManagerMinAggregateInput'] = None,
        max: Optional['types.TeamManagerMaxAggregateInput'] = None,
        having: Optional['types.TeamManagerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamManagerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamManagerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TeamManagerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamManagerGroupByOutput']:
        """Group TeamManager records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamManager fields to group records by
        where
            TeamManager filter to select records
        take
            Limit the maximum number of TeamManager records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamManagerGroupByOutput]
            A list of dictionaries representing the TeamManager record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamManager records by teamSeasonId values
        # and count how many records are in each group
        results = await TeamManager.prisma().group_by(
            ['teamSeasonId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BidActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Bid]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Bid.prisma().query_raw(
            'SELECT * FROM Bid WHERE id = $1',
            'bcggigjece',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Bid
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Bid.prisma().query_first(
            'SELECT * FROM Bid WHERE contractId = $1',
            'ebbgedgij',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BidCreateInput,
        include: Optional[types.BidInclude] = None
    ) -> _PrismaModelT:
        """Create a new Bid record.

        Parameters
        ----------
        data
            Bid record data
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The created Bid record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Bid record from just the required fields
        bid = await Bid.prisma().create(
            data={
                # data to create a Bid record
                'contractId': 'fgbiijjgg',
                'teamSeasonId': 'bebggjhjdf',
                'amount': 1168743388,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BidCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Bid records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Bid record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Bid.prisma().create_many(
            data=[
                {
                    # data to create a Bid record
                    'contractId': 'bafegedecj',
                    'teamSeasonId': 'bbjhjfgacg',
                    'amount': 282126955,
                },
                {
                    # data to create a Bid record
                    'contractId': 'bcedhibfhg',
                    'teamSeasonId': 'bebdjbdbif',
                    'amount': 1830779270,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Bid record.

        Parameters
        ----------
        where
            Bid filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The deleted Bid record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().delete(
            where={
                'id': 'cigdhgfbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Bid record.

        Parameters
        ----------
        where
            Bid filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The found Bid record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().find_unique(
            where={
                'id': 'caahhdaiae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Bid record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Bid filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The found Bid record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().find_unique_or_raise(
            where={
                'id': 'bbagdeeigb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Bid records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Bid records returned
        skip
            Ignore the first N results
        where
            Bid filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Bid]
            The list of all Bid records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Bid records
        bids = await Bid.prisma().find_many(take=10)

        # find the first 5 Bid records ordered by the teamSeasonId field
        bids = await Bid.prisma().find_many(
            take=5,
            order={
                'teamSeasonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Bid record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Bid filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Bid
            The first Bid record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Bid record ordered by the amount field
        bid = await Bid.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
        include: Optional[types.BidInclude] = None,
        order: Optional[Union[types.BidOrderByInput, List[types.BidOrderByInput]]] = None,
        distinct: Optional[List[types.BidScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Bid record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Bid filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Bid model
        order
            Order the returned Bid records by any field
        distinct
            Filter Bid records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Bid
            The first Bid record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Bid record ordered by the status field
        bid = await Bid.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BidUpdateInput,
        where: types.BidWhereUniqueInput,
        include: Optional[types.BidInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Bid record.

        Parameters
        ----------
        data
            Bid record data specifying what to update
        where
            Bid filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The updated Bid record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bid = await Bid.prisma().update(
            where={
                'id': 'fdfeaggba',
            },
            data={
                # data to update the Bid record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BidWhereUniqueInput,
        data: types.BidUpsertInput,
        include: Optional[types.BidInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Bid filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Bid model

        Returns
        -------
        prisma.models.Bid
            The created or updated Bid record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bid = await Bid.prisma().upsert(
            where={
                'id': 'begjjihibb',
            },
            data={
                'create': {
                    'id': 'begjjihibb',
                    'contractId': 'bcedhibfhg',
                    'teamSeasonId': 'bebdjbdbif',
                    'amount': 1830779270,
                },
                'update': {
                    'contractId': 'bcedhibfhg',
                    'teamSeasonId': 'bebdjbdbif',
                    'amount': 1830779270,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BidUpdateManyMutationInput,
        where: types.BidWhereInput,
    ) -> int:
        """Update multiple Bid records

        Parameters
        ----------
        data
            Bid data to update the selected Bid records to
        where
            Filter to select the Bid records to update

        Returns
        -------
        int
            The total number of Bid records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Bid records
        total = await Bid.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Bid records present in the database

        Parameters
        ----------
        select
            Select the Bid fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Bid filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BidCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Bid.prisma().count()

        # results: prisma.types.BidCountAggregateOutput
        results = await Bid.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BidCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> types.BidCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BidCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BidWhereInput] = None,
        cursor: Optional[types.BidWhereUniqueInput] = None,
    ) -> Union[int, types.BidCountAggregateOutput]:
        """Count the number of Bid records present in the database

        Parameters
        ----------
        select
            Select the Bid fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Bid filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BidCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Bid.prisma().count()

        # results: prisma.types.BidCountAggregateOutput
        results = await Bid.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BidCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BidWhereInput] = None
    ) -> int:
        """Delete multiple Bid records.

        Parameters
        ----------
        where
            Optional Bid filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Bid records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Bid records
        total = await Bid.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BidScalarFieldKeysT'],
        *,
        where: Optional['types.BidWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BidAvgAggregateInput'] = None,
        sum: Optional['types.BidSumAggregateInput'] = None,
        min: Optional['types.BidMinAggregateInput'] = None,
        max: Optional['types.BidMaxAggregateInput'] = None,
        having: Optional['types.BidScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BidCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BidScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BidScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BidGroupByOutput']:
        """Group Bid records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Bid fields to group records by
        where
            Bid filter to select records
        take
            Limit the maximum number of Bid records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BidGroupByOutput]
            A list of dictionaries representing the Bid record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Bid records by contractId values
        # and count how many records are in each group
        results = await Bid.prisma().group_by(
            ['contractId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContractActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contract]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Contract.prisma().query_raw(
            'SELECT * FROM Contract WHERE id = $1',
            'caddceegea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contract
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Contract.prisma().query_first(
            'SELECT * FROM Contract WHERE amount = $1',
            1601123481,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContractCreateInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contract record.

        Parameters
        ----------
        data
            Contract record data
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created Contract record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contract record from just the required fields
        contract = await Contract.prisma().create(
            data={
                # data to create a Contract record
                'amount': 196490078,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContractCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contract records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contract record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Contract.prisma().create_many(
            data=[
                {
                    # data to create a Contract record
                    'amount': 418296639,
                },
                {
                    # data to create a Contract record
                    'amount': 2046407692,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contract record.

        Parameters
        ----------
        where
            Contract filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The deleted Contract record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().delete(
            where={
                'id': 'bdgggffdbh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contract record.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique(
            where={
                'id': 'ecceffbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Contract record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique_or_raise(
            where={
                'id': 'hicficihf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contract records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N results
        where
            Contract filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contract]
            The list of all Contract records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contract records
        contracts = await Contract.prisma().find_many(take=10)

        # find the first 5 Contract records ordered by the createdAt field
        contracts = await Contract.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contract record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the updatedAt field
        contract = await Contract.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Contract record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the id field
        contract = await Contract.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContractUpdateInput,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contract record.

        Parameters
        ----------
        data
            Contract record data specifying what to update
        where
            Contract filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The updated Contract record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contract = await Contract.prisma().update(
            where={
                'id': 'ibfaagjgi',
            },
            data={
                # data to update the Contract record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContractWhereUniqueInput,
        data: types.ContractUpsertInput,
        include: Optional[types.ContractInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contract filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created or updated Contract record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().upsert(
            where={
                'id': 'eaifecghd',
            },
            data={
                'create': {
                    'id': 'eaifecghd',
                    'amount': 2046407692,
                },
                'update': {
                    'amount': 2046407692,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContractUpdateManyMutationInput,
        where: types.ContractWhereInput,
    ) -> int:
        """Update multiple Contract records

        Parameters
        ----------
        data
            Contract data to update the selected Contract records to
        where
            Filter to select the Contract records to update

        Returns
        -------
        int
            The total number of Contract records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contract records
        total = await Contract.prisma().update_many(
            data={
                'amount': 1618956342
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContractCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> types.ContractCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContractCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> Union[int, types.ContractCountAggregateOutput]:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContractCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContractWhereInput] = None
    ) -> int:
        """Delete multiple Contract records.

        Parameters
        ----------
        where
            Optional Contract filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contract records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contract records
        total = await Contract.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContractScalarFieldKeysT'],
        *,
        where: Optional['types.ContractWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContractAvgAggregateInput'] = None,
        sum: Optional['types.ContractSumAggregateInput'] = None,
        min: Optional['types.ContractMinAggregateInput'] = None,
        max: Optional['types.ContractMaxAggregateInput'] = None,
        having: Optional['types.ContractScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContractCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContractScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ContractScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ContractGroupByOutput']:
        """Group Contract records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contract fields to group records by
        where
            Contract filter to select records
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContractGroupByOutput]
            A list of dictionaries representing the Contract record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contract records by id values
        # and count how many records are in each group
        results = await Contract.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'fediaecbf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'heggbgjjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'bhcifchej',
                'username': 'cajffjdjcc',
                'password': 'bfifidcjbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bdigbbhjae',
                    'username': 'ijfaffdgj',
                    'password': 'cbidhicfe',
                },
                {
                    # data to create a User record
                    'email': 'bhcacgebf',
                    'username': 'ihibjghjg',
                    'password': 'bgjgccjicj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'biajcgifag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bheefggifj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hgedcaiai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bcbbjeidfd',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bifffjjdde',
            },
            data={
                'create': {
                    'id': 'bifffjjdde',
                    'email': 'bhcacgebf',
                    'username': 'ihibjghjg',
                    'password': 'bgjgccjicj',
                },
                'update': {
                    'email': 'bhcacgebf',
                    'username': 'ihibjghjg',
                    'password': 'bgjgccjicj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'role': enums.UserRole.SUPER_ADMIN
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'avatarUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'isSuperAdmin': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeysT'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by isAdmin values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['isAdmin'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EaIdHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EaIdHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EaIdHistory.prisma().query_raw(
            'SELECT * FROM EaIdHistory WHERE id = $1',
            'begafdbcdj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EaIdHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EaIdHistory.prisma().query_first(
            'SELECT * FROM EaIdHistory WHERE userId = $1',
            'bjghehhega',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EaIdHistoryCreateInput,
        include: Optional[types.EaIdHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new EaIdHistory record.

        Parameters
        ----------
        data
            EaIdHistory record data
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The created EaIdHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EaIdHistory record from just the required fields
        eaidhistory = await EaIdHistory.prisma().create(
            data={
                # data to create a EaIdHistory record
                'userId': 'bjahjfchgf',
                'eaId': 'igacgedag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EaIdHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EaIdHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EaIdHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EaIdHistory.prisma().create_many(
            data=[
                {
                    # data to create a EaIdHistory record
                    'userId': 'biabebefjf',
                    'eaId': 'cbjahcfhg',
                },
                {
                    # data to create a EaIdHistory record
                    'userId': 'idfgegdcj',
                    'eaId': 'bchdbejgda',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EaIdHistoryWhereUniqueInput,
        include: Optional[types.EaIdHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EaIdHistory record.

        Parameters
        ----------
        where
            EaIdHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The deleted EaIdHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        eaidhistory = await EaIdHistory.prisma().delete(
            where={
                'id': 'iabddeah',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EaIdHistoryWhereUniqueInput,
        include: Optional[types.EaIdHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EaIdHistory record.

        Parameters
        ----------
        where
            EaIdHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The found EaIdHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        eaidhistory = await EaIdHistory.prisma().find_unique(
            where={
                'id': 'jjdfdgbai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EaIdHistoryWhereUniqueInput,
        include: Optional[types.EaIdHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EaIdHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EaIdHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The found EaIdHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        eaidhistory = await EaIdHistory.prisma().find_unique_or_raise(
            where={
                'id': 'egciiedh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
        include: Optional[types.EaIdHistoryInclude] = None,
        order: Optional[Union[types.EaIdHistoryOrderByInput, List[types.EaIdHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.EaIdHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EaIdHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EaIdHistory records returned
        skip
            Ignore the first N results
        where
            EaIdHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EaIdHistory model
        order
            Order the returned EaIdHistory records by any field
        distinct
            Filter EaIdHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EaIdHistory]
            The list of all EaIdHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EaIdHistory records
        eaidhistorys = await EaIdHistory.prisma().find_many(take=10)

        # find the first 5 EaIdHistory records ordered by the eaId field
        eaidhistorys = await EaIdHistory.prisma().find_many(
            take=5,
            order={
                'eaId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
        include: Optional[types.EaIdHistoryInclude] = None,
        order: Optional[Union[types.EaIdHistoryOrderByInput, List[types.EaIdHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.EaIdHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EaIdHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EaIdHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EaIdHistory model
        order
            Order the returned EaIdHistory records by any field
        distinct
            Filter EaIdHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EaIdHistory
            The first EaIdHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EaIdHistory record ordered by the createdAt field
        eaidhistory = await EaIdHistory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
        include: Optional[types.EaIdHistoryInclude] = None,
        order: Optional[Union[types.EaIdHistoryOrderByInput, List[types.EaIdHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.EaIdHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EaIdHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EaIdHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EaIdHistory model
        order
            Order the returned EaIdHistory records by any field
        distinct
            Filter EaIdHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EaIdHistory
            The first EaIdHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EaIdHistory record ordered by the updatedAt field
        eaidhistory = await EaIdHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EaIdHistoryUpdateInput,
        where: types.EaIdHistoryWhereUniqueInput,
        include: Optional[types.EaIdHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EaIdHistory record.

        Parameters
        ----------
        data
            EaIdHistory record data specifying what to update
        where
            EaIdHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The updated EaIdHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        eaidhistory = await EaIdHistory.prisma().update(
            where={
                'id': 'bdifabdjgc',
            },
            data={
                # data to update the EaIdHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EaIdHistoryWhereUniqueInput,
        data: types.EaIdHistoryUpsertInput,
        include: Optional[types.EaIdHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EaIdHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EaIdHistory model

        Returns
        -------
        prisma.models.EaIdHistory
            The created or updated EaIdHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        eaidhistory = await EaIdHistory.prisma().upsert(
            where={
                'id': 'cdgcech',
            },
            data={
                'create': {
                    'id': 'cdgcech',
                    'userId': 'idfgegdcj',
                    'eaId': 'bchdbejgda',
                },
                'update': {
                    'userId': 'idfgegdcj',
                    'eaId': 'bchdbejgda',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EaIdHistoryUpdateManyMutationInput,
        where: types.EaIdHistoryWhereInput,
    ) -> int:
        """Update multiple EaIdHistory records

        Parameters
        ----------
        data
            EaIdHistory data to update the selected EaIdHistory records to
        where
            Filter to select the EaIdHistory records to update

        Returns
        -------
        int
            The total number of EaIdHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EaIdHistory records
        total = await EaIdHistory.prisma().update_many(
            data={
                'id': 'cahfeidjjc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EaIdHistory records present in the database

        Parameters
        ----------
        select
            Select the EaIdHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EaIdHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EaIdHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EaIdHistory.prisma().count()

        # results: prisma.types.EaIdHistoryCountAggregateOutput
        results = await EaIdHistory.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EaIdHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
    ) -> types.EaIdHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EaIdHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EaIdHistoryWhereInput] = None,
        cursor: Optional[types.EaIdHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.EaIdHistoryCountAggregateOutput]:
        """Count the number of EaIdHistory records present in the database

        Parameters
        ----------
        select
            Select the EaIdHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EaIdHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EaIdHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EaIdHistory.prisma().count()

        # results: prisma.types.EaIdHistoryCountAggregateOutput
        results = await EaIdHistory.prisma().count(
            select={
                '_all': True,
                'eaId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EaIdHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EaIdHistoryWhereInput] = None
    ) -> int:
        """Delete multiple EaIdHistory records.

        Parameters
        ----------
        where
            Optional EaIdHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EaIdHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EaIdHistory records
        total = await EaIdHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EaIdHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.EaIdHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EaIdHistoryAvgAggregateInput'] = None,
        sum: Optional['types.EaIdHistorySumAggregateInput'] = None,
        min: Optional['types.EaIdHistoryMinAggregateInput'] = None,
        max: Optional['types.EaIdHistoryMaxAggregateInput'] = None,
        having: Optional['types.EaIdHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EaIdHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EaIdHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.EaIdHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.EaIdHistoryGroupByOutput']:
        """Group EaIdHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EaIdHistory fields to group records by
        where
            EaIdHistory filter to select records
        take
            Limit the maximum number of EaIdHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EaIdHistoryGroupByOutput]
            A list of dictionaries representing the EaIdHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EaIdHistory records by createdAt values
        # and count how many records are in each group
        results = await EaIdHistory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SystemHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SystemHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SystemHistory.prisma().query_raw(
            'SELECT * FROM SystemHistory WHERE id = $1',
            'ijfgbcgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SystemHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SystemHistory.prisma().query_first(
            'SELECT * FROM SystemHistory WHERE userId = $1',
            'iedhiefji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SystemHistoryCreateInput,
        include: Optional[types.SystemHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new SystemHistory record.

        Parameters
        ----------
        data
            SystemHistory record data
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The created SystemHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SystemHistory record from just the required fields
        systemhistory = await SystemHistory.prisma().create(
            data={
                # data to create a SystemHistory record
                'userId': 'bfibagifgh',
                'system': enums.System.PS,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SystemHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SystemHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SystemHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SystemHistory.prisma().create_many(
            data=[
                {
                    # data to create a SystemHistory record
                    'userId': 'ddccaidii',
                    'system': enums.System.PS,
                },
                {
                    # data to create a SystemHistory record
                    'userId': 'bccfegbeif',
                    'system': enums.System.PS,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SystemHistoryWhereUniqueInput,
        include: Optional[types.SystemHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SystemHistory record.

        Parameters
        ----------
        where
            SystemHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The deleted SystemHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemhistory = await SystemHistory.prisma().delete(
            where={
                'id': 'ibehchefi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SystemHistoryWhereUniqueInput,
        include: Optional[types.SystemHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SystemHistory record.

        Parameters
        ----------
        where
            SystemHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The found SystemHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemhistory = await SystemHistory.prisma().find_unique(
            where={
                'id': 'caigcfigbb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SystemHistoryWhereUniqueInput,
        include: Optional[types.SystemHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SystemHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SystemHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The found SystemHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemhistory = await SystemHistory.prisma().find_unique_or_raise(
            where={
                'id': 'iibbbffae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
        include: Optional[types.SystemHistoryInclude] = None,
        order: Optional[Union[types.SystemHistoryOrderByInput, List[types.SystemHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SystemHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SystemHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SystemHistory records returned
        skip
            Ignore the first N results
        where
            SystemHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemHistory model
        order
            Order the returned SystemHistory records by any field
        distinct
            Filter SystemHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SystemHistory]
            The list of all SystemHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SystemHistory records
        systemhistorys = await SystemHistory.prisma().find_many(take=10)

        # find the first 5 SystemHistory records ordered by the system field
        systemhistorys = await SystemHistory.prisma().find_many(
            take=5,
            order={
                'system': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
        include: Optional[types.SystemHistoryInclude] = None,
        order: Optional[Union[types.SystemHistoryOrderByInput, List[types.SystemHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SystemHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SystemHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemHistory model
        order
            Order the returned SystemHistory records by any field
        distinct
            Filter SystemHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemHistory
            The first SystemHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemHistory record ordered by the createdAt field
        systemhistory = await SystemHistory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
        include: Optional[types.SystemHistoryInclude] = None,
        order: Optional[Union[types.SystemHistoryOrderByInput, List[types.SystemHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SystemHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SystemHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemHistory model
        order
            Order the returned SystemHistory records by any field
        distinct
            Filter SystemHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemHistory
            The first SystemHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemHistory record ordered by the updatedAt field
        systemhistory = await SystemHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SystemHistoryUpdateInput,
        where: types.SystemHistoryWhereUniqueInput,
        include: Optional[types.SystemHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SystemHistory record.

        Parameters
        ----------
        data
            SystemHistory record data specifying what to update
        where
            SystemHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The updated SystemHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        systemhistory = await SystemHistory.prisma().update(
            where={
                'id': 'bfeejijjcj',
            },
            data={
                # data to update the SystemHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SystemHistoryWhereUniqueInput,
        data: types.SystemHistoryUpsertInput,
        include: Optional[types.SystemHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SystemHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SystemHistory model

        Returns
        -------
        prisma.models.SystemHistory
            The created or updated SystemHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemhistory = await SystemHistory.prisma().upsert(
            where={
                'id': 'fjffjchi',
            },
            data={
                'create': {
                    'id': 'fjffjchi',
                    'userId': 'bccfegbeif',
                    'system': enums.System.PS,
                },
                'update': {
                    'userId': 'bccfegbeif',
                    'system': enums.System.PS,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SystemHistoryUpdateManyMutationInput,
        where: types.SystemHistoryWhereInput,
    ) -> int:
        """Update multiple SystemHistory records

        Parameters
        ----------
        data
            SystemHistory data to update the selected SystemHistory records to
        where
            Filter to select the SystemHistory records to update

        Returns
        -------
        int
            The total number of SystemHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SystemHistory records
        total = await SystemHistory.prisma().update_many(
            data={
                'id': 'jidfbaadb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SystemHistory records present in the database

        Parameters
        ----------
        select
            Select the SystemHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemHistory.prisma().count()

        # results: prisma.types.SystemHistoryCountAggregateOutput
        results = await SystemHistory.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SystemHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
    ) -> types.SystemHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SystemHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemHistoryWhereInput] = None,
        cursor: Optional[types.SystemHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.SystemHistoryCountAggregateOutput]:
        """Count the number of SystemHistory records present in the database

        Parameters
        ----------
        select
            Select the SystemHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemHistory.prisma().count()

        # results: prisma.types.SystemHistoryCountAggregateOutput
        results = await SystemHistory.prisma().count(
            select={
                '_all': True,
                'system': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SystemHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SystemHistoryWhereInput] = None
    ) -> int:
        """Delete multiple SystemHistory records.

        Parameters
        ----------
        where
            Optional SystemHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SystemHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SystemHistory records
        total = await SystemHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SystemHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.SystemHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SystemHistoryAvgAggregateInput'] = None,
        sum: Optional['types.SystemHistorySumAggregateInput'] = None,
        min: Optional['types.SystemHistoryMinAggregateInput'] = None,
        max: Optional['types.SystemHistoryMaxAggregateInput'] = None,
        having: Optional['types.SystemHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SystemHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SystemHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SystemHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SystemHistoryGroupByOutput']:
        """Group SystemHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SystemHistory fields to group records by
        where
            SystemHistory filter to select records
        take
            Limit the maximum number of SystemHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SystemHistoryGroupByOutput]
            A list of dictionaries representing the SystemHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SystemHistory records by createdAt values
        # and count how many records are in each group
        results = await SystemHistory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GamertagHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GamertagHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GamertagHistory.prisma().query_raw(
            'SELECT * FROM GamertagHistory WHERE userId = $1',
            'behdacbaie',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GamertagHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GamertagHistory.prisma().query_first(
            'SELECT * FROM GamertagHistory WHERE system = $1',
            enums.System.PS,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GamertagHistoryCreateInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new GamertagHistory record.

        Parameters
        ----------
        data
            GamertagHistory record data
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The created GamertagHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GamertagHistory record from just the required fields
        gamertaghistory = await GamertagHistory.prisma().create(
            data={
                # data to create a GamertagHistory record
                'userId': 'bfjgcaghfh',
                'system': enums.System.PS,
                'gamertag': 'cahdaeja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GamertagHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GamertagHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GamertagHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GamertagHistory.prisma().create_many(
            data=[
                {
                    # data to create a GamertagHistory record
                    'userId': 'hebbbcdgd',
                    'system': enums.System.PS,
                    'gamertag': 'bbehiidbee',
                },
                {
                    # data to create a GamertagHistory record
                    'userId': 'ebgbfhhcj',
                    'system': enums.System.PS,
                    'gamertag': 'ififjedhe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GamertagHistory record.

        Parameters
        ----------
        where
            GamertagHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The deleted GamertagHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().delete(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GamertagHistory record.

        Parameters
        ----------
        where
            GamertagHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The found GamertagHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().find_unique(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GamertagHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GamertagHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The found GamertagHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().find_unique_or_raise(
            where={
                # GamertagHistory where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GamertagHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GamertagHistory records returned
        skip
            Ignore the first N results
        where
            GamertagHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GamertagHistory]
            The list of all GamertagHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GamertagHistory records
        gamertaghistorys = await GamertagHistory.prisma().find_many(take=10)

        # find the first 5 GamertagHistory records ordered by the gamertag field
        gamertaghistorys = await GamertagHistory.prisma().find_many(
            take=5,
            order={
                'gamertag': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GamertagHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GamertagHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GamertagHistory
            The first GamertagHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GamertagHistory record ordered by the createdAt field
        gamertaghistory = await GamertagHistory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
        include: Optional[types.GamertagHistoryInclude] = None,
        order: Optional[Union[types.GamertagHistoryOrderByInput, List[types.GamertagHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.GamertagHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GamertagHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GamertagHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GamertagHistory model
        order
            Order the returned GamertagHistory records by any field
        distinct
            Filter GamertagHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GamertagHistory
            The first GamertagHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GamertagHistory record ordered by the updatedAt field
        gamertaghistory = await GamertagHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GamertagHistoryUpdateInput,
        where: types.GamertagHistoryWhereUniqueInput,
        include: Optional[types.GamertagHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GamertagHistory record.

        Parameters
        ----------
        data
            GamertagHistory record data specifying what to update
        where
            GamertagHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The updated GamertagHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().update(
            where={
                # GamertagHistory where unique filter

            },
            data={
                # data to update the GamertagHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GamertagHistoryWhereUniqueInput,
        data: types.GamertagHistoryUpsertInput,
        include: Optional[types.GamertagHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GamertagHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GamertagHistory model

        Returns
        -------
        prisma.models.GamertagHistory
            The created or updated GamertagHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gamertaghistory = await GamertagHistory.prisma().upsert(
            where={
                # GamertagHistory where unique filter
            },
            data={
                'create': {
                    # GamertagHistory data to be set if the record does not exist
                },
                'update': {
                    # GamertagHistory data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GamertagHistoryUpdateManyMutationInput,
        where: types.GamertagHistoryWhereInput,
    ) -> int:
        """Update multiple GamertagHistory records

        Parameters
        ----------
        data
            GamertagHistory data to update the selected GamertagHistory records to
        where
            Filter to select the GamertagHistory records to update

        Returns
        -------
        int
            The total number of GamertagHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GamertagHistory records
        total = await GamertagHistory.prisma().update_many(
            data={
                'verificationCode': 'hfedffhbj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GamertagHistory records present in the database

        Parameters
        ----------
        select
            Select the GamertagHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GamertagHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GamertagHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GamertagHistory.prisma().count()

        # results: prisma.types.GamertagHistoryCountAggregateOutput
        results = await GamertagHistory.prisma().count(
            select={
                '_all': True,
                'codeGeneratedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GamertagHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> types.GamertagHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GamertagHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GamertagHistoryWhereInput] = None,
        cursor: Optional[types.GamertagHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.GamertagHistoryCountAggregateOutput]:
        """Count the number of GamertagHistory records present in the database

        Parameters
        ----------
        select
            Select the GamertagHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GamertagHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GamertagHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GamertagHistory.prisma().count()

        # results: prisma.types.GamertagHistoryCountAggregateOutput
        results = await GamertagHistory.prisma().count(
            select={
                '_all': True,
                'verificationStatus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GamertagHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GamertagHistoryWhereInput] = None
    ) -> int:
        """Delete multiple GamertagHistory records.

        Parameters
        ----------
        where
            Optional GamertagHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GamertagHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GamertagHistory records
        total = await GamertagHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GamertagHistoryScalarFieldKeysT'],
        *,
        where: Optional['types.GamertagHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GamertagHistoryAvgAggregateInput'] = None,
        sum: Optional['types.GamertagHistorySumAggregateInput'] = None,
        min: Optional['types.GamertagHistoryMinAggregateInput'] = None,
        max: Optional['types.GamertagHistoryMaxAggregateInput'] = None,
        having: Optional['types.GamertagHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GamertagHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GamertagHistoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.GamertagHistoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.GamertagHistoryGroupByOutput']:
        """Group GamertagHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GamertagHistory fields to group records by
        where
            GamertagHistory filter to select records
        take
            Limit the maximum number of GamertagHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GamertagHistoryGroupByOutput]
            A list of dictionaries representing the GamertagHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GamertagHistory records by verifiedAt values
        # and count how many records are in each group
        results = await GamertagHistory.prisma().group_by(
            ['verifiedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            'bgiijbehea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            'bbffbhdhcf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 'bfchgjajgc',
                'type': enums.NotificationType.SYSTEM,
                'title': 'cadgfjhggh',
                'message': 'bfdjfdceei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 'efggdaihd',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'ihccegibe',
                    'message': 'fjicjcccd',
                },
                {
                    # data to create a Notification record
                    'userId': 'babcahcee',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bcfdfajjaj',
                    'message': 'caijhaajag',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 'eifbeahf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 'bddjcffcce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 'bghaaafgej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the type field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the title field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the message field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 'dgceiifgg',
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 'cabciaijfb',
            },
            data={
                'create': {
                    'id': 'cabciaijfb',
                    'userId': 'babcahcee',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bcfdfajjaj',
                    'message': 'caijhaajag',
                },
                'update': {
                    'userId': 'babcahcee',
                    'type': enums.NotificationType.SYSTEM,
                    'title': 'bcfdfajjaj',
                    'message': 'caijhaajag',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'status': enums.NotificationStatus.UNREAD
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'link': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeysT'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by createdAt values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models