# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _SystemListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.System']]


class _SystemListFilterHasInput(TypedDict):
    has: 'enums.System'


class _SystemListFilterHasEveryInput(TypedDict):
    has_every: List['enums.System']


class _SystemListFilterHasSomeInput(TypedDict):
    has_some: List['enums.System']


class _SystemListFilterIsEmptyInput(TypedDict):
    is_empty: bool


SystemListFilter = Union[
    _SystemListFilterHasInput,
    _SystemListFilterEqualsInput,
    _SystemListFilterHasSomeInput,
    _SystemListFilterIsEmptyInput,
    _SystemListFilterHasEveryInput,
]


class _SystemListUpdateSet(TypedDict):
    set: List['enums.System']


class _SystemListUpdatePush(TypedDict):
    push: List['enums.System']


SystemListUpdate = Union[
    List['enums.System'],
    _SystemListUpdateSet,
    _SystemListUpdatePush,
]

class _BidStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.BidStatus']]


class _BidStatusListFilterHasInput(TypedDict):
    has: 'enums.BidStatus'


class _BidStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.BidStatus']


class _BidStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.BidStatus']


class _BidStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BidStatusListFilter = Union[
    _BidStatusListFilterHasInput,
    _BidStatusListFilterEqualsInput,
    _BidStatusListFilterHasSomeInput,
    _BidStatusListFilterIsEmptyInput,
    _BidStatusListFilterHasEveryInput,
]


class _BidStatusListUpdateSet(TypedDict):
    set: List['enums.BidStatus']


class _BidStatusListUpdatePush(TypedDict):
    push: List['enums.BidStatus']


BidStatusListUpdate = Union[
    List['enums.BidStatus'],
    _BidStatusListUpdateSet,
    _BidStatusListUpdatePush,
]

class _NotificationTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.NotificationType']]


class _NotificationTypeListFilterHasInput(TypedDict):
    has: 'enums.NotificationType'


class _NotificationTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.NotificationType']


class _NotificationTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.NotificationType']


class _NotificationTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


NotificationTypeListFilter = Union[
    _NotificationTypeListFilterHasInput,
    _NotificationTypeListFilterEqualsInput,
    _NotificationTypeListFilterHasSomeInput,
    _NotificationTypeListFilterIsEmptyInput,
    _NotificationTypeListFilterHasEveryInput,
]


class _NotificationTypeListUpdateSet(TypedDict):
    set: List['enums.NotificationType']


class _NotificationTypeListUpdatePush(TypedDict):
    push: List['enums.NotificationType']


NotificationTypeListUpdate = Union[
    List['enums.NotificationType'],
    _NotificationTypeListUpdateSet,
    _NotificationTypeListUpdatePush,
]

class _NotificationStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.NotificationStatus']]


class _NotificationStatusListFilterHasInput(TypedDict):
    has: 'enums.NotificationStatus'


class _NotificationStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.NotificationStatus']


class _NotificationStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.NotificationStatus']


class _NotificationStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


NotificationStatusListFilter = Union[
    _NotificationStatusListFilterHasInput,
    _NotificationStatusListFilterEqualsInput,
    _NotificationStatusListFilterHasSomeInput,
    _NotificationStatusListFilterIsEmptyInput,
    _NotificationStatusListFilterHasEveryInput,
]


class _NotificationStatusListUpdateSet(TypedDict):
    set: List['enums.NotificationStatus']


class _NotificationStatusListUpdatePush(TypedDict):
    push: List['enums.NotificationStatus']


NotificationStatusListUpdate = Union[
    List['enums.NotificationStatus'],
    _NotificationStatusListUpdateSet,
    _NotificationStatusListUpdatePush,
]

class _ForumPostStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ForumPostStatus']]


class _ForumPostStatusListFilterHasInput(TypedDict):
    has: 'enums.ForumPostStatus'


class _ForumPostStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ForumPostStatus']


class _ForumPostStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ForumPostStatus']


class _ForumPostStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ForumPostStatusListFilter = Union[
    _ForumPostStatusListFilterHasInput,
    _ForumPostStatusListFilterEqualsInput,
    _ForumPostStatusListFilterHasSomeInput,
    _ForumPostStatusListFilterIsEmptyInput,
    _ForumPostStatusListFilterHasEveryInput,
]


class _ForumPostStatusListUpdateSet(TypedDict):
    set: List['enums.ForumPostStatus']


class _ForumPostStatusListUpdatePush(TypedDict):
    push: List['enums.ForumPostStatus']


ForumPostStatusListUpdate = Union[
    List['enums.ForumPostStatus'],
    _ForumPostStatusListUpdateSet,
    _ForumPostStatusListUpdatePush,
]

class _ReactionTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ReactionType']]


class _ReactionTypeListFilterHasInput(TypedDict):
    has: 'enums.ReactionType'


class _ReactionTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ReactionType']


class _ReactionTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ReactionType']


class _ReactionTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ReactionTypeListFilter = Union[
    _ReactionTypeListFilterHasInput,
    _ReactionTypeListFilterEqualsInput,
    _ReactionTypeListFilterHasSomeInput,
    _ReactionTypeListFilterIsEmptyInput,
    _ReactionTypeListFilterHasEveryInput,
]


class _ReactionTypeListUpdateSet(TypedDict):
    set: List['enums.ReactionType']


class _ReactionTypeListUpdatePush(TypedDict):
    push: List['enums.ReactionType']


ReactionTypeListUpdate = Union[
    List['enums.ReactionType'],
    _ReactionTypeListUpdateSet,
    _ReactionTypeListUpdatePush,
]

class _TeamManagementRoleListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TeamManagementRole']]


class _TeamManagementRoleListFilterHasInput(TypedDict):
    has: 'enums.TeamManagementRole'


class _TeamManagementRoleListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TeamManagementRole']


class _TeamManagementRoleListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TeamManagementRole']


class _TeamManagementRoleListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TeamManagementRoleListFilter = Union[
    _TeamManagementRoleListFilterHasInput,
    _TeamManagementRoleListFilterEqualsInput,
    _TeamManagementRoleListFilterHasSomeInput,
    _TeamManagementRoleListFilterIsEmptyInput,
    _TeamManagementRoleListFilterHasEveryInput,
]


class _TeamManagementRoleListUpdateSet(TypedDict):
    set: List['enums.TeamManagementRole']


class _TeamManagementRoleListUpdatePush(TypedDict):
    push: List['enums.TeamManagementRole']


TeamManagementRoleListUpdate = Union[
    List['enums.TeamManagementRole'],
    _TeamManagementRoleListUpdateSet,
    _TeamManagementRoleListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    name: Optional[_str]
    avatarUrl: Optional[_str]
    isAdmin: _bool
    resetToken: Optional[_str]
    resetTokenExpiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: 'PlayerCreateNestedWithoutRelationsInput'
    notifications: 'NotificationCreateManyNestedWithoutRelationsInput'
    forumPosts: 'ForumPostCreateManyNestedWithoutRelationsInput'
    forumComments: 'ForumCommentCreateManyNestedWithoutRelationsInput'
    forumReactions: 'ForumReactionCreateManyNestedWithoutRelationsInput'
    forumFollowing: 'ForumFollowerCreateManyNestedWithoutRelationsInput'
    forumSubscriptions: 'ForumPostSubscriptionCreateManyNestedWithoutRelationsInput'
    teamManagement: 'TeamManagerCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    username: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    name: Optional[_str]
    avatarUrl: Optional[_str]
    isAdmin: _bool
    resetToken: Optional[_str]
    resetTokenExpiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    username: _str
    password: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_UserWhereUnique_username_Input = TypedDict(
    '_UserWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

_UserWhereUnique_resetToken_Input = TypedDict(
    '_UserWhereUnique_resetToken_Input',
    {
        'resetToken': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
    '_UserWhereUnique_username_Input',
    '_UserWhereUnique_resetToken_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    username: _str
    password: _str
    name: Optional[_str]
    avatarUrl: Optional[_str]
    isAdmin: _bool
    resetToken: Optional[_str]
    resetTokenExpiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: 'PlayerUpdateOneWithoutRelationsInput'
    notifications: 'NotificationUpdateManyWithoutRelationsInput'
    forumPosts: 'ForumPostUpdateManyWithoutRelationsInput'
    forumComments: 'ForumCommentUpdateManyWithoutRelationsInput'
    forumReactions: 'ForumReactionUpdateManyWithoutRelationsInput'
    forumFollowing: 'ForumFollowerUpdateManyWithoutRelationsInput'
    forumSubscriptions: 'ForumPostSubscriptionUpdateManyWithoutRelationsInput'
    teamManagement: 'TeamManagerUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    username: _str
    password: _str
    name: Optional[_str]
    avatarUrl: Optional[_str]
    isAdmin: _bool
    resetToken: Optional[_str]
    resetTokenExpiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_username_OrderByInput = TypedDict(
    '_User_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_avatarUrl_OrderByInput = TypedDict(
    '_User_avatarUrl_OrderByInput',
    {
        'avatarUrl': 'SortOrder',
    },
    total=True
)

_User_isAdmin_OrderByInput = TypedDict(
    '_User_isAdmin_OrderByInput',
    {
        'isAdmin': 'SortOrder',
    },
    total=True
)

_User_resetToken_OrderByInput = TypedDict(
    '_User_resetToken_OrderByInput',
    {
        'resetToken': 'SortOrder',
    },
    total=True
)

_User_resetTokenExpiresAt_OrderByInput = TypedDict(
    '_User_resetTokenExpiresAt_OrderByInput',
    {
        'resetTokenExpiresAt': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_username_OrderByInput',
    '_User_password_OrderByInput',
    '_User_name_OrderByInput',
    '_User_avatarUrl_OrderByInput',
    '_User_isAdmin_OrderByInput',
    '_User_resetToken_OrderByInput',
    '_User_resetTokenExpiresAt_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    player: Union[bool, 'PlayerArgsFromUser']
    notifications: Union[bool, 'FindManyNotificationArgsFromUser']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromUser']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromUser']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromUser']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromUser']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromUser']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromUser']


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    player: Union[bool, 'PlayerArgsFromUser']
    notifications: Union[bool, 'FindManyNotificationArgsFromUser']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromUser']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromUser']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromUser']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromUser']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromUser']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromUser']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromUser']


class PlayerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    player: Union[bool, 'PlayerArgsFromUser']


class GamertagHistoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tiers: Union[bool, 'FindManyTierArgsFromUser']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromUser']


class SeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    season: Union[bool, 'SeasonArgsFromUser']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromUser']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromUser']


class TierArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromUser']
    managers: Union[bool, 'FindManyTeamManagerArgsFromUser']
    nhlAffiliate: Union[bool, 'TeamArgsFromUser']
    ahlAffiliate: Union[bool, 'TeamArgsFromUser']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromUser']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromUser']


class TeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    team: Union[bool, 'TeamArgsFromUser']
    tier: Union[bool, 'TierArgsFromUser']
    matches: Union[bool, 'FindManyMatchArgsFromUser']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromUser']
    bids: Union[bool, 'FindManyBidArgsFromUser']


class TeamSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    player: Union[bool, 'PlayerArgsFromUser']
    season: Union[bool, 'SeasonArgsFromUser']
    contract: Union[bool, 'ContractArgsFromUser']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromUser']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromUser']


class PlayerSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromUser']
    tier: Union[bool, 'TierArgsFromUser']


class PlayerTierHistoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromUser']
    teamSeason: Union[bool, 'TeamSeasonArgsFromUser']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromUser']


class PlayerTeamSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromUser']
    bids: Union[bool, 'FindManyBidArgsFromUser']


class ContractArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    contract: Union[bool, 'ContractArgsFromUser']
    teamSeason: Union[bool, 'TeamSeasonArgsFromUser']


class BidArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromUser']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromUser']


class MatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    match: Union[bool, 'MatchArgsFromUser']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromUser']


class PlayerMatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class NotificationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUser']
    comments: Union[bool, 'FindManyForumCommentArgsFromUser']
    reactions: Union[bool, 'FindManyForumReactionArgsFromUser']
    followers: Union[bool, 'FindManyForumFollowerArgsFromUser']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromUser']


class ForumPostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    post: Union[bool, 'ForumPostArgsFromUser']
    comment: Union[bool, 'ForumCommentArgsFromUser']


class ForumReactionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    post: Union[bool, 'ForumPostArgsFromUser']


class ForumFollowerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    post: Union[bool, 'ForumPostArgsFromUser']


class ForumPostSubscriptionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUser']
    post: Union[bool, 'ForumPostArgsFromUser']
    quotedComment: Union[bool, 'ForumCommentArgsFromUser']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromUser']
    reactions: Union[bool, 'FindManyForumReactionArgsFromUser']


class ForumCommentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    team: Union[bool, 'TeamArgsFromUser']


class TeamManagerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    avatarUrl: Union[None, _str, 'types.StringFilter']
    isAdmin: Union[_bool, 'types.BooleanFilter']
    resetToken: Union[None, _str, 'types.StringFilter']
    resetTokenExpiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    player: 'PlayerRelationFilter'
    notifications: 'NotificationListRelationFilter'
    forumPosts: 'ForumPostListRelationFilter'
    forumComments: 'ForumCommentListRelationFilter'
    forumReactions: 'ForumReactionListRelationFilter'
    forumFollowing: 'ForumFollowerListRelationFilter'
    forumSubscriptions: 'ForumPostSubscriptionListRelationFilter'
    teamManagement: 'TeamManagerListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    avatarUrl: Union[_str, 'types.StringWithAggregatesFilter']
    isAdmin: Union[_bool, 'types.BooleanWithAggregatesFilter']
    resetToken: Union[_str, 'types.StringWithAggregatesFilter']
    resetTokenExpiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    username: _str
    password: _str
    name: _str
    avatarUrl: _str
    isAdmin: _bool
    resetToken: _str
    resetTokenExpiresAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    email: _str
    username: _str
    password: _str
    name: _str
    avatarUrl: _str
    isAdmin: _bool
    resetToken: _str
    resetTokenExpiresAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    username: bool
    password: bool
    name: bool
    avatarUrl: bool
    isAdmin: bool
    resetToken: bool
    resetTokenExpiresAt: bool
    createdAt: bool
    updatedAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    username: bool
    password: bool
    name: bool
    avatarUrl: bool
    isAdmin: bool
    resetToken: bool
    resetTokenExpiresAt: bool
    createdAt: bool
    updatedAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'username': bool,
        'password': bool,
        'name': bool,
        'avatarUrl': bool,
        'isAdmin': bool,
        'resetToken': bool,
        'resetTokenExpiresAt': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'username': int,
        'password': int,
        'name': int,
        'avatarUrl': int,
        'isAdmin': int,
        'resetToken': int,
        'resetTokenExpiresAt': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'username',
    'password',
    'name',
    'avatarUrl',
    'isAdmin',
    'resetToken',
    'resetTokenExpiresAt',
    'createdAt',
    'updatedAt',
    'player',
    'notifications',
    'forumPosts',
    'forumComments',
    'forumReactions',
    'forumFollowing',
    'forumSubscriptions',
    'teamManagement',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'username',
    'password',
    'name',
    'avatarUrl',
    'isAdmin',
    'resetToken',
    'resetTokenExpiresAt',
    'createdAt',
    'updatedAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'player',
        'notifications',
        'forumPosts',
        'forumComments',
        'forumReactions',
        'forumFollowing',
        'forumSubscriptions',
        'teamManagement',
    ]

# Player types

class PlayerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Player create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    gamertags: 'GamertagHistoryCreateManyNestedWithoutRelationsInput'
    seasons: 'PlayerSeasonCreateManyNestedWithoutRelationsInput'


class PlayerCreateInput(PlayerOptionalCreateInput):
    """Required arguments to the Player create method"""
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Player create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerCreateWithoutRelationsInput(PlayerOptionalCreateWithoutRelationsInput):
    """Required arguments to the Player create method, without relations"""
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'

class PlayerConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerCreateWithoutRelationsInput'
    where: 'PlayerWhereUniqueInput'

class PlayerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerCreateWithoutRelationsInput'
    connect: 'PlayerWhereUniqueInput'
    connect_or_create: 'PlayerConnectOrCreateWithoutRelationsInput'


class PlayerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerCreateWithoutRelationsInput', List['PlayerCreateWithoutRelationsInput']]
    connect: Union['PlayerWhereUniqueInput', List['PlayerWhereUniqueInput']]
    connect_or_create: Union['PlayerConnectOrCreateWithoutRelationsInput', List['PlayerConnectOrCreateWithoutRelationsInput']]

_PlayerWhereUnique_id_Input = TypedDict(
    '_PlayerWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlayerWhereUniqueInput = _PlayerWhereUnique_id_Input


class PlayerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    gamertags: 'GamertagHistoryUpdateManyWithoutRelationsInput'
    seasons: 'PlayerSeasonUpdateManyWithoutRelationsInput'


class PlayerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerCreateWithoutRelationsInput']
    connect: List['PlayerWhereUniqueInput']
    connect_or_create: List['PlayerConnectOrCreateWithoutRelationsInput']
    set: List['PlayerWhereUniqueInput']
    disconnect: List['PlayerWhereUniqueInput']
    delete: List['PlayerWhereUniqueInput']

    # TODO
    # update: List['PlayerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerScalarWhereInput']
    # upsert: List['PlayerUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerCreateWithoutRelationsInput'
    connect: 'PlayerWhereUniqueInput'
    connect_or_create: 'PlayerConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerUpdateInput'
    # upsert: 'PlayerUpsertWithoutRelationsInput'


class PlayerUpsertInput(TypedDict):
    create: 'PlayerCreateInput'
    update: 'PlayerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Player_id_OrderByInput = TypedDict(
    '_Player_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Player_ea_id_OrderByInput = TypedDict(
    '_Player_ea_id_OrderByInput',
    {
        'ea_id': 'SortOrder',
    },
    total=True
)

_Player_name_OrderByInput = TypedDict(
    '_Player_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Player_activeSystem_OrderByInput = TypedDict(
    '_Player_activeSystem_OrderByInput',
    {
        'activeSystem': 'SortOrder',
    },
    total=True
)

_Player_createdAt_OrderByInput = TypedDict(
    '_Player_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Player_updatedAt_OrderByInput = TypedDict(
    '_Player_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Player_RelevanceInner = TypedDict(
    '_Player_RelevanceInner',
    {
        'fields': 'List[PlayerScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Player_RelevanceOrderByInput = TypedDict(
    '_Player_RelevanceOrderByInput',
    {
        '_relevance': '_Player_RelevanceInner',
    },
    total=True
)

PlayerOrderByInput = Union[
    '_Player_id_OrderByInput',
    '_Player_ea_id_OrderByInput',
    '_Player_name_OrderByInput',
    '_Player_activeSystem_OrderByInput',
    '_Player_createdAt_OrderByInput',
    '_Player_updatedAt_OrderByInput',
    '_Player_RelevanceOrderByInput',
]



# recursive Player types
# TODO: cleanup these types



PlayerRelationFilter = TypedDict(
    'PlayerRelationFilter',
    {
        'is': 'PlayerWhereInput',
        'is_not': 'PlayerWhereInput',
    },
    total=False,
)


class PlayerListRelationFilter(TypedDict, total=False):
    some: 'PlayerWhereInput'
    none: 'PlayerWhereInput'
    every: 'PlayerWhereInput'


class PlayerInclude(TypedDict, total=False):
    """Player relational arguments"""
    user: Union[bool, 'UserArgsFromPlayer']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayer']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayer']


class UserIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    player: Union[bool, 'PlayerArgsFromPlayer']
    notifications: Union[bool, 'FindManyNotificationArgsFromPlayer']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromPlayer']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromPlayer']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromPlayer']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromPlayer']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayer']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromPlayer']


class UserArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayer']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayer']


class PlayerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    player: Union[bool, 'PlayerArgsFromPlayer']


class GamertagHistoryArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    tiers: Union[bool, 'FindManyTierArgsFromPlayer']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromPlayer']


class SeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    season: Union[bool, 'SeasonArgsFromPlayer']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromPlayer']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayer']


class TierArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromPlayer']
    managers: Union[bool, 'FindManyTeamManagerArgsFromPlayer']
    nhlAffiliate: Union[bool, 'TeamArgsFromPlayer']
    ahlAffiliate: Union[bool, 'TeamArgsFromPlayer']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayer']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayer']


class TeamArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    team: Union[bool, 'TeamArgsFromPlayer']
    tier: Union[bool, 'TierArgsFromPlayer']
    matches: Union[bool, 'FindManyMatchArgsFromPlayer']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayer']
    bids: Union[bool, 'FindManyBidArgsFromPlayer']


class TeamSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    player: Union[bool, 'PlayerArgsFromPlayer']
    season: Union[bool, 'SeasonArgsFromPlayer']
    contract: Union[bool, 'ContractArgsFromPlayer']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayer']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayer']


class PlayerSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayer']
    tier: Union[bool, 'TierArgsFromPlayer']


class PlayerTierHistoryArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayer']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayer']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayer']


class PlayerTeamSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayer']
    bids: Union[bool, 'FindManyBidArgsFromPlayer']


class ContractArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    contract: Union[bool, 'ContractArgsFromPlayer']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayer']


class BidArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayer']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromPlayer']


class MatchArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    match: Union[bool, 'MatchArgsFromPlayer']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayer']


class PlayerMatchArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']


class NotificationArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    author: Union[bool, 'UserArgsFromPlayer']
    comments: Union[bool, 'FindManyForumCommentArgsFromPlayer']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayer']
    followers: Union[bool, 'FindManyForumFollowerArgsFromPlayer']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayer']


class ForumPostArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']
    post: Union[bool, 'ForumPostArgsFromPlayer']
    comment: Union[bool, 'ForumCommentArgsFromPlayer']


class ForumReactionArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']
    post: Union[bool, 'ForumPostArgsFromPlayer']


class ForumFollowerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']
    post: Union[bool, 'ForumPostArgsFromPlayer']


class ForumPostSubscriptionArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    author: Union[bool, 'UserArgsFromPlayer']
    post: Union[bool, 'ForumPostArgsFromPlayer']
    quotedComment: Union[bool, 'ForumCommentArgsFromPlayer']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromPlayer']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayer']


class ForumCommentArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromPlayer(TypedDict, total=False):
    """Relational arguments for Player"""
    user: Union[bool, 'UserArgsFromPlayer']
    team: Union[bool, 'TeamArgsFromPlayer']


class TeamManagerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromPlayer(TypedDict, total=False):
    """Arguments for Player"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyPlayerArgs = FindManyPlayerArgsFromPlayer
FindFirstPlayerArgs = FindManyPlayerArgsFromPlayer


class PlayerWhereInput(TypedDict, total=False):
    """Player arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ea_id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    activeSystem: 'enums.System'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    gamertags: 'GamertagHistoryListRelationFilter'
    seasons: 'PlayerSeasonListRelationFilter'

    # should be noted that AND and NOT should be Union['PlayerWhereInput', List['PlayerWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlayerWhereInput']
    OR: List['PlayerWhereInput']
    NOT: List['PlayerWhereInput']



# aggregate Player types


class PlayerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Player arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ea_id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    activeSystem: 'enums.System'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PlayerScalarWhereWithAggregatesInput']
    OR: List['PlayerScalarWhereWithAggregatesInput']
    NOT: List['PlayerScalarWhereWithAggregatesInput']



class PlayerGroupByOutput(TypedDict, total=False):
    id: _str
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PlayerSumAggregateOutput'
    _avg: 'PlayerAvgAggregateOutput'
    _min: 'PlayerMinAggregateOutput'
    _max: 'PlayerMaxAggregateOutput'
    _count: 'PlayerCountAggregateOutput'


class PlayerAvgAggregateOutput(TypedDict, total=False):
    """Player output for aggregating averages"""


class PlayerSumAggregateOutput(TypedDict, total=False):
    """Player output for aggregating sums"""


class PlayerScalarAggregateOutput(TypedDict, total=False):
    """Player output including scalar fields"""
    id: _str
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PlayerMinAggregateOutput = PlayerScalarAggregateOutput
PlayerMaxAggregateOutput = PlayerScalarAggregateOutput


class PlayerMaxAggregateInput(TypedDict, total=False):
    """Player input for aggregating by max"""
    id: bool
    ea_id: bool
    name: bool
    activeSystem: bool
    createdAt: bool
    updatedAt: bool


class PlayerMinAggregateInput(TypedDict, total=False):
    """Player input for aggregating by min"""
    id: bool
    ea_id: bool
    name: bool
    activeSystem: bool
    createdAt: bool
    updatedAt: bool


class PlayerNumberAggregateInput(TypedDict, total=False):
    """Player input for aggregating numbers"""


PlayerAvgAggregateInput = PlayerNumberAggregateInput
PlayerSumAggregateInput = PlayerNumberAggregateInput


PlayerCountAggregateInput = TypedDict(
    'PlayerCountAggregateInput',
    {
        'id': bool,
        'ea_id': bool,
        'name': bool,
        'activeSystem': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PlayerCountAggregateOutput = TypedDict(
    'PlayerCountAggregateOutput',
    {
        'id': int,
        'ea_id': int,
        'name': int,
        'activeSystem': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PlayerKeys = Literal[
    'id',
    'ea_id',
    'name',
    'activeSystem',
    'createdAt',
    'updatedAt',
    'user',
    'gamertags',
    'seasons',
]
PlayerScalarFieldKeys = Literal[
    'id',
    'ea_id',
    'name',
    'activeSystem',
    'createdAt',
    'updatedAt',
]
PlayerScalarFieldKeysT = TypeVar('PlayerScalarFieldKeysT', bound=PlayerScalarFieldKeys)

PlayerRelationalFieldKeys = Literal[
        'user',
        'gamertags',
        'seasons',
    ]

# GamertagHistory types

class GamertagHistoryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the GamertagHistory create method"""
    playerId: _str
    createdAt: datetime.datetime
    player: 'PlayerCreateNestedWithoutRelationsInput'


class GamertagHistoryCreateInput(GamertagHistoryOptionalCreateInput):
    """Required arguments to the GamertagHistory create method"""
    system: 'enums.System'
    gamertag: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GamertagHistoryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the GamertagHistory create method, without relations"""
    playerId: _str
    createdAt: datetime.datetime


class GamertagHistoryCreateWithoutRelationsInput(GamertagHistoryOptionalCreateWithoutRelationsInput):
    """Required arguments to the GamertagHistory create method, without relations"""
    system: 'enums.System'
    gamertag: _str

class GamertagHistoryConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'GamertagHistoryCreateWithoutRelationsInput'
    where: 'GamertagHistoryWhereUniqueInput'

class GamertagHistoryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GamertagHistoryCreateWithoutRelationsInput'
    connect: 'GamertagHistoryWhereUniqueInput'
    connect_or_create: 'GamertagHistoryConnectOrCreateWithoutRelationsInput'


class GamertagHistoryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GamertagHistoryCreateWithoutRelationsInput', List['GamertagHistoryCreateWithoutRelationsInput']]
    connect: Union['GamertagHistoryWhereUniqueInput', List['GamertagHistoryWhereUniqueInput']]
    connect_or_create: Union['GamertagHistoryConnectOrCreateWithoutRelationsInput', List['GamertagHistoryConnectOrCreateWithoutRelationsInput']]

_GamertagHistoryCompoundPrimaryKeyInner = TypedDict(
    '_GamertagHistoryCompoundPrimaryKeyInner',
    {
        'playerId': '_str',
        'system': 'enums.System',
    },
    total=True
)

_GamertagHistoryCompoundPrimaryKey = TypedDict(
    '_GamertagHistoryCompoundPrimaryKey',
    {
        'playerId_system': '_GamertagHistoryCompoundPrimaryKeyInner',
    },
    total=True
)

GamertagHistoryWhereUniqueInput = _GamertagHistoryCompoundPrimaryKey


class GamertagHistoryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    system: 'enums.System'
    gamertag: _str
    createdAt: datetime.datetime
    player: 'PlayerUpdateOneWithoutRelationsInput'


class GamertagHistoryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    system: 'enums.System'
    gamertag: _str
    createdAt: datetime.datetime


class GamertagHistoryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GamertagHistoryCreateWithoutRelationsInput']
    connect: List['GamertagHistoryWhereUniqueInput']
    connect_or_create: List['GamertagHistoryConnectOrCreateWithoutRelationsInput']
    set: List['GamertagHistoryWhereUniqueInput']
    disconnect: List['GamertagHistoryWhereUniqueInput']
    delete: List['GamertagHistoryWhereUniqueInput']

    # TODO
    # update: List['GamertagHistoryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GamertagHistoryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GamertagHistoryScalarWhereInput']
    # upsert: List['GamertagHistoryUpserteWithWhereUniqueWithoutRelationsInput']


class GamertagHistoryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GamertagHistoryCreateWithoutRelationsInput'
    connect: 'GamertagHistoryWhereUniqueInput'
    connect_or_create: 'GamertagHistoryConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GamertagHistoryUpdateInput'
    # upsert: 'GamertagHistoryUpsertWithoutRelationsInput'


class GamertagHistoryUpsertInput(TypedDict):
    create: 'GamertagHistoryCreateInput'
    update: 'GamertagHistoryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_GamertagHistory_playerId_OrderByInput = TypedDict(
    '_GamertagHistory_playerId_OrderByInput',
    {
        'playerId': 'SortOrder',
    },
    total=True
)

_GamertagHistory_system_OrderByInput = TypedDict(
    '_GamertagHistory_system_OrderByInput',
    {
        'system': 'SortOrder',
    },
    total=True
)

_GamertagHistory_gamertag_OrderByInput = TypedDict(
    '_GamertagHistory_gamertag_OrderByInput',
    {
        'gamertag': 'SortOrder',
    },
    total=True
)

_GamertagHistory_createdAt_OrderByInput = TypedDict(
    '_GamertagHistory_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_GamertagHistory_RelevanceInner = TypedDict(
    '_GamertagHistory_RelevanceInner',
    {
        'fields': 'List[GamertagHistoryScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_GamertagHistory_RelevanceOrderByInput = TypedDict(
    '_GamertagHistory_RelevanceOrderByInput',
    {
        '_relevance': '_GamertagHistory_RelevanceInner',
    },
    total=True
)

GamertagHistoryOrderByInput = Union[
    '_GamertagHistory_playerId_OrderByInput',
    '_GamertagHistory_system_OrderByInput',
    '_GamertagHistory_gamertag_OrderByInput',
    '_GamertagHistory_createdAt_OrderByInput',
    '_GamertagHistory_RelevanceOrderByInput',
]



# recursive GamertagHistory types
# TODO: cleanup these types



GamertagHistoryRelationFilter = TypedDict(
    'GamertagHistoryRelationFilter',
    {
        'is': 'GamertagHistoryWhereInput',
        'is_not': 'GamertagHistoryWhereInput',
    },
    total=False,
)


class GamertagHistoryListRelationFilter(TypedDict, total=False):
    some: 'GamertagHistoryWhereInput'
    none: 'GamertagHistoryWhereInput'
    every: 'GamertagHistoryWhereInput'


class GamertagHistoryInclude(TypedDict, total=False):
    """GamertagHistory relational arguments"""
    player: Union[bool, 'PlayerArgsFromGamertagHistory']


class UserIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    player: Union[bool, 'PlayerArgsFromGamertagHistory']
    notifications: Union[bool, 'FindManyNotificationArgsFromGamertagHistory']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromGamertagHistory']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromGamertagHistory']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromGamertagHistory']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromGamertagHistory']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromGamertagHistory']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromGamertagHistory']


class UserArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromGamertagHistory']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromGamertagHistory']


class PlayerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    player: Union[bool, 'PlayerArgsFromGamertagHistory']


class GamertagHistoryArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    tiers: Union[bool, 'FindManyTierArgsFromGamertagHistory']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromGamertagHistory']


class SeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    season: Union[bool, 'SeasonArgsFromGamertagHistory']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromGamertagHistory']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromGamertagHistory']


class TierArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromGamertagHistory']
    managers: Union[bool, 'FindManyTeamManagerArgsFromGamertagHistory']
    nhlAffiliate: Union[bool, 'TeamArgsFromGamertagHistory']
    ahlAffiliate: Union[bool, 'TeamArgsFromGamertagHistory']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromGamertagHistory']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromGamertagHistory']


class TeamArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    team: Union[bool, 'TeamArgsFromGamertagHistory']
    tier: Union[bool, 'TierArgsFromGamertagHistory']
    matches: Union[bool, 'FindManyMatchArgsFromGamertagHistory']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromGamertagHistory']
    bids: Union[bool, 'FindManyBidArgsFromGamertagHistory']


class TeamSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    player: Union[bool, 'PlayerArgsFromGamertagHistory']
    season: Union[bool, 'SeasonArgsFromGamertagHistory']
    contract: Union[bool, 'ContractArgsFromGamertagHistory']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromGamertagHistory']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromGamertagHistory']


class PlayerSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromGamertagHistory']
    tier: Union[bool, 'TierArgsFromGamertagHistory']


class PlayerTierHistoryArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromGamertagHistory']
    teamSeason: Union[bool, 'TeamSeasonArgsFromGamertagHistory']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromGamertagHistory']


class PlayerTeamSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromGamertagHistory']
    bids: Union[bool, 'FindManyBidArgsFromGamertagHistory']


class ContractArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    contract: Union[bool, 'ContractArgsFromGamertagHistory']
    teamSeason: Union[bool, 'TeamSeasonArgsFromGamertagHistory']


class BidArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromGamertagHistory']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromGamertagHistory']


class MatchArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    match: Union[bool, 'MatchArgsFromGamertagHistory']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromGamertagHistory']


class PlayerMatchArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']


class NotificationArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    author: Union[bool, 'UserArgsFromGamertagHistory']
    comments: Union[bool, 'FindManyForumCommentArgsFromGamertagHistory']
    reactions: Union[bool, 'FindManyForumReactionArgsFromGamertagHistory']
    followers: Union[bool, 'FindManyForumFollowerArgsFromGamertagHistory']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromGamertagHistory']


class ForumPostArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']
    post: Union[bool, 'ForumPostArgsFromGamertagHistory']
    comment: Union[bool, 'ForumCommentArgsFromGamertagHistory']


class ForumReactionArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']
    post: Union[bool, 'ForumPostArgsFromGamertagHistory']


class ForumFollowerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']
    post: Union[bool, 'ForumPostArgsFromGamertagHistory']


class ForumPostSubscriptionArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    author: Union[bool, 'UserArgsFromGamertagHistory']
    post: Union[bool, 'ForumPostArgsFromGamertagHistory']
    quotedComment: Union[bool, 'ForumCommentArgsFromGamertagHistory']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromGamertagHistory']
    reactions: Union[bool, 'FindManyForumReactionArgsFromGamertagHistory']


class ForumCommentArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromGamertagHistory(TypedDict, total=False):
    """Relational arguments for GamertagHistory"""
    user: Union[bool, 'UserArgsFromGamertagHistory']
    team: Union[bool, 'TeamArgsFromGamertagHistory']


class TeamManagerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromGamertagHistory(TypedDict, total=False):
    """Arguments for GamertagHistory"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyGamertagHistoryArgs = FindManyGamertagHistoryArgsFromGamertagHistory
FindFirstGamertagHistoryArgs = FindManyGamertagHistoryArgsFromGamertagHistory


class GamertagHistoryWhereInput(TypedDict, total=False):
    """GamertagHistory arguments for searching"""
    playerId: Union[_str, 'types.StringFilter']
    system: 'enums.System'
    gamertag: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    player: 'PlayerRelationFilter'

    # should be noted that AND and NOT should be Union['GamertagHistoryWhereInput', List['GamertagHistoryWhereInput']]
    # but this causes mypy to hang :/
    AND: List['GamertagHistoryWhereInput']
    OR: List['GamertagHistoryWhereInput']
    NOT: List['GamertagHistoryWhereInput']



# aggregate GamertagHistory types


class GamertagHistoryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """GamertagHistory arguments for searching"""
    playerId: Union[_str, 'types.StringWithAggregatesFilter']
    system: 'enums.System'
    gamertag: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['GamertagHistoryScalarWhereWithAggregatesInput']
    OR: List['GamertagHistoryScalarWhereWithAggregatesInput']
    NOT: List['GamertagHistoryScalarWhereWithAggregatesInput']



class GamertagHistoryGroupByOutput(TypedDict, total=False):
    playerId: _str
    system: 'enums.System'
    gamertag: _str
    createdAt: datetime.datetime
    _sum: 'GamertagHistorySumAggregateOutput'
    _avg: 'GamertagHistoryAvgAggregateOutput'
    _min: 'GamertagHistoryMinAggregateOutput'
    _max: 'GamertagHistoryMaxAggregateOutput'
    _count: 'GamertagHistoryCountAggregateOutput'


class GamertagHistoryAvgAggregateOutput(TypedDict, total=False):
    """GamertagHistory output for aggregating averages"""


class GamertagHistorySumAggregateOutput(TypedDict, total=False):
    """GamertagHistory output for aggregating sums"""


class GamertagHistoryScalarAggregateOutput(TypedDict, total=False):
    """GamertagHistory output including scalar fields"""
    playerId: _str
    system: 'enums.System'
    gamertag: _str
    createdAt: datetime.datetime


GamertagHistoryMinAggregateOutput = GamertagHistoryScalarAggregateOutput
GamertagHistoryMaxAggregateOutput = GamertagHistoryScalarAggregateOutput


class GamertagHistoryMaxAggregateInput(TypedDict, total=False):
    """GamertagHistory input for aggregating by max"""
    playerId: bool
    system: bool
    gamertag: bool
    createdAt: bool


class GamertagHistoryMinAggregateInput(TypedDict, total=False):
    """GamertagHistory input for aggregating by min"""
    playerId: bool
    system: bool
    gamertag: bool
    createdAt: bool


class GamertagHistoryNumberAggregateInput(TypedDict, total=False):
    """GamertagHistory input for aggregating numbers"""


GamertagHistoryAvgAggregateInput = GamertagHistoryNumberAggregateInput
GamertagHistorySumAggregateInput = GamertagHistoryNumberAggregateInput


GamertagHistoryCountAggregateInput = TypedDict(
    'GamertagHistoryCountAggregateInput',
    {
        'playerId': bool,
        'system': bool,
        'gamertag': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

GamertagHistoryCountAggregateOutput = TypedDict(
    'GamertagHistoryCountAggregateOutput',
    {
        'playerId': int,
        'system': int,
        'gamertag': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


GamertagHistoryKeys = Literal[
    'playerId',
    'system',
    'gamertag',
    'createdAt',
    'player',
]
GamertagHistoryScalarFieldKeys = Literal[
    'playerId',
    'system',
    'gamertag',
    'createdAt',
]
GamertagHistoryScalarFieldKeysT = TypeVar('GamertagHistoryScalarFieldKeysT', bound=GamertagHistoryScalarFieldKeys)

GamertagHistoryRelationalFieldKeys = Literal[
        'player',
    ]

# Season types

class SeasonOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Season create method"""
    id: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tiers: 'TierCreateManyNestedWithoutRelationsInput'
    players: 'PlayerSeasonCreateManyNestedWithoutRelationsInput'


class SeasonCreateInput(SeasonOptionalCreateInput):
    """Required arguments to the Season create method"""
    seasonId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SeasonOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Season create method, without relations"""
    id: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SeasonCreateWithoutRelationsInput(SeasonOptionalCreateWithoutRelationsInput):
    """Required arguments to the Season create method, without relations"""
    seasonId: _str

class SeasonConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SeasonCreateWithoutRelationsInput'
    where: 'SeasonWhereUniqueInput'

class SeasonCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SeasonCreateWithoutRelationsInput'
    connect: 'SeasonWhereUniqueInput'
    connect_or_create: 'SeasonConnectOrCreateWithoutRelationsInput'


class SeasonCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SeasonCreateWithoutRelationsInput', List['SeasonCreateWithoutRelationsInput']]
    connect: Union['SeasonWhereUniqueInput', List['SeasonWhereUniqueInput']]
    connect_or_create: Union['SeasonConnectOrCreateWithoutRelationsInput', List['SeasonConnectOrCreateWithoutRelationsInput']]

_SeasonWhereUnique_id_Input = TypedDict(
    '_SeasonWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

SeasonWhereUniqueInput = _SeasonWhereUnique_id_Input


class SeasonUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    seasonId: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tiers: 'TierUpdateManyWithoutRelationsInput'
    players: 'PlayerSeasonUpdateManyWithoutRelationsInput'


class SeasonUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    seasonId: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SeasonUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SeasonCreateWithoutRelationsInput']
    connect: List['SeasonWhereUniqueInput']
    connect_or_create: List['SeasonConnectOrCreateWithoutRelationsInput']
    set: List['SeasonWhereUniqueInput']
    disconnect: List['SeasonWhereUniqueInput']
    delete: List['SeasonWhereUniqueInput']

    # TODO
    # update: List['SeasonUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SeasonUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SeasonScalarWhereInput']
    # upsert: List['SeasonUpserteWithWhereUniqueWithoutRelationsInput']


class SeasonUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SeasonCreateWithoutRelationsInput'
    connect: 'SeasonWhereUniqueInput'
    connect_or_create: 'SeasonConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SeasonUpdateInput'
    # upsert: 'SeasonUpsertWithoutRelationsInput'


class SeasonUpsertInput(TypedDict):
    create: 'SeasonCreateInput'
    update: 'SeasonUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Season_id_OrderByInput = TypedDict(
    '_Season_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Season_seasonId_OrderByInput = TypedDict(
    '_Season_seasonId_OrderByInput',
    {
        'seasonId': 'SortOrder',
    },
    total=True
)

_Season_isLatest_OrderByInput = TypedDict(
    '_Season_isLatest_OrderByInput',
    {
        'isLatest': 'SortOrder',
    },
    total=True
)

_Season_createdAt_OrderByInput = TypedDict(
    '_Season_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Season_updatedAt_OrderByInput = TypedDict(
    '_Season_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Season_RelevanceInner = TypedDict(
    '_Season_RelevanceInner',
    {
        'fields': 'List[SeasonScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Season_RelevanceOrderByInput = TypedDict(
    '_Season_RelevanceOrderByInput',
    {
        '_relevance': '_Season_RelevanceInner',
    },
    total=True
)

SeasonOrderByInput = Union[
    '_Season_id_OrderByInput',
    '_Season_seasonId_OrderByInput',
    '_Season_isLatest_OrderByInput',
    '_Season_createdAt_OrderByInput',
    '_Season_updatedAt_OrderByInput',
    '_Season_RelevanceOrderByInput',
]



# recursive Season types
# TODO: cleanup these types



SeasonRelationFilter = TypedDict(
    'SeasonRelationFilter',
    {
        'is': 'SeasonWhereInput',
        'is_not': 'SeasonWhereInput',
    },
    total=False,
)


class SeasonListRelationFilter(TypedDict, total=False):
    some: 'SeasonWhereInput'
    none: 'SeasonWhereInput'
    every: 'SeasonWhereInput'


class SeasonInclude(TypedDict, total=False):
    """Season relational arguments"""
    tiers: Union[bool, 'FindManyTierArgsFromSeason']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromSeason']


class UserIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    player: Union[bool, 'PlayerArgsFromSeason']
    notifications: Union[bool, 'FindManyNotificationArgsFromSeason']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromSeason']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromSeason']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromSeason']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromSeason']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromSeason']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromSeason']


class UserArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromSeason']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromSeason']


class PlayerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    player: Union[bool, 'PlayerArgsFromSeason']


class GamertagHistoryArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    tiers: Union[bool, 'FindManyTierArgsFromSeason']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromSeason']


class SeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    season: Union[bool, 'SeasonArgsFromSeason']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromSeason']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromSeason']


class TierArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromSeason']
    managers: Union[bool, 'FindManyTeamManagerArgsFromSeason']
    nhlAffiliate: Union[bool, 'TeamArgsFromSeason']
    ahlAffiliate: Union[bool, 'TeamArgsFromSeason']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromSeason']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromSeason']


class TeamArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    team: Union[bool, 'TeamArgsFromSeason']
    tier: Union[bool, 'TierArgsFromSeason']
    matches: Union[bool, 'FindManyMatchArgsFromSeason']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromSeason']
    bids: Union[bool, 'FindManyBidArgsFromSeason']


class TeamSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    player: Union[bool, 'PlayerArgsFromSeason']
    season: Union[bool, 'SeasonArgsFromSeason']
    contract: Union[bool, 'ContractArgsFromSeason']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromSeason']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromSeason']


class PlayerSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromSeason']
    tier: Union[bool, 'TierArgsFromSeason']


class PlayerTierHistoryArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromSeason']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromSeason']


class PlayerTeamSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromSeason']
    bids: Union[bool, 'FindManyBidArgsFromSeason']


class ContractArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    contract: Union[bool, 'ContractArgsFromSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromSeason']


class BidArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromSeason']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromSeason']


class MatchArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    match: Union[bool, 'MatchArgsFromSeason']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromSeason']


class PlayerMatchArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']


class NotificationArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    author: Union[bool, 'UserArgsFromSeason']
    comments: Union[bool, 'FindManyForumCommentArgsFromSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromSeason']
    followers: Union[bool, 'FindManyForumFollowerArgsFromSeason']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromSeason']


class ForumPostArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']
    post: Union[bool, 'ForumPostArgsFromSeason']
    comment: Union[bool, 'ForumCommentArgsFromSeason']


class ForumReactionArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']
    post: Union[bool, 'ForumPostArgsFromSeason']


class ForumFollowerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']
    post: Union[bool, 'ForumPostArgsFromSeason']


class ForumPostSubscriptionArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    author: Union[bool, 'UserArgsFromSeason']
    post: Union[bool, 'ForumPostArgsFromSeason']
    quotedComment: Union[bool, 'ForumCommentArgsFromSeason']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromSeason']


class ForumCommentArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromSeason(TypedDict, total=False):
    """Relational arguments for Season"""
    user: Union[bool, 'UserArgsFromSeason']
    team: Union[bool, 'TeamArgsFromSeason']


class TeamManagerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromSeason(TypedDict, total=False):
    """Arguments for Season"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManySeasonArgs = FindManySeasonArgsFromSeason
FindFirstSeasonArgs = FindManySeasonArgsFromSeason


class SeasonWhereInput(TypedDict, total=False):
    """Season arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    seasonId: Union[_str, 'types.StringFilter']
    isLatest: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    tiers: 'TierListRelationFilter'
    players: 'PlayerSeasonListRelationFilter'

    # should be noted that AND and NOT should be Union['SeasonWhereInput', List['SeasonWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SeasonWhereInput']
    OR: List['SeasonWhereInput']
    NOT: List['SeasonWhereInput']



# aggregate Season types


class SeasonScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Season arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    seasonId: Union[_str, 'types.StringWithAggregatesFilter']
    isLatest: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SeasonScalarWhereWithAggregatesInput']
    OR: List['SeasonScalarWhereWithAggregatesInput']
    NOT: List['SeasonScalarWhereWithAggregatesInput']



class SeasonGroupByOutput(TypedDict, total=False):
    id: _str
    seasonId: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'SeasonSumAggregateOutput'
    _avg: 'SeasonAvgAggregateOutput'
    _min: 'SeasonMinAggregateOutput'
    _max: 'SeasonMaxAggregateOutput'
    _count: 'SeasonCountAggregateOutput'


class SeasonAvgAggregateOutput(TypedDict, total=False):
    """Season output for aggregating averages"""


class SeasonSumAggregateOutput(TypedDict, total=False):
    """Season output for aggregating sums"""


class SeasonScalarAggregateOutput(TypedDict, total=False):
    """Season output including scalar fields"""
    id: _str
    seasonId: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


SeasonMinAggregateOutput = SeasonScalarAggregateOutput
SeasonMaxAggregateOutput = SeasonScalarAggregateOutput


class SeasonMaxAggregateInput(TypedDict, total=False):
    """Season input for aggregating by max"""
    id: bool
    seasonId: bool
    isLatest: bool
    createdAt: bool
    updatedAt: bool


class SeasonMinAggregateInput(TypedDict, total=False):
    """Season input for aggregating by min"""
    id: bool
    seasonId: bool
    isLatest: bool
    createdAt: bool
    updatedAt: bool


class SeasonNumberAggregateInput(TypedDict, total=False):
    """Season input for aggregating numbers"""


SeasonAvgAggregateInput = SeasonNumberAggregateInput
SeasonSumAggregateInput = SeasonNumberAggregateInput


SeasonCountAggregateInput = TypedDict(
    'SeasonCountAggregateInput',
    {
        'id': bool,
        'seasonId': bool,
        'isLatest': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

SeasonCountAggregateOutput = TypedDict(
    'SeasonCountAggregateOutput',
    {
        'id': int,
        'seasonId': int,
        'isLatest': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


SeasonKeys = Literal[
    'id',
    'seasonId',
    'isLatest',
    'createdAt',
    'updatedAt',
    'tiers',
    'players',
]
SeasonScalarFieldKeys = Literal[
    'id',
    'seasonId',
    'isLatest',
    'createdAt',
    'updatedAt',
]
SeasonScalarFieldKeysT = TypeVar('SeasonScalarFieldKeysT', bound=SeasonScalarFieldKeys)

SeasonRelationalFieldKeys = Literal[
        'tiers',
        'players',
    ]

# Tier types

class TierOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tier create method"""
    id: _str
    seasonId: _str
    salaryCap: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    season: 'SeasonCreateNestedWithoutRelationsInput'
    teams: 'TeamSeasonCreateManyNestedWithoutRelationsInput'
    playerHistory: 'PlayerTierHistoryCreateManyNestedWithoutRelationsInput'


class TierCreateInput(TierOptionalCreateInput):
    """Required arguments to the Tier create method"""
    leagueLevel: _int
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TierOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tier create method, without relations"""
    id: _str
    seasonId: _str
    salaryCap: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TierCreateWithoutRelationsInput(TierOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tier create method, without relations"""
    leagueLevel: _int
    name: _str

class TierConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TierCreateWithoutRelationsInput'
    where: 'TierWhereUniqueInput'

class TierCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TierCreateWithoutRelationsInput'
    connect: 'TierWhereUniqueInput'
    connect_or_create: 'TierConnectOrCreateWithoutRelationsInput'


class TierCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TierCreateWithoutRelationsInput', List['TierCreateWithoutRelationsInput']]
    connect: Union['TierWhereUniqueInput', List['TierWhereUniqueInput']]
    connect_or_create: Union['TierConnectOrCreateWithoutRelationsInput', List['TierConnectOrCreateWithoutRelationsInput']]

_TierWhereUnique_id_Input = TypedDict(
    '_TierWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TierWhereUniqueInput = _TierWhereUnique_id_Input


class TierUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    leagueLevel: Union[AtomicIntInput, _int]
    name: _str
    salaryCap: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    season: 'SeasonUpdateOneWithoutRelationsInput'
    teams: 'TeamSeasonUpdateManyWithoutRelationsInput'
    playerHistory: 'PlayerTierHistoryUpdateManyWithoutRelationsInput'


class TierUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    leagueLevel: Union[AtomicIntInput, _int]
    name: _str
    salaryCap: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TierUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TierCreateWithoutRelationsInput']
    connect: List['TierWhereUniqueInput']
    connect_or_create: List['TierConnectOrCreateWithoutRelationsInput']
    set: List['TierWhereUniqueInput']
    disconnect: List['TierWhereUniqueInput']
    delete: List['TierWhereUniqueInput']

    # TODO
    # update: List['TierUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TierUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TierScalarWhereInput']
    # upsert: List['TierUpserteWithWhereUniqueWithoutRelationsInput']


class TierUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TierCreateWithoutRelationsInput'
    connect: 'TierWhereUniqueInput'
    connect_or_create: 'TierConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TierUpdateInput'
    # upsert: 'TierUpsertWithoutRelationsInput'


class TierUpsertInput(TypedDict):
    create: 'TierCreateInput'
    update: 'TierUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tier_id_OrderByInput = TypedDict(
    '_Tier_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tier_seasonId_OrderByInput = TypedDict(
    '_Tier_seasonId_OrderByInput',
    {
        'seasonId': 'SortOrder',
    },
    total=True
)

_Tier_leagueLevel_OrderByInput = TypedDict(
    '_Tier_leagueLevel_OrderByInput',
    {
        'leagueLevel': 'SortOrder',
    },
    total=True
)

_Tier_name_OrderByInput = TypedDict(
    '_Tier_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Tier_salaryCap_OrderByInput = TypedDict(
    '_Tier_salaryCap_OrderByInput',
    {
        'salaryCap': 'SortOrder',
    },
    total=True
)

_Tier_createdAt_OrderByInput = TypedDict(
    '_Tier_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tier_updatedAt_OrderByInput = TypedDict(
    '_Tier_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tier_RelevanceInner = TypedDict(
    '_Tier_RelevanceInner',
    {
        'fields': 'List[TierScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tier_RelevanceOrderByInput = TypedDict(
    '_Tier_RelevanceOrderByInput',
    {
        '_relevance': '_Tier_RelevanceInner',
    },
    total=True
)

TierOrderByInput = Union[
    '_Tier_id_OrderByInput',
    '_Tier_seasonId_OrderByInput',
    '_Tier_leagueLevel_OrderByInput',
    '_Tier_name_OrderByInput',
    '_Tier_salaryCap_OrderByInput',
    '_Tier_createdAt_OrderByInput',
    '_Tier_updatedAt_OrderByInput',
    '_Tier_RelevanceOrderByInput',
]



# recursive Tier types
# TODO: cleanup these types



TierRelationFilter = TypedDict(
    'TierRelationFilter',
    {
        'is': 'TierWhereInput',
        'is_not': 'TierWhereInput',
    },
    total=False,
)


class TierListRelationFilter(TypedDict, total=False):
    some: 'TierWhereInput'
    none: 'TierWhereInput'
    every: 'TierWhereInput'


class TierInclude(TypedDict, total=False):
    """Tier relational arguments"""
    season: Union[bool, 'SeasonArgsFromTier']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromTier']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTier']


class UserIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    player: Union[bool, 'PlayerArgsFromTier']
    notifications: Union[bool, 'FindManyNotificationArgsFromTier']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromTier']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromTier']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromTier']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromTier']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromTier']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromTier']


class UserArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromTier']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromTier']


class PlayerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    player: Union[bool, 'PlayerArgsFromTier']


class GamertagHistoryArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    tiers: Union[bool, 'FindManyTierArgsFromTier']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromTier']


class SeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    season: Union[bool, 'SeasonArgsFromTier']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromTier']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTier']


class TierArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromTier']
    managers: Union[bool, 'FindManyTeamManagerArgsFromTier']
    nhlAffiliate: Union[bool, 'TeamArgsFromTier']
    ahlAffiliate: Union[bool, 'TeamArgsFromTier']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromTier']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromTier']


class TeamArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    team: Union[bool, 'TeamArgsFromTier']
    tier: Union[bool, 'TierArgsFromTier']
    matches: Union[bool, 'FindManyMatchArgsFromTier']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTier']
    bids: Union[bool, 'FindManyBidArgsFromTier']


class TeamSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    player: Union[bool, 'PlayerArgsFromTier']
    season: Union[bool, 'SeasonArgsFromTier']
    contract: Union[bool, 'ContractArgsFromTier']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTier']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTier']


class PlayerSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTier']
    tier: Union[bool, 'TierArgsFromTier']


class PlayerTierHistoryArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTier']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTier']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromTier']


class PlayerTeamSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTier']
    bids: Union[bool, 'FindManyBidArgsFromTier']


class ContractArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    contract: Union[bool, 'ContractArgsFromTier']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTier']


class BidArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromTier']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromTier']


class MatchArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    match: Union[bool, 'MatchArgsFromTier']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromTier']


class PlayerMatchArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']


class NotificationArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    author: Union[bool, 'UserArgsFromTier']
    comments: Union[bool, 'FindManyForumCommentArgsFromTier']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTier']
    followers: Union[bool, 'FindManyForumFollowerArgsFromTier']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromTier']


class ForumPostArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']
    post: Union[bool, 'ForumPostArgsFromTier']
    comment: Union[bool, 'ForumCommentArgsFromTier']


class ForumReactionArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']
    post: Union[bool, 'ForumPostArgsFromTier']


class ForumFollowerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']
    post: Union[bool, 'ForumPostArgsFromTier']


class ForumPostSubscriptionArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    author: Union[bool, 'UserArgsFromTier']
    post: Union[bool, 'ForumPostArgsFromTier']
    quotedComment: Union[bool, 'ForumCommentArgsFromTier']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromTier']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTier']


class ForumCommentArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromTier(TypedDict, total=False):
    """Relational arguments for Tier"""
    user: Union[bool, 'UserArgsFromTier']
    team: Union[bool, 'TeamArgsFromTier']


class TeamManagerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromTier(TypedDict, total=False):
    """Arguments for Tier"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyTierArgs = FindManyTierArgsFromTier
FindFirstTierArgs = FindManyTierArgsFromTier


class TierWhereInput(TypedDict, total=False):
    """Tier arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    seasonId: Union[_str, 'types.StringFilter']
    leagueLevel: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    salaryCap: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    season: 'SeasonRelationFilter'
    teams: 'TeamSeasonListRelationFilter'
    playerHistory: 'PlayerTierHistoryListRelationFilter'

    # should be noted that AND and NOT should be Union['TierWhereInput', List['TierWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TierWhereInput']
    OR: List['TierWhereInput']
    NOT: List['TierWhereInput']



# aggregate Tier types


class TierScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tier arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    seasonId: Union[_str, 'types.StringWithAggregatesFilter']
    leagueLevel: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    salaryCap: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TierScalarWhereWithAggregatesInput']
    OR: List['TierScalarWhereWithAggregatesInput']
    NOT: List['TierScalarWhereWithAggregatesInput']



class TierGroupByOutput(TypedDict, total=False):
    id: _str
    seasonId: _str
    leagueLevel: _int
    name: _str
    salaryCap: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'TierSumAggregateOutput'
    _avg: 'TierAvgAggregateOutput'
    _min: 'TierMinAggregateOutput'
    _max: 'TierMaxAggregateOutput'
    _count: 'TierCountAggregateOutput'


class TierAvgAggregateOutput(TypedDict, total=False):
    """Tier output for aggregating averages"""
    leagueLevel: float
    salaryCap: float


class TierSumAggregateOutput(TypedDict, total=False):
    """Tier output for aggregating sums"""
    leagueLevel: _int
    salaryCap: _int


class TierScalarAggregateOutput(TypedDict, total=False):
    """Tier output including scalar fields"""
    id: _str
    seasonId: _str
    leagueLevel: _int
    name: _str
    salaryCap: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


TierMinAggregateOutput = TierScalarAggregateOutput
TierMaxAggregateOutput = TierScalarAggregateOutput


class TierMaxAggregateInput(TypedDict, total=False):
    """Tier input for aggregating by max"""
    id: bool
    seasonId: bool
    leagueLevel: bool
    name: bool
    salaryCap: bool
    createdAt: bool
    updatedAt: bool


class TierMinAggregateInput(TypedDict, total=False):
    """Tier input for aggregating by min"""
    id: bool
    seasonId: bool
    leagueLevel: bool
    name: bool
    salaryCap: bool
    createdAt: bool
    updatedAt: bool


class TierNumberAggregateInput(TypedDict, total=False):
    """Tier input for aggregating numbers"""
    leagueLevel: bool
    salaryCap: bool


TierAvgAggregateInput = TierNumberAggregateInput
TierSumAggregateInput = TierNumberAggregateInput


TierCountAggregateInput = TypedDict(
    'TierCountAggregateInput',
    {
        'id': bool,
        'seasonId': bool,
        'leagueLevel': bool,
        'name': bool,
        'salaryCap': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

TierCountAggregateOutput = TypedDict(
    'TierCountAggregateOutput',
    {
        'id': int,
        'seasonId': int,
        'leagueLevel': int,
        'name': int,
        'salaryCap': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


TierKeys = Literal[
    'id',
    'seasonId',
    'leagueLevel',
    'name',
    'salaryCap',
    'createdAt',
    'updatedAt',
    'season',
    'teams',
    'playerHistory',
]
TierScalarFieldKeys = Literal[
    'id',
    'seasonId',
    'leagueLevel',
    'name',
    'salaryCap',
    'createdAt',
    'updatedAt',
]
TierScalarFieldKeysT = TypeVar('TierScalarFieldKeysT', bound=TierScalarFieldKeys)

TierRelationalFieldKeys = Literal[
        'season',
        'teams',
        'playerHistory',
    ]

# Team types

class TeamOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Team create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    seasons: 'TeamSeasonCreateManyNestedWithoutRelationsInput'
    managers: 'TeamManagerCreateManyNestedWithoutRelationsInput'
    nhlAffiliateId: Optional[_str]
    ahlAffiliateId: Optional[_str]
    nhlAffiliate: 'TeamCreateNestedWithoutRelationsInput'
    ahlAffiliate: 'TeamCreateNestedWithoutRelationsInput'
    ahlAffiliates: 'TeamCreateManyNestedWithoutRelationsInput'
    echlAffiliates: 'TeamCreateManyNestedWithoutRelationsInput'


class TeamCreateInput(TeamOptionalCreateInput):
    """Required arguments to the Team create method"""
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Team create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    nhlAffiliateId: Optional[_str]
    ahlAffiliateId: Optional[_str]


class TeamCreateWithoutRelationsInput(TeamOptionalCreateWithoutRelationsInput):
    """Required arguments to the Team create method, without relations"""
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str

class TeamConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeamCreateWithoutRelationsInput'
    where: 'TeamWhereUniqueInput'

class TeamCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    connect_or_create: 'TeamConnectOrCreateWithoutRelationsInput'


class TeamCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamCreateWithoutRelationsInput', List['TeamCreateWithoutRelationsInput']]
    connect: Union['TeamWhereUniqueInput', List['TeamWhereUniqueInput']]
    connect_or_create: Union['TeamConnectOrCreateWithoutRelationsInput', List['TeamConnectOrCreateWithoutRelationsInput']]

_TeamWhereUnique_id_Input = TypedDict(
    '_TeamWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_TeamWhereUnique_teamIdentifier_Input = TypedDict(
    '_TeamWhereUnique_teamIdentifier_Input',
    {
        'teamIdentifier': '_str',
    },
    total=True
)

TeamWhereUniqueInput = Union[
    '_TeamWhereUnique_id_Input',
    '_TeamWhereUnique_teamIdentifier_Input',
]


class TeamUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    seasons: 'TeamSeasonUpdateManyWithoutRelationsInput'
    managers: 'TeamManagerUpdateManyWithoutRelationsInput'
    nhlAffiliate: 'TeamUpdateOneWithoutRelationsInput'
    ahlAffiliate: 'TeamUpdateOneWithoutRelationsInput'
    ahlAffiliates: 'TeamUpdateManyWithoutRelationsInput'
    echlAffiliates: 'TeamUpdateManyWithoutRelationsInput'


class TeamUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TeamUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamCreateWithoutRelationsInput']
    connect: List['TeamWhereUniqueInput']
    connect_or_create: List['TeamConnectOrCreateWithoutRelationsInput']
    set: List['TeamWhereUniqueInput']
    disconnect: List['TeamWhereUniqueInput']
    delete: List['TeamWhereUniqueInput']

    # TODO
    # update: List['TeamUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamScalarWhereInput']
    # upsert: List['TeamUpserteWithWhereUniqueWithoutRelationsInput']


class TeamUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    connect_or_create: 'TeamConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamUpdateInput'
    # upsert: 'TeamUpsertWithoutRelationsInput'


class TeamUpsertInput(TypedDict):
    create: 'TeamCreateInput'
    update: 'TeamUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Team_id_OrderByInput = TypedDict(
    '_Team_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Team_eaClubId_OrderByInput = TypedDict(
    '_Team_eaClubId_OrderByInput',
    {
        'eaClubId': 'SortOrder',
    },
    total=True
)

_Team_eaClubName_OrderByInput = TypedDict(
    '_Team_eaClubName_OrderByInput',
    {
        'eaClubName': 'SortOrder',
    },
    total=True
)

_Team_officialName_OrderByInput = TypedDict(
    '_Team_officialName_OrderByInput',
    {
        'officialName': 'SortOrder',
    },
    total=True
)

_Team_teamIdentifier_OrderByInput = TypedDict(
    '_Team_teamIdentifier_OrderByInput',
    {
        'teamIdentifier': 'SortOrder',
    },
    total=True
)

_Team_createdAt_OrderByInput = TypedDict(
    '_Team_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Team_updatedAt_OrderByInput = TypedDict(
    '_Team_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Team_nhlAffiliateId_OrderByInput = TypedDict(
    '_Team_nhlAffiliateId_OrderByInput',
    {
        'nhlAffiliateId': 'SortOrder',
    },
    total=True
)

_Team_ahlAffiliateId_OrderByInput = TypedDict(
    '_Team_ahlAffiliateId_OrderByInput',
    {
        'ahlAffiliateId': 'SortOrder',
    },
    total=True
)

_Team_RelevanceInner = TypedDict(
    '_Team_RelevanceInner',
    {
        'fields': 'List[TeamScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Team_RelevanceOrderByInput = TypedDict(
    '_Team_RelevanceOrderByInput',
    {
        '_relevance': '_Team_RelevanceInner',
    },
    total=True
)

TeamOrderByInput = Union[
    '_Team_id_OrderByInput',
    '_Team_eaClubId_OrderByInput',
    '_Team_eaClubName_OrderByInput',
    '_Team_officialName_OrderByInput',
    '_Team_teamIdentifier_OrderByInput',
    '_Team_createdAt_OrderByInput',
    '_Team_updatedAt_OrderByInput',
    '_Team_nhlAffiliateId_OrderByInput',
    '_Team_ahlAffiliateId_OrderByInput',
    '_Team_RelevanceOrderByInput',
]



# recursive Team types
# TODO: cleanup these types



TeamRelationFilter = TypedDict(
    'TeamRelationFilter',
    {
        'is': 'TeamWhereInput',
        'is_not': 'TeamWhereInput',
    },
    total=False,
)


class TeamListRelationFilter(TypedDict, total=False):
    some: 'TeamWhereInput'
    none: 'TeamWhereInput'
    every: 'TeamWhereInput'


class TeamInclude(TypedDict, total=False):
    """Team relational arguments"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromTeam']
    managers: Union[bool, 'FindManyTeamManagerArgsFromTeam']
    nhlAffiliate: Union[bool, 'TeamArgsFromTeam']
    ahlAffiliate: Union[bool, 'TeamArgsFromTeam']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromTeam']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromTeam']


class UserIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    player: Union[bool, 'PlayerArgsFromTeam']
    notifications: Union[bool, 'FindManyNotificationArgsFromTeam']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromTeam']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromTeam']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromTeam']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromTeam']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeam']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromTeam']


class UserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromTeam']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromTeam']


class PlayerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    player: Union[bool, 'PlayerArgsFromTeam']


class GamertagHistoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tiers: Union[bool, 'FindManyTierArgsFromTeam']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromTeam']


class SeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    season: Union[bool, 'SeasonArgsFromTeam']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromTeam']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeam']


class TierArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromTeam']
    managers: Union[bool, 'FindManyTeamManagerArgsFromTeam']
    nhlAffiliate: Union[bool, 'TeamArgsFromTeam']
    ahlAffiliate: Union[bool, 'TeamArgsFromTeam']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromTeam']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromTeam']


class TeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    team: Union[bool, 'TeamArgsFromTeam']
    tier: Union[bool, 'TierArgsFromTeam']
    matches: Union[bool, 'FindManyMatchArgsFromTeam']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeam']
    bids: Union[bool, 'FindManyBidArgsFromTeam']


class TeamSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    player: Union[bool, 'PlayerArgsFromTeam']
    season: Union[bool, 'SeasonArgsFromTeam']
    contract: Union[bool, 'ContractArgsFromTeam']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeam']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeam']


class PlayerSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeam']
    tier: Union[bool, 'TierArgsFromTeam']


class PlayerTierHistoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeam']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeam']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromTeam']


class PlayerTeamSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeam']
    bids: Union[bool, 'FindManyBidArgsFromTeam']


class ContractArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    contract: Union[bool, 'ContractArgsFromTeam']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeam']


class BidArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeam']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromTeam']


class MatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    match: Union[bool, 'MatchArgsFromTeam']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromTeam']


class PlayerMatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']


class NotificationArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    author: Union[bool, 'UserArgsFromTeam']
    comments: Union[bool, 'FindManyForumCommentArgsFromTeam']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeam']
    followers: Union[bool, 'FindManyForumFollowerArgsFromTeam']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeam']


class ForumPostArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']
    post: Union[bool, 'ForumPostArgsFromTeam']
    comment: Union[bool, 'ForumCommentArgsFromTeam']


class ForumReactionArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']
    post: Union[bool, 'ForumPostArgsFromTeam']


class ForumFollowerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']
    post: Union[bool, 'ForumPostArgsFromTeam']


class ForumPostSubscriptionArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    author: Union[bool, 'UserArgsFromTeam']
    post: Union[bool, 'ForumPostArgsFromTeam']
    quotedComment: Union[bool, 'ForumCommentArgsFromTeam']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromTeam']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeam']


class ForumCommentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeam']
    team: Union[bool, 'TeamArgsFromTeam']


class TeamManagerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyTeamArgs = FindManyTeamArgsFromTeam
FindFirstTeamArgs = FindManyTeamArgsFromTeam


class TeamWhereInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    eaClubId: Union[_str, 'types.StringFilter']
    eaClubName: Union[_str, 'types.StringFilter']
    officialName: Union[_str, 'types.StringFilter']
    teamIdentifier: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    seasons: 'TeamSeasonListRelationFilter'
    managers: 'TeamManagerListRelationFilter'
    nhlAffiliateId: Union[None, _str, 'types.StringFilter']
    ahlAffiliateId: Union[None, _str, 'types.StringFilter']
    nhlAffiliate: 'TeamRelationFilter'
    ahlAffiliate: 'TeamRelationFilter'
    ahlAffiliates: 'TeamListRelationFilter'
    echlAffiliates: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInput', List['TeamWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInput']
    OR: List['TeamWhereInput']
    NOT: List['TeamWhereInput']



# aggregate Team types


class TeamScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    eaClubId: Union[_str, 'types.StringWithAggregatesFilter']
    eaClubName: Union[_str, 'types.StringWithAggregatesFilter']
    officialName: Union[_str, 'types.StringWithAggregatesFilter']
    teamIdentifier: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    nhlAffiliateId: Union[_str, 'types.StringWithAggregatesFilter']
    ahlAffiliateId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInput']
    OR: List['TeamScalarWhereWithAggregatesInput']
    NOT: List['TeamScalarWhereWithAggregatesInput']



class TeamGroupByOutput(TypedDict, total=False):
    id: _str
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    nhlAffiliateId: _str
    ahlAffiliateId: _str
    _sum: 'TeamSumAggregateOutput'
    _avg: 'TeamAvgAggregateOutput'
    _min: 'TeamMinAggregateOutput'
    _max: 'TeamMaxAggregateOutput'
    _count: 'TeamCountAggregateOutput'


class TeamAvgAggregateOutput(TypedDict, total=False):
    """Team output for aggregating averages"""


class TeamSumAggregateOutput(TypedDict, total=False):
    """Team output for aggregating sums"""


class TeamScalarAggregateOutput(TypedDict, total=False):
    """Team output including scalar fields"""
    id: _str
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    nhlAffiliateId: _str
    ahlAffiliateId: _str


TeamMinAggregateOutput = TeamScalarAggregateOutput
TeamMaxAggregateOutput = TeamScalarAggregateOutput


class TeamMaxAggregateInput(TypedDict, total=False):
    """Team input for aggregating by max"""
    id: bool
    eaClubId: bool
    eaClubName: bool
    officialName: bool
    teamIdentifier: bool
    createdAt: bool
    updatedAt: bool
    nhlAffiliateId: bool
    ahlAffiliateId: bool


class TeamMinAggregateInput(TypedDict, total=False):
    """Team input for aggregating by min"""
    id: bool
    eaClubId: bool
    eaClubName: bool
    officialName: bool
    teamIdentifier: bool
    createdAt: bool
    updatedAt: bool
    nhlAffiliateId: bool
    ahlAffiliateId: bool


class TeamNumberAggregateInput(TypedDict, total=False):
    """Team input for aggregating numbers"""


TeamAvgAggregateInput = TeamNumberAggregateInput
TeamSumAggregateInput = TeamNumberAggregateInput


TeamCountAggregateInput = TypedDict(
    'TeamCountAggregateInput',
    {
        'id': bool,
        'eaClubId': bool,
        'eaClubName': bool,
        'officialName': bool,
        'teamIdentifier': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'nhlAffiliateId': bool,
        'ahlAffiliateId': bool,
        '_all': bool,
    },
    total=False,
)

TeamCountAggregateOutput = TypedDict(
    'TeamCountAggregateOutput',
    {
        'id': int,
        'eaClubId': int,
        'eaClubName': int,
        'officialName': int,
        'teamIdentifier': int,
        'createdAt': int,
        'updatedAt': int,
        'nhlAffiliateId': int,
        'ahlAffiliateId': int,
        '_all': int,
    },
    total=False,
)


TeamKeys = Literal[
    'id',
    'eaClubId',
    'eaClubName',
    'officialName',
    'teamIdentifier',
    'createdAt',
    'updatedAt',
    'seasons',
    'managers',
    'nhlAffiliateId',
    'ahlAffiliateId',
    'nhlAffiliate',
    'ahlAffiliate',
    'ahlAffiliates',
    'echlAffiliates',
]
TeamScalarFieldKeys = Literal[
    'id',
    'eaClubId',
    'eaClubName',
    'officialName',
    'teamIdentifier',
    'createdAt',
    'updatedAt',
    'nhlAffiliateId',
    'ahlAffiliateId',
]
TeamScalarFieldKeysT = TypeVar('TeamScalarFieldKeysT', bound=TeamScalarFieldKeys)

TeamRelationalFieldKeys = Literal[
        'seasons',
        'managers',
        'nhlAffiliate',
        'ahlAffiliate',
        'ahlAffiliates',
        'echlAffiliates',
    ]

# TeamSeason types

class TeamSeasonOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TeamSeason create method"""
    id: _str
    teamId: _str
    tierId: _str
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    team: 'TeamCreateNestedWithoutRelationsInput'
    tier: 'TierCreateNestedWithoutRelationsInput'
    matches: 'MatchCreateManyNestedWithoutRelationsInput'
    players: 'PlayerTeamSeasonCreateManyNestedWithoutRelationsInput'
    bids: 'BidCreateManyNestedWithoutRelationsInput'


class TeamSeasonCreateInput(TeamSeasonOptionalCreateInput):
    """Required arguments to the TeamSeason create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamSeasonOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TeamSeason create method, without relations"""
    id: _str
    teamId: _str
    tierId: _str
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TeamSeasonCreateWithoutRelationsInput(TeamSeasonOptionalCreateWithoutRelationsInput):
    """Required arguments to the TeamSeason create method, without relations"""

class TeamSeasonConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeamSeasonCreateWithoutRelationsInput'
    where: 'TeamSeasonWhereUniqueInput'

class TeamSeasonCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamSeasonCreateWithoutRelationsInput'
    connect: 'TeamSeasonWhereUniqueInput'
    connect_or_create: 'TeamSeasonConnectOrCreateWithoutRelationsInput'


class TeamSeasonCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamSeasonCreateWithoutRelationsInput', List['TeamSeasonCreateWithoutRelationsInput']]
    connect: Union['TeamSeasonWhereUniqueInput', List['TeamSeasonWhereUniqueInput']]
    connect_or_create: Union['TeamSeasonConnectOrCreateWithoutRelationsInput', List['TeamSeasonConnectOrCreateWithoutRelationsInput']]

_TeamSeasonWhereUnique_id_Input = TypedDict(
    '_TeamSeasonWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TeamSeasonWhereUniqueInput = _TeamSeasonWhereUnique_id_Input


class TeamSeasonUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    forwardCount: Union[AtomicIntInput, _int]
    defenseCount: Union[AtomicIntInput, _int]
    goalieCount: Union[AtomicIntInput, _int]
    wins: Union[AtomicIntInput, _int]
    losses: Union[AtomicIntInput, _int]
    otLosses: Union[AtomicIntInput, _int]
    goalsAgainst: Union[AtomicIntInput, _int]
    goalsFor: Union[AtomicIntInput, _int]
    matchesPlayed: Union[AtomicIntInput, _int]
    penaltyKillGoalsAgainst: Union[AtomicIntInput, _int]
    penaltyKillOpportunities: Union[AtomicIntInput, _int]
    powerplayGoals: Union[AtomicIntInput, _int]
    powerplayOpportunities: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    shotsAgainst: Union[AtomicIntInput, _int]
    timeOnAttack: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    team: 'TeamUpdateOneWithoutRelationsInput'
    tier: 'TierUpdateOneWithoutRelationsInput'
    matches: 'MatchUpdateManyWithoutRelationsInput'
    players: 'PlayerTeamSeasonUpdateManyWithoutRelationsInput'
    bids: 'BidUpdateManyWithoutRelationsInput'


class TeamSeasonUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    forwardCount: Union[AtomicIntInput, _int]
    defenseCount: Union[AtomicIntInput, _int]
    goalieCount: Union[AtomicIntInput, _int]
    wins: Union[AtomicIntInput, _int]
    losses: Union[AtomicIntInput, _int]
    otLosses: Union[AtomicIntInput, _int]
    goalsAgainst: Union[AtomicIntInput, _int]
    goalsFor: Union[AtomicIntInput, _int]
    matchesPlayed: Union[AtomicIntInput, _int]
    penaltyKillGoalsAgainst: Union[AtomicIntInput, _int]
    penaltyKillOpportunities: Union[AtomicIntInput, _int]
    powerplayGoals: Union[AtomicIntInput, _int]
    powerplayOpportunities: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    shotsAgainst: Union[AtomicIntInput, _int]
    timeOnAttack: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TeamSeasonUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamSeasonCreateWithoutRelationsInput']
    connect: List['TeamSeasonWhereUniqueInput']
    connect_or_create: List['TeamSeasonConnectOrCreateWithoutRelationsInput']
    set: List['TeamSeasonWhereUniqueInput']
    disconnect: List['TeamSeasonWhereUniqueInput']
    delete: List['TeamSeasonWhereUniqueInput']

    # TODO
    # update: List['TeamSeasonUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamSeasonUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamSeasonScalarWhereInput']
    # upsert: List['TeamSeasonUpserteWithWhereUniqueWithoutRelationsInput']


class TeamSeasonUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamSeasonCreateWithoutRelationsInput'
    connect: 'TeamSeasonWhereUniqueInput'
    connect_or_create: 'TeamSeasonConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamSeasonUpdateInput'
    # upsert: 'TeamSeasonUpsertWithoutRelationsInput'


class TeamSeasonUpsertInput(TypedDict):
    create: 'TeamSeasonCreateInput'
    update: 'TeamSeasonUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TeamSeason_id_OrderByInput = TypedDict(
    '_TeamSeason_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TeamSeason_teamId_OrderByInput = TypedDict(
    '_TeamSeason_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

_TeamSeason_tierId_OrderByInput = TypedDict(
    '_TeamSeason_tierId_OrderByInput',
    {
        'tierId': 'SortOrder',
    },
    total=True
)

_TeamSeason_forwardCount_OrderByInput = TypedDict(
    '_TeamSeason_forwardCount_OrderByInput',
    {
        'forwardCount': 'SortOrder',
    },
    total=True
)

_TeamSeason_defenseCount_OrderByInput = TypedDict(
    '_TeamSeason_defenseCount_OrderByInput',
    {
        'defenseCount': 'SortOrder',
    },
    total=True
)

_TeamSeason_goalieCount_OrderByInput = TypedDict(
    '_TeamSeason_goalieCount_OrderByInput',
    {
        'goalieCount': 'SortOrder',
    },
    total=True
)

_TeamSeason_wins_OrderByInput = TypedDict(
    '_TeamSeason_wins_OrderByInput',
    {
        'wins': 'SortOrder',
    },
    total=True
)

_TeamSeason_losses_OrderByInput = TypedDict(
    '_TeamSeason_losses_OrderByInput',
    {
        'losses': 'SortOrder',
    },
    total=True
)

_TeamSeason_otLosses_OrderByInput = TypedDict(
    '_TeamSeason_otLosses_OrderByInput',
    {
        'otLosses': 'SortOrder',
    },
    total=True
)

_TeamSeason_goalsAgainst_OrderByInput = TypedDict(
    '_TeamSeason_goalsAgainst_OrderByInput',
    {
        'goalsAgainst': 'SortOrder',
    },
    total=True
)

_TeamSeason_goalsFor_OrderByInput = TypedDict(
    '_TeamSeason_goalsFor_OrderByInput',
    {
        'goalsFor': 'SortOrder',
    },
    total=True
)

_TeamSeason_matchesPlayed_OrderByInput = TypedDict(
    '_TeamSeason_matchesPlayed_OrderByInput',
    {
        'matchesPlayed': 'SortOrder',
    },
    total=True
)

_TeamSeason_penaltyKillGoalsAgainst_OrderByInput = TypedDict(
    '_TeamSeason_penaltyKillGoalsAgainst_OrderByInput',
    {
        'penaltyKillGoalsAgainst': 'SortOrder',
    },
    total=True
)

_TeamSeason_penaltyKillOpportunities_OrderByInput = TypedDict(
    '_TeamSeason_penaltyKillOpportunities_OrderByInput',
    {
        'penaltyKillOpportunities': 'SortOrder',
    },
    total=True
)

_TeamSeason_powerplayGoals_OrderByInput = TypedDict(
    '_TeamSeason_powerplayGoals_OrderByInput',
    {
        'powerplayGoals': 'SortOrder',
    },
    total=True
)

_TeamSeason_powerplayOpportunities_OrderByInput = TypedDict(
    '_TeamSeason_powerplayOpportunities_OrderByInput',
    {
        'powerplayOpportunities': 'SortOrder',
    },
    total=True
)

_TeamSeason_shots_OrderByInput = TypedDict(
    '_TeamSeason_shots_OrderByInput',
    {
        'shots': 'SortOrder',
    },
    total=True
)

_TeamSeason_shotsAgainst_OrderByInput = TypedDict(
    '_TeamSeason_shotsAgainst_OrderByInput',
    {
        'shotsAgainst': 'SortOrder',
    },
    total=True
)

_TeamSeason_timeOnAttack_OrderByInput = TypedDict(
    '_TeamSeason_timeOnAttack_OrderByInput',
    {
        'timeOnAttack': 'SortOrder',
    },
    total=True
)

_TeamSeason_createdAt_OrderByInput = TypedDict(
    '_TeamSeason_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_TeamSeason_updatedAt_OrderByInput = TypedDict(
    '_TeamSeason_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_TeamSeason_RelevanceInner = TypedDict(
    '_TeamSeason_RelevanceInner',
    {
        'fields': 'List[TeamSeasonScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_TeamSeason_RelevanceOrderByInput = TypedDict(
    '_TeamSeason_RelevanceOrderByInput',
    {
        '_relevance': '_TeamSeason_RelevanceInner',
    },
    total=True
)

TeamSeasonOrderByInput = Union[
    '_TeamSeason_id_OrderByInput',
    '_TeamSeason_teamId_OrderByInput',
    '_TeamSeason_tierId_OrderByInput',
    '_TeamSeason_forwardCount_OrderByInput',
    '_TeamSeason_defenseCount_OrderByInput',
    '_TeamSeason_goalieCount_OrderByInput',
    '_TeamSeason_wins_OrderByInput',
    '_TeamSeason_losses_OrderByInput',
    '_TeamSeason_otLosses_OrderByInput',
    '_TeamSeason_goalsAgainst_OrderByInput',
    '_TeamSeason_goalsFor_OrderByInput',
    '_TeamSeason_matchesPlayed_OrderByInput',
    '_TeamSeason_penaltyKillGoalsAgainst_OrderByInput',
    '_TeamSeason_penaltyKillOpportunities_OrderByInput',
    '_TeamSeason_powerplayGoals_OrderByInput',
    '_TeamSeason_powerplayOpportunities_OrderByInput',
    '_TeamSeason_shots_OrderByInput',
    '_TeamSeason_shotsAgainst_OrderByInput',
    '_TeamSeason_timeOnAttack_OrderByInput',
    '_TeamSeason_createdAt_OrderByInput',
    '_TeamSeason_updatedAt_OrderByInput',
    '_TeamSeason_RelevanceOrderByInput',
]



# recursive TeamSeason types
# TODO: cleanup these types



TeamSeasonRelationFilter = TypedDict(
    'TeamSeasonRelationFilter',
    {
        'is': 'TeamSeasonWhereInput',
        'is_not': 'TeamSeasonWhereInput',
    },
    total=False,
)


class TeamSeasonListRelationFilter(TypedDict, total=False):
    some: 'TeamSeasonWhereInput'
    none: 'TeamSeasonWhereInput'
    every: 'TeamSeasonWhereInput'


class TeamSeasonInclude(TypedDict, total=False):
    """TeamSeason relational arguments"""
    team: Union[bool, 'TeamArgsFromTeamSeason']
    tier: Union[bool, 'TierArgsFromTeamSeason']
    matches: Union[bool, 'FindManyMatchArgsFromTeamSeason']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeamSeason']
    bids: Union[bool, 'FindManyBidArgsFromTeamSeason']


class UserIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    player: Union[bool, 'PlayerArgsFromTeamSeason']
    notifications: Union[bool, 'FindManyNotificationArgsFromTeamSeason']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromTeamSeason']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromTeamSeason']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromTeamSeason']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromTeamSeason']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeamSeason']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromTeamSeason']


class UserArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromTeamSeason']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromTeamSeason']


class PlayerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    player: Union[bool, 'PlayerArgsFromTeamSeason']


class GamertagHistoryArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    tiers: Union[bool, 'FindManyTierArgsFromTeamSeason']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromTeamSeason']


class SeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    season: Union[bool, 'SeasonArgsFromTeamSeason']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromTeamSeason']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeamSeason']


class TierArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromTeamSeason']
    managers: Union[bool, 'FindManyTeamManagerArgsFromTeamSeason']
    nhlAffiliate: Union[bool, 'TeamArgsFromTeamSeason']
    ahlAffiliate: Union[bool, 'TeamArgsFromTeamSeason']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromTeamSeason']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromTeamSeason']


class TeamArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    team: Union[bool, 'TeamArgsFromTeamSeason']
    tier: Union[bool, 'TierArgsFromTeamSeason']
    matches: Union[bool, 'FindManyMatchArgsFromTeamSeason']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeamSeason']
    bids: Union[bool, 'FindManyBidArgsFromTeamSeason']


class TeamSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    player: Union[bool, 'PlayerArgsFromTeamSeason']
    season: Union[bool, 'SeasonArgsFromTeamSeason']
    contract: Union[bool, 'ContractArgsFromTeamSeason']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeamSeason']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeamSeason']


class PlayerSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamSeason']
    tier: Union[bool, 'TierArgsFromTeamSeason']


class PlayerTierHistoryArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamSeason']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromTeamSeason']


class PlayerTeamSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamSeason']
    bids: Union[bool, 'FindManyBidArgsFromTeamSeason']


class ContractArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    contract: Union[bool, 'ContractArgsFromTeamSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamSeason']


class BidArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamSeason']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromTeamSeason']


class MatchArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    match: Union[bool, 'MatchArgsFromTeamSeason']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromTeamSeason']


class PlayerMatchArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']


class NotificationArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    author: Union[bool, 'UserArgsFromTeamSeason']
    comments: Union[bool, 'FindManyForumCommentArgsFromTeamSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeamSeason']
    followers: Union[bool, 'FindManyForumFollowerArgsFromTeamSeason']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeamSeason']


class ForumPostArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']
    post: Union[bool, 'ForumPostArgsFromTeamSeason']
    comment: Union[bool, 'ForumCommentArgsFromTeamSeason']


class ForumReactionArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']
    post: Union[bool, 'ForumPostArgsFromTeamSeason']


class ForumFollowerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']
    post: Union[bool, 'ForumPostArgsFromTeamSeason']


class ForumPostSubscriptionArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    author: Union[bool, 'UserArgsFromTeamSeason']
    post: Union[bool, 'ForumPostArgsFromTeamSeason']
    quotedComment: Union[bool, 'ForumCommentArgsFromTeamSeason']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromTeamSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeamSeason']


class ForumCommentArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromTeamSeason(TypedDict, total=False):
    """Relational arguments for TeamSeason"""
    user: Union[bool, 'UserArgsFromTeamSeason']
    team: Union[bool, 'TeamArgsFromTeamSeason']


class TeamManagerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromTeamSeason(TypedDict, total=False):
    """Arguments for TeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyTeamSeasonArgs = FindManyTeamSeasonArgsFromTeamSeason
FindFirstTeamSeasonArgs = FindManyTeamSeasonArgsFromTeamSeason


class TeamSeasonWhereInput(TypedDict, total=False):
    """TeamSeason arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    tierId: Union[_str, 'types.StringFilter']
    forwardCount: Union[_int, 'types.IntFilter']
    defenseCount: Union[_int, 'types.IntFilter']
    goalieCount: Union[_int, 'types.IntFilter']
    wins: Union[_int, 'types.IntFilter']
    losses: Union[_int, 'types.IntFilter']
    otLosses: Union[_int, 'types.IntFilter']
    goalsAgainst: Union[_int, 'types.IntFilter']
    goalsFor: Union[_int, 'types.IntFilter']
    matchesPlayed: Union[_int, 'types.IntFilter']
    penaltyKillGoalsAgainst: Union[_int, 'types.IntFilter']
    penaltyKillOpportunities: Union[_int, 'types.IntFilter']
    powerplayGoals: Union[_int, 'types.IntFilter']
    powerplayOpportunities: Union[_int, 'types.IntFilter']
    shots: Union[_int, 'types.IntFilter']
    shotsAgainst: Union[_int, 'types.IntFilter']
    timeOnAttack: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    team: 'TeamRelationFilter'
    tier: 'TierRelationFilter'
    matches: 'MatchListRelationFilter'
    players: 'PlayerTeamSeasonListRelationFilter'
    bids: 'BidListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamSeasonWhereInput', List['TeamSeasonWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TeamSeasonWhereInput']
    OR: List['TeamSeasonWhereInput']
    NOT: List['TeamSeasonWhereInput']



# aggregate TeamSeason types


class TeamSeasonScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TeamSeason arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']
    tierId: Union[_str, 'types.StringWithAggregatesFilter']
    forwardCount: Union[_int, 'types.IntWithAggregatesFilter']
    defenseCount: Union[_int, 'types.IntWithAggregatesFilter']
    goalieCount: Union[_int, 'types.IntWithAggregatesFilter']
    wins: Union[_int, 'types.IntWithAggregatesFilter']
    losses: Union[_int, 'types.IntWithAggregatesFilter']
    otLosses: Union[_int, 'types.IntWithAggregatesFilter']
    goalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    goalsFor: Union[_int, 'types.IntWithAggregatesFilter']
    matchesPlayed: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyKillGoalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyKillOpportunities: Union[_int, 'types.IntWithAggregatesFilter']
    powerplayGoals: Union[_int, 'types.IntWithAggregatesFilter']
    powerplayOpportunities: Union[_int, 'types.IntWithAggregatesFilter']
    shots: Union[_int, 'types.IntWithAggregatesFilter']
    shotsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    timeOnAttack: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TeamSeasonScalarWhereWithAggregatesInput']
    OR: List['TeamSeasonScalarWhereWithAggregatesInput']
    NOT: List['TeamSeasonScalarWhereWithAggregatesInput']



class TeamSeasonGroupByOutput(TypedDict, total=False):
    id: _str
    teamId: _str
    tierId: _str
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'TeamSeasonSumAggregateOutput'
    _avg: 'TeamSeasonAvgAggregateOutput'
    _min: 'TeamSeasonMinAggregateOutput'
    _max: 'TeamSeasonMaxAggregateOutput'
    _count: 'TeamSeasonCountAggregateOutput'


class TeamSeasonAvgAggregateOutput(TypedDict, total=False):
    """TeamSeason output for aggregating averages"""
    forwardCount: float
    defenseCount: float
    goalieCount: float
    wins: float
    losses: float
    otLosses: float
    goalsAgainst: float
    goalsFor: float
    matchesPlayed: float
    penaltyKillGoalsAgainst: float
    penaltyKillOpportunities: float
    powerplayGoals: float
    powerplayOpportunities: float
    shots: float
    shotsAgainst: float
    timeOnAttack: float


class TeamSeasonSumAggregateOutput(TypedDict, total=False):
    """TeamSeason output for aggregating sums"""
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int


class TeamSeasonScalarAggregateOutput(TypedDict, total=False):
    """TeamSeason output including scalar fields"""
    id: _str
    teamId: _str
    tierId: _str
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


TeamSeasonMinAggregateOutput = TeamSeasonScalarAggregateOutput
TeamSeasonMaxAggregateOutput = TeamSeasonScalarAggregateOutput


class TeamSeasonMaxAggregateInput(TypedDict, total=False):
    """TeamSeason input for aggregating by max"""
    id: bool
    teamId: bool
    tierId: bool
    forwardCount: bool
    defenseCount: bool
    goalieCount: bool
    wins: bool
    losses: bool
    otLosses: bool
    goalsAgainst: bool
    goalsFor: bool
    matchesPlayed: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool
    createdAt: bool
    updatedAt: bool


class TeamSeasonMinAggregateInput(TypedDict, total=False):
    """TeamSeason input for aggregating by min"""
    id: bool
    teamId: bool
    tierId: bool
    forwardCount: bool
    defenseCount: bool
    goalieCount: bool
    wins: bool
    losses: bool
    otLosses: bool
    goalsAgainst: bool
    goalsFor: bool
    matchesPlayed: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool
    createdAt: bool
    updatedAt: bool


class TeamSeasonNumberAggregateInput(TypedDict, total=False):
    """TeamSeason input for aggregating numbers"""
    forwardCount: bool
    defenseCount: bool
    goalieCount: bool
    wins: bool
    losses: bool
    otLosses: bool
    goalsAgainst: bool
    goalsFor: bool
    matchesPlayed: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool


TeamSeasonAvgAggregateInput = TeamSeasonNumberAggregateInput
TeamSeasonSumAggregateInput = TeamSeasonNumberAggregateInput


TeamSeasonCountAggregateInput = TypedDict(
    'TeamSeasonCountAggregateInput',
    {
        'id': bool,
        'teamId': bool,
        'tierId': bool,
        'forwardCount': bool,
        'defenseCount': bool,
        'goalieCount': bool,
        'wins': bool,
        'losses': bool,
        'otLosses': bool,
        'goalsAgainst': bool,
        'goalsFor': bool,
        'matchesPlayed': bool,
        'penaltyKillGoalsAgainst': bool,
        'penaltyKillOpportunities': bool,
        'powerplayGoals': bool,
        'powerplayOpportunities': bool,
        'shots': bool,
        'shotsAgainst': bool,
        'timeOnAttack': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

TeamSeasonCountAggregateOutput = TypedDict(
    'TeamSeasonCountAggregateOutput',
    {
        'id': int,
        'teamId': int,
        'tierId': int,
        'forwardCount': int,
        'defenseCount': int,
        'goalieCount': int,
        'wins': int,
        'losses': int,
        'otLosses': int,
        'goalsAgainst': int,
        'goalsFor': int,
        'matchesPlayed': int,
        'penaltyKillGoalsAgainst': int,
        'penaltyKillOpportunities': int,
        'powerplayGoals': int,
        'powerplayOpportunities': int,
        'shots': int,
        'shotsAgainst': int,
        'timeOnAttack': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


TeamSeasonKeys = Literal[
    'id',
    'teamId',
    'tierId',
    'forwardCount',
    'defenseCount',
    'goalieCount',
    'wins',
    'losses',
    'otLosses',
    'goalsAgainst',
    'goalsFor',
    'matchesPlayed',
    'penaltyKillGoalsAgainst',
    'penaltyKillOpportunities',
    'powerplayGoals',
    'powerplayOpportunities',
    'shots',
    'shotsAgainst',
    'timeOnAttack',
    'createdAt',
    'updatedAt',
    'team',
    'tier',
    'matches',
    'players',
    'bids',
]
TeamSeasonScalarFieldKeys = Literal[
    'id',
    'teamId',
    'tierId',
    'forwardCount',
    'defenseCount',
    'goalieCount',
    'wins',
    'losses',
    'otLosses',
    'goalsAgainst',
    'goalsFor',
    'matchesPlayed',
    'penaltyKillGoalsAgainst',
    'penaltyKillOpportunities',
    'powerplayGoals',
    'powerplayOpportunities',
    'shots',
    'shotsAgainst',
    'timeOnAttack',
    'createdAt',
    'updatedAt',
]
TeamSeasonScalarFieldKeysT = TypeVar('TeamSeasonScalarFieldKeysT', bound=TeamSeasonScalarFieldKeys)

TeamSeasonRelationalFieldKeys = Literal[
        'team',
        'tier',
        'matches',
        'players',
        'bids',
    ]

# PlayerSeason types

class PlayerSeasonOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayerSeason create method"""
    id: _str
    playerId: _str
    seasonId: _str
    contractId: _str
    gamesPlayed: Optional[_int]
    goals: Optional[_int]
    assists: Optional[_int]
    plusMinus: Optional[_int]
    shots: Optional[_int]
    hits: Optional[_int]
    takeaways: Optional[_int]
    giveaways: Optional[_int]
    penaltyMinutes: Optional[_int]
    saves: Optional[_int]
    goalsAgainst: Optional[_int]
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: 'PlayerCreateNestedWithoutRelationsInput'
    season: 'SeasonCreateNestedWithoutRelationsInput'
    contract: 'ContractCreateNestedWithoutRelationsInput'
    teamSeasons: 'PlayerTeamSeasonCreateManyNestedWithoutRelationsInput'
    tierHistory: 'PlayerTierHistoryCreateManyNestedWithoutRelationsInput'


class PlayerSeasonCreateInput(PlayerSeasonOptionalCreateInput):
    """Required arguments to the PlayerSeason create method"""
    position: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerSeasonOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayerSeason create method, without relations"""
    id: _str
    playerId: _str
    seasonId: _str
    contractId: _str
    gamesPlayed: Optional[_int]
    goals: Optional[_int]
    assists: Optional[_int]
    plusMinus: Optional[_int]
    shots: Optional[_int]
    hits: Optional[_int]
    takeaways: Optional[_int]
    giveaways: Optional[_int]
    penaltyMinutes: Optional[_int]
    saves: Optional[_int]
    goalsAgainst: Optional[_int]
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerSeasonCreateWithoutRelationsInput(PlayerSeasonOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayerSeason create method, without relations"""
    position: _str

class PlayerSeasonConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerSeasonCreateWithoutRelationsInput'
    where: 'PlayerSeasonWhereUniqueInput'

class PlayerSeasonCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerSeasonCreateWithoutRelationsInput'
    connect: 'PlayerSeasonWhereUniqueInput'
    connect_or_create: 'PlayerSeasonConnectOrCreateWithoutRelationsInput'


class PlayerSeasonCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerSeasonCreateWithoutRelationsInput', List['PlayerSeasonCreateWithoutRelationsInput']]
    connect: Union['PlayerSeasonWhereUniqueInput', List['PlayerSeasonWhereUniqueInput']]
    connect_or_create: Union['PlayerSeasonConnectOrCreateWithoutRelationsInput', List['PlayerSeasonConnectOrCreateWithoutRelationsInput']]

_PlayerSeasonWhereUnique_id_Input = TypedDict(
    '_PlayerSeasonWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_PlayerSeasonWhereUnique_contractId_Input = TypedDict(
    '_PlayerSeasonWhereUnique_contractId_Input',
    {
        'contractId': '_str',
    },
    total=True
)

PlayerSeasonWhereUniqueInput = Union[
    '_PlayerSeasonWhereUnique_id_Input',
    '_PlayerSeasonWhereUnique_contractId_Input',
]


class PlayerSeasonUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    position: _str
    gamesPlayed: Optional[Union[AtomicIntInput, _int]]
    goals: Optional[Union[AtomicIntInput, _int]]
    assists: Optional[Union[AtomicIntInput, _int]]
    plusMinus: Optional[Union[AtomicIntInput, _int]]
    shots: Optional[Union[AtomicIntInput, _int]]
    hits: Optional[Union[AtomicIntInput, _int]]
    takeaways: Optional[Union[AtomicIntInput, _int]]
    giveaways: Optional[Union[AtomicIntInput, _int]]
    penaltyMinutes: Optional[Union[AtomicIntInput, _int]]
    saves: Optional[Union[AtomicIntInput, _int]]
    goalsAgainst: Optional[Union[AtomicIntInput, _int]]
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: 'PlayerUpdateOneWithoutRelationsInput'
    season: 'SeasonUpdateOneWithoutRelationsInput'
    contract: 'ContractUpdateOneWithoutRelationsInput'
    teamSeasons: 'PlayerTeamSeasonUpdateManyWithoutRelationsInput'
    tierHistory: 'PlayerTierHistoryUpdateManyWithoutRelationsInput'


class PlayerSeasonUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    position: _str
    gamesPlayed: Optional[Union[AtomicIntInput, _int]]
    goals: Optional[Union[AtomicIntInput, _int]]
    assists: Optional[Union[AtomicIntInput, _int]]
    plusMinus: Optional[Union[AtomicIntInput, _int]]
    shots: Optional[Union[AtomicIntInput, _int]]
    hits: Optional[Union[AtomicIntInput, _int]]
    takeaways: Optional[Union[AtomicIntInput, _int]]
    giveaways: Optional[Union[AtomicIntInput, _int]]
    penaltyMinutes: Optional[Union[AtomicIntInput, _int]]
    saves: Optional[Union[AtomicIntInput, _int]]
    goalsAgainst: Optional[Union[AtomicIntInput, _int]]
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerSeasonUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerSeasonCreateWithoutRelationsInput']
    connect: List['PlayerSeasonWhereUniqueInput']
    connect_or_create: List['PlayerSeasonConnectOrCreateWithoutRelationsInput']
    set: List['PlayerSeasonWhereUniqueInput']
    disconnect: List['PlayerSeasonWhereUniqueInput']
    delete: List['PlayerSeasonWhereUniqueInput']

    # TODO
    # update: List['PlayerSeasonUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerSeasonUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerSeasonScalarWhereInput']
    # upsert: List['PlayerSeasonUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerSeasonUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerSeasonCreateWithoutRelationsInput'
    connect: 'PlayerSeasonWhereUniqueInput'
    connect_or_create: 'PlayerSeasonConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerSeasonUpdateInput'
    # upsert: 'PlayerSeasonUpsertWithoutRelationsInput'


class PlayerSeasonUpsertInput(TypedDict):
    create: 'PlayerSeasonCreateInput'
    update: 'PlayerSeasonUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayerSeason_id_OrderByInput = TypedDict(
    '_PlayerSeason_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayerSeason_playerId_OrderByInput = TypedDict(
    '_PlayerSeason_playerId_OrderByInput',
    {
        'playerId': 'SortOrder',
    },
    total=True
)

_PlayerSeason_seasonId_OrderByInput = TypedDict(
    '_PlayerSeason_seasonId_OrderByInput',
    {
        'seasonId': 'SortOrder',
    },
    total=True
)

_PlayerSeason_contractId_OrderByInput = TypedDict(
    '_PlayerSeason_contractId_OrderByInput',
    {
        'contractId': 'SortOrder',
    },
    total=True
)

_PlayerSeason_position_OrderByInput = TypedDict(
    '_PlayerSeason_position_OrderByInput',
    {
        'position': 'SortOrder',
    },
    total=True
)

_PlayerSeason_gamesPlayed_OrderByInput = TypedDict(
    '_PlayerSeason_gamesPlayed_OrderByInput',
    {
        'gamesPlayed': 'SortOrder',
    },
    total=True
)

_PlayerSeason_goals_OrderByInput = TypedDict(
    '_PlayerSeason_goals_OrderByInput',
    {
        'goals': 'SortOrder',
    },
    total=True
)

_PlayerSeason_assists_OrderByInput = TypedDict(
    '_PlayerSeason_assists_OrderByInput',
    {
        'assists': 'SortOrder',
    },
    total=True
)

_PlayerSeason_plusMinus_OrderByInput = TypedDict(
    '_PlayerSeason_plusMinus_OrderByInput',
    {
        'plusMinus': 'SortOrder',
    },
    total=True
)

_PlayerSeason_shots_OrderByInput = TypedDict(
    '_PlayerSeason_shots_OrderByInput',
    {
        'shots': 'SortOrder',
    },
    total=True
)

_PlayerSeason_hits_OrderByInput = TypedDict(
    '_PlayerSeason_hits_OrderByInput',
    {
        'hits': 'SortOrder',
    },
    total=True
)

_PlayerSeason_takeaways_OrderByInput = TypedDict(
    '_PlayerSeason_takeaways_OrderByInput',
    {
        'takeaways': 'SortOrder',
    },
    total=True
)

_PlayerSeason_giveaways_OrderByInput = TypedDict(
    '_PlayerSeason_giveaways_OrderByInput',
    {
        'giveaways': 'SortOrder',
    },
    total=True
)

_PlayerSeason_penaltyMinutes_OrderByInput = TypedDict(
    '_PlayerSeason_penaltyMinutes_OrderByInput',
    {
        'penaltyMinutes': 'SortOrder',
    },
    total=True
)

_PlayerSeason_saves_OrderByInput = TypedDict(
    '_PlayerSeason_saves_OrderByInput',
    {
        'saves': 'SortOrder',
    },
    total=True
)

_PlayerSeason_goalsAgainst_OrderByInput = TypedDict(
    '_PlayerSeason_goalsAgainst_OrderByInput',
    {
        'goalsAgainst': 'SortOrder',
    },
    total=True
)

_PlayerSeason_isInBidding_OrderByInput = TypedDict(
    '_PlayerSeason_isInBidding_OrderByInput',
    {
        'isInBidding': 'SortOrder',
    },
    total=True
)

_PlayerSeason_createdAt_OrderByInput = TypedDict(
    '_PlayerSeason_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PlayerSeason_updatedAt_OrderByInput = TypedDict(
    '_PlayerSeason_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_PlayerSeason_RelevanceInner = TypedDict(
    '_PlayerSeason_RelevanceInner',
    {
        'fields': 'List[PlayerSeasonScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayerSeason_RelevanceOrderByInput = TypedDict(
    '_PlayerSeason_RelevanceOrderByInput',
    {
        '_relevance': '_PlayerSeason_RelevanceInner',
    },
    total=True
)

PlayerSeasonOrderByInput = Union[
    '_PlayerSeason_id_OrderByInput',
    '_PlayerSeason_playerId_OrderByInput',
    '_PlayerSeason_seasonId_OrderByInput',
    '_PlayerSeason_contractId_OrderByInput',
    '_PlayerSeason_position_OrderByInput',
    '_PlayerSeason_gamesPlayed_OrderByInput',
    '_PlayerSeason_goals_OrderByInput',
    '_PlayerSeason_assists_OrderByInput',
    '_PlayerSeason_plusMinus_OrderByInput',
    '_PlayerSeason_shots_OrderByInput',
    '_PlayerSeason_hits_OrderByInput',
    '_PlayerSeason_takeaways_OrderByInput',
    '_PlayerSeason_giveaways_OrderByInput',
    '_PlayerSeason_penaltyMinutes_OrderByInput',
    '_PlayerSeason_saves_OrderByInput',
    '_PlayerSeason_goalsAgainst_OrderByInput',
    '_PlayerSeason_isInBidding_OrderByInput',
    '_PlayerSeason_createdAt_OrderByInput',
    '_PlayerSeason_updatedAt_OrderByInput',
    '_PlayerSeason_RelevanceOrderByInput',
]



# recursive PlayerSeason types
# TODO: cleanup these types



PlayerSeasonRelationFilter = TypedDict(
    'PlayerSeasonRelationFilter',
    {
        'is': 'PlayerSeasonWhereInput',
        'is_not': 'PlayerSeasonWhereInput',
    },
    total=False,
)


class PlayerSeasonListRelationFilter(TypedDict, total=False):
    some: 'PlayerSeasonWhereInput'
    none: 'PlayerSeasonWhereInput'
    every: 'PlayerSeasonWhereInput'


class PlayerSeasonInclude(TypedDict, total=False):
    """PlayerSeason relational arguments"""
    player: Union[bool, 'PlayerArgsFromPlayerSeason']
    season: Union[bool, 'SeasonArgsFromPlayerSeason']
    contract: Union[bool, 'ContractArgsFromPlayerSeason']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerSeason']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerSeason']


class UserIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerSeason']
    notifications: Union[bool, 'FindManyNotificationArgsFromPlayerSeason']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromPlayerSeason']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromPlayerSeason']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromPlayerSeason']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromPlayerSeason']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerSeason']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromPlayerSeason']


class UserArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayerSeason']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerSeason']


class PlayerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerSeason']


class GamertagHistoryArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    tiers: Union[bool, 'FindManyTierArgsFromPlayerSeason']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerSeason']


class SeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    season: Union[bool, 'SeasonArgsFromPlayerSeason']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromPlayerSeason']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerSeason']


class TierArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromPlayerSeason']
    managers: Union[bool, 'FindManyTeamManagerArgsFromPlayerSeason']
    nhlAffiliate: Union[bool, 'TeamArgsFromPlayerSeason']
    ahlAffiliate: Union[bool, 'TeamArgsFromPlayerSeason']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerSeason']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerSeason']


class TeamArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    team: Union[bool, 'TeamArgsFromPlayerSeason']
    tier: Union[bool, 'TierArgsFromPlayerSeason']
    matches: Union[bool, 'FindManyMatchArgsFromPlayerSeason']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerSeason']
    bids: Union[bool, 'FindManyBidArgsFromPlayerSeason']


class TeamSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerSeason']
    season: Union[bool, 'SeasonArgsFromPlayerSeason']
    contract: Union[bool, 'ContractArgsFromPlayerSeason']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerSeason']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerSeason']


class PlayerSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerSeason']
    tier: Union[bool, 'TierArgsFromPlayerSeason']


class PlayerTierHistoryArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerSeason']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayerSeason']


class PlayerTeamSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerSeason']
    bids: Union[bool, 'FindManyBidArgsFromPlayerSeason']


class ContractArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    contract: Union[bool, 'ContractArgsFromPlayerSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerSeason']


class BidArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerSeason']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromPlayerSeason']


class MatchArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    match: Union[bool, 'MatchArgsFromPlayerSeason']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayerSeason']


class PlayerMatchArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']


class NotificationArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    author: Union[bool, 'UserArgsFromPlayerSeason']
    comments: Union[bool, 'FindManyForumCommentArgsFromPlayerSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerSeason']
    followers: Union[bool, 'FindManyForumFollowerArgsFromPlayerSeason']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerSeason']


class ForumPostArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerSeason']
    comment: Union[bool, 'ForumCommentArgsFromPlayerSeason']


class ForumReactionArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerSeason']


class ForumFollowerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerSeason']


class ForumPostSubscriptionArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    author: Union[bool, 'UserArgsFromPlayerSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerSeason']
    quotedComment: Union[bool, 'ForumCommentArgsFromPlayerSeason']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromPlayerSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerSeason']


class ForumCommentArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromPlayerSeason(TypedDict, total=False):
    """Relational arguments for PlayerSeason"""
    user: Union[bool, 'UserArgsFromPlayerSeason']
    team: Union[bool, 'TeamArgsFromPlayerSeason']


class TeamManagerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromPlayerSeason(TypedDict, total=False):
    """Arguments for PlayerSeason"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyPlayerSeasonArgs = FindManyPlayerSeasonArgsFromPlayerSeason
FindFirstPlayerSeasonArgs = FindManyPlayerSeasonArgsFromPlayerSeason


class PlayerSeasonWhereInput(TypedDict, total=False):
    """PlayerSeason arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    playerId: Union[_str, 'types.StringFilter']
    seasonId: Union[_str, 'types.StringFilter']
    contractId: Union[_str, 'types.StringFilter']
    position: Union[_str, 'types.StringFilter']
    gamesPlayed: Union[None, _int, 'types.IntFilter']
    goals: Union[None, _int, 'types.IntFilter']
    assists: Union[None, _int, 'types.IntFilter']
    plusMinus: Union[None, _int, 'types.IntFilter']
    shots: Union[None, _int, 'types.IntFilter']
    hits: Union[None, _int, 'types.IntFilter']
    takeaways: Union[None, _int, 'types.IntFilter']
    giveaways: Union[None, _int, 'types.IntFilter']
    penaltyMinutes: Union[None, _int, 'types.IntFilter']
    saves: Union[None, _int, 'types.IntFilter']
    goalsAgainst: Union[None, _int, 'types.IntFilter']
    isInBidding: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    player: 'PlayerRelationFilter'
    season: 'SeasonRelationFilter'
    contract: 'ContractRelationFilter'
    teamSeasons: 'PlayerTeamSeasonListRelationFilter'
    tierHistory: 'PlayerTierHistoryListRelationFilter'

    # should be noted that AND and NOT should be Union['PlayerSeasonWhereInput', List['PlayerSeasonWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlayerSeasonWhereInput']
    OR: List['PlayerSeasonWhereInput']
    NOT: List['PlayerSeasonWhereInput']



# aggregate PlayerSeason types


class PlayerSeasonScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayerSeason arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    playerId: Union[_str, 'types.StringWithAggregatesFilter']
    seasonId: Union[_str, 'types.StringWithAggregatesFilter']
    contractId: Union[_str, 'types.StringWithAggregatesFilter']
    position: Union[_str, 'types.StringWithAggregatesFilter']
    gamesPlayed: Union[_int, 'types.IntWithAggregatesFilter']
    goals: Union[_int, 'types.IntWithAggregatesFilter']
    assists: Union[_int, 'types.IntWithAggregatesFilter']
    plusMinus: Union[_int, 'types.IntWithAggregatesFilter']
    shots: Union[_int, 'types.IntWithAggregatesFilter']
    hits: Union[_int, 'types.IntWithAggregatesFilter']
    takeaways: Union[_int, 'types.IntWithAggregatesFilter']
    giveaways: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    saves: Union[_int, 'types.IntWithAggregatesFilter']
    goalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    isInBidding: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PlayerSeasonScalarWhereWithAggregatesInput']
    OR: List['PlayerSeasonScalarWhereWithAggregatesInput']
    NOT: List['PlayerSeasonScalarWhereWithAggregatesInput']



class PlayerSeasonGroupByOutput(TypedDict, total=False):
    id: _str
    playerId: _str
    seasonId: _str
    contractId: _str
    position: _str
    gamesPlayed: _int
    goals: _int
    assists: _int
    plusMinus: _int
    shots: _int
    hits: _int
    takeaways: _int
    giveaways: _int
    penaltyMinutes: _int
    saves: _int
    goalsAgainst: _int
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PlayerSeasonSumAggregateOutput'
    _avg: 'PlayerSeasonAvgAggregateOutput'
    _min: 'PlayerSeasonMinAggregateOutput'
    _max: 'PlayerSeasonMaxAggregateOutput'
    _count: 'PlayerSeasonCountAggregateOutput'


class PlayerSeasonAvgAggregateOutput(TypedDict, total=False):
    """PlayerSeason output for aggregating averages"""
    gamesPlayed: float
    goals: float
    assists: float
    plusMinus: float
    shots: float
    hits: float
    takeaways: float
    giveaways: float
    penaltyMinutes: float
    saves: float
    goalsAgainst: float


class PlayerSeasonSumAggregateOutput(TypedDict, total=False):
    """PlayerSeason output for aggregating sums"""
    gamesPlayed: _int
    goals: _int
    assists: _int
    plusMinus: _int
    shots: _int
    hits: _int
    takeaways: _int
    giveaways: _int
    penaltyMinutes: _int
    saves: _int
    goalsAgainst: _int


class PlayerSeasonScalarAggregateOutput(TypedDict, total=False):
    """PlayerSeason output including scalar fields"""
    id: _str
    playerId: _str
    seasonId: _str
    contractId: _str
    position: _str
    gamesPlayed: _int
    goals: _int
    assists: _int
    plusMinus: _int
    shots: _int
    hits: _int
    takeaways: _int
    giveaways: _int
    penaltyMinutes: _int
    saves: _int
    goalsAgainst: _int
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PlayerSeasonMinAggregateOutput = PlayerSeasonScalarAggregateOutput
PlayerSeasonMaxAggregateOutput = PlayerSeasonScalarAggregateOutput


class PlayerSeasonMaxAggregateInput(TypedDict, total=False):
    """PlayerSeason input for aggregating by max"""
    id: bool
    playerId: bool
    seasonId: bool
    contractId: bool
    position: bool
    gamesPlayed: bool
    goals: bool
    assists: bool
    plusMinus: bool
    shots: bool
    hits: bool
    takeaways: bool
    giveaways: bool
    penaltyMinutes: bool
    saves: bool
    goalsAgainst: bool
    isInBidding: bool
    createdAt: bool
    updatedAt: bool


class PlayerSeasonMinAggregateInput(TypedDict, total=False):
    """PlayerSeason input for aggregating by min"""
    id: bool
    playerId: bool
    seasonId: bool
    contractId: bool
    position: bool
    gamesPlayed: bool
    goals: bool
    assists: bool
    plusMinus: bool
    shots: bool
    hits: bool
    takeaways: bool
    giveaways: bool
    penaltyMinutes: bool
    saves: bool
    goalsAgainst: bool
    isInBidding: bool
    createdAt: bool
    updatedAt: bool


class PlayerSeasonNumberAggregateInput(TypedDict, total=False):
    """PlayerSeason input for aggregating numbers"""
    gamesPlayed: bool
    goals: bool
    assists: bool
    plusMinus: bool
    shots: bool
    hits: bool
    takeaways: bool
    giveaways: bool
    penaltyMinutes: bool
    saves: bool
    goalsAgainst: bool


PlayerSeasonAvgAggregateInput = PlayerSeasonNumberAggregateInput
PlayerSeasonSumAggregateInput = PlayerSeasonNumberAggregateInput


PlayerSeasonCountAggregateInput = TypedDict(
    'PlayerSeasonCountAggregateInput',
    {
        'id': bool,
        'playerId': bool,
        'seasonId': bool,
        'contractId': bool,
        'position': bool,
        'gamesPlayed': bool,
        'goals': bool,
        'assists': bool,
        'plusMinus': bool,
        'shots': bool,
        'hits': bool,
        'takeaways': bool,
        'giveaways': bool,
        'penaltyMinutes': bool,
        'saves': bool,
        'goalsAgainst': bool,
        'isInBidding': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PlayerSeasonCountAggregateOutput = TypedDict(
    'PlayerSeasonCountAggregateOutput',
    {
        'id': int,
        'playerId': int,
        'seasonId': int,
        'contractId': int,
        'position': int,
        'gamesPlayed': int,
        'goals': int,
        'assists': int,
        'plusMinus': int,
        'shots': int,
        'hits': int,
        'takeaways': int,
        'giveaways': int,
        'penaltyMinutes': int,
        'saves': int,
        'goalsAgainst': int,
        'isInBidding': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PlayerSeasonKeys = Literal[
    'id',
    'playerId',
    'seasonId',
    'contractId',
    'position',
    'gamesPlayed',
    'goals',
    'assists',
    'plusMinus',
    'shots',
    'hits',
    'takeaways',
    'giveaways',
    'penaltyMinutes',
    'saves',
    'goalsAgainst',
    'isInBidding',
    'createdAt',
    'updatedAt',
    'player',
    'season',
    'contract',
    'teamSeasons',
    'tierHistory',
]
PlayerSeasonScalarFieldKeys = Literal[
    'id',
    'playerId',
    'seasonId',
    'contractId',
    'position',
    'gamesPlayed',
    'goals',
    'assists',
    'plusMinus',
    'shots',
    'hits',
    'takeaways',
    'giveaways',
    'penaltyMinutes',
    'saves',
    'goalsAgainst',
    'isInBidding',
    'createdAt',
    'updatedAt',
]
PlayerSeasonScalarFieldKeysT = TypeVar('PlayerSeasonScalarFieldKeysT', bound=PlayerSeasonScalarFieldKeys)

PlayerSeasonRelationalFieldKeys = Literal[
        'player',
        'season',
        'contract',
        'teamSeasons',
        'tierHistory',
    ]

# PlayerTierHistory types

class PlayerTierHistoryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayerTierHistory create method"""
    id: _str
    playerSeasonId: _str
    tierId: _str
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonCreateNestedWithoutRelationsInput'
    tier: 'TierCreateNestedWithoutRelationsInput'


class PlayerTierHistoryCreateInput(PlayerTierHistoryOptionalCreateInput):
    """Required arguments to the PlayerTierHistory create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerTierHistoryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayerTierHistory create method, without relations"""
    id: _str
    playerSeasonId: _str
    tierId: _str
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerTierHistoryCreateWithoutRelationsInput(PlayerTierHistoryOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayerTierHistory create method, without relations"""

class PlayerTierHistoryConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerTierHistoryCreateWithoutRelationsInput'
    where: 'PlayerTierHistoryWhereUniqueInput'

class PlayerTierHistoryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerTierHistoryCreateWithoutRelationsInput'
    connect: 'PlayerTierHistoryWhereUniqueInput'
    connect_or_create: 'PlayerTierHistoryConnectOrCreateWithoutRelationsInput'


class PlayerTierHistoryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerTierHistoryCreateWithoutRelationsInput', List['PlayerTierHistoryCreateWithoutRelationsInput']]
    connect: Union['PlayerTierHistoryWhereUniqueInput', List['PlayerTierHistoryWhereUniqueInput']]
    connect_or_create: Union['PlayerTierHistoryConnectOrCreateWithoutRelationsInput', List['PlayerTierHistoryConnectOrCreateWithoutRelationsInput']]

_PlayerTierHistoryWhereUnique_id_Input = TypedDict(
    '_PlayerTierHistoryWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlayerTierHistoryWhereUniqueInput = _PlayerTierHistoryWhereUnique_id_Input


class PlayerTierHistoryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonUpdateOneWithoutRelationsInput'
    tier: 'TierUpdateOneWithoutRelationsInput'


class PlayerTierHistoryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerTierHistoryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerTierHistoryCreateWithoutRelationsInput']
    connect: List['PlayerTierHistoryWhereUniqueInput']
    connect_or_create: List['PlayerTierHistoryConnectOrCreateWithoutRelationsInput']
    set: List['PlayerTierHistoryWhereUniqueInput']
    disconnect: List['PlayerTierHistoryWhereUniqueInput']
    delete: List['PlayerTierHistoryWhereUniqueInput']

    # TODO
    # update: List['PlayerTierHistoryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerTierHistoryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerTierHistoryScalarWhereInput']
    # upsert: List['PlayerTierHistoryUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerTierHistoryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerTierHistoryCreateWithoutRelationsInput'
    connect: 'PlayerTierHistoryWhereUniqueInput'
    connect_or_create: 'PlayerTierHistoryConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerTierHistoryUpdateInput'
    # upsert: 'PlayerTierHistoryUpsertWithoutRelationsInput'


class PlayerTierHistoryUpsertInput(TypedDict):
    create: 'PlayerTierHistoryCreateInput'
    update: 'PlayerTierHistoryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayerTierHistory_id_OrderByInput = TypedDict(
    '_PlayerTierHistory_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_playerSeasonId_OrderByInput = TypedDict(
    '_PlayerTierHistory_playerSeasonId_OrderByInput',
    {
        'playerSeasonId': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_tierId_OrderByInput = TypedDict(
    '_PlayerTierHistory_tierId_OrderByInput',
    {
        'tierId': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_startDate_OrderByInput = TypedDict(
    '_PlayerTierHistory_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_endDate_OrderByInput = TypedDict(
    '_PlayerTierHistory_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_createdAt_OrderByInput = TypedDict(
    '_PlayerTierHistory_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_updatedAt_OrderByInput = TypedDict(
    '_PlayerTierHistory_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_RelevanceInner = TypedDict(
    '_PlayerTierHistory_RelevanceInner',
    {
        'fields': 'List[PlayerTierHistoryScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayerTierHistory_RelevanceOrderByInput = TypedDict(
    '_PlayerTierHistory_RelevanceOrderByInput',
    {
        '_relevance': '_PlayerTierHistory_RelevanceInner',
    },
    total=True
)

PlayerTierHistoryOrderByInput = Union[
    '_PlayerTierHistory_id_OrderByInput',
    '_PlayerTierHistory_playerSeasonId_OrderByInput',
    '_PlayerTierHistory_tierId_OrderByInput',
    '_PlayerTierHistory_startDate_OrderByInput',
    '_PlayerTierHistory_endDate_OrderByInput',
    '_PlayerTierHistory_createdAt_OrderByInput',
    '_PlayerTierHistory_updatedAt_OrderByInput',
    '_PlayerTierHistory_RelevanceOrderByInput',
]



# recursive PlayerTierHistory types
# TODO: cleanup these types



PlayerTierHistoryRelationFilter = TypedDict(
    'PlayerTierHistoryRelationFilter',
    {
        'is': 'PlayerTierHistoryWhereInput',
        'is_not': 'PlayerTierHistoryWhereInput',
    },
    total=False,
)


class PlayerTierHistoryListRelationFilter(TypedDict, total=False):
    some: 'PlayerTierHistoryWhereInput'
    none: 'PlayerTierHistoryWhereInput'
    every: 'PlayerTierHistoryWhereInput'


class PlayerTierHistoryInclude(TypedDict, total=False):
    """PlayerTierHistory relational arguments"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTierHistory']
    tier: Union[bool, 'TierArgsFromPlayerTierHistory']


class UserIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    player: Union[bool, 'PlayerArgsFromPlayerTierHistory']
    notifications: Union[bool, 'FindManyNotificationArgsFromPlayerTierHistory']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromPlayerTierHistory']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromPlayerTierHistory']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTierHistory']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromPlayerTierHistory']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerTierHistory']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromPlayerTierHistory']


class UserArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayerTierHistory']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerTierHistory']


class PlayerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    player: Union[bool, 'PlayerArgsFromPlayerTierHistory']


class GamertagHistoryArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    tiers: Union[bool, 'FindManyTierArgsFromPlayerTierHistory']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerTierHistory']


class SeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    season: Union[bool, 'SeasonArgsFromPlayerTierHistory']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromPlayerTierHistory']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerTierHistory']


class TierArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromPlayerTierHistory']
    managers: Union[bool, 'FindManyTeamManagerArgsFromPlayerTierHistory']
    nhlAffiliate: Union[bool, 'TeamArgsFromPlayerTierHistory']
    ahlAffiliate: Union[bool, 'TeamArgsFromPlayerTierHistory']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerTierHistory']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerTierHistory']


class TeamArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    team: Union[bool, 'TeamArgsFromPlayerTierHistory']
    tier: Union[bool, 'TierArgsFromPlayerTierHistory']
    matches: Union[bool, 'FindManyMatchArgsFromPlayerTierHistory']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerTierHistory']
    bids: Union[bool, 'FindManyBidArgsFromPlayerTierHistory']


class TeamSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    player: Union[bool, 'PlayerArgsFromPlayerTierHistory']
    season: Union[bool, 'SeasonArgsFromPlayerTierHistory']
    contract: Union[bool, 'ContractArgsFromPlayerTierHistory']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerTierHistory']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerTierHistory']


class PlayerSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTierHistory']
    tier: Union[bool, 'TierArgsFromPlayerTierHistory']


class PlayerTierHistoryArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTierHistory']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTierHistory']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayerTierHistory']


class PlayerTeamSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTierHistory']
    bids: Union[bool, 'FindManyBidArgsFromPlayerTierHistory']


class ContractArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    contract: Union[bool, 'ContractArgsFromPlayerTierHistory']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTierHistory']


class BidArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTierHistory']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromPlayerTierHistory']


class MatchArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    match: Union[bool, 'MatchArgsFromPlayerTierHistory']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayerTierHistory']


class PlayerMatchArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']


class NotificationArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    author: Union[bool, 'UserArgsFromPlayerTierHistory']
    comments: Union[bool, 'FindManyForumCommentArgsFromPlayerTierHistory']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTierHistory']
    followers: Union[bool, 'FindManyForumFollowerArgsFromPlayerTierHistory']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerTierHistory']


class ForumPostArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']
    post: Union[bool, 'ForumPostArgsFromPlayerTierHistory']
    comment: Union[bool, 'ForumCommentArgsFromPlayerTierHistory']


class ForumReactionArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']
    post: Union[bool, 'ForumPostArgsFromPlayerTierHistory']


class ForumFollowerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']
    post: Union[bool, 'ForumPostArgsFromPlayerTierHistory']


class ForumPostSubscriptionArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    author: Union[bool, 'UserArgsFromPlayerTierHistory']
    post: Union[bool, 'ForumPostArgsFromPlayerTierHistory']
    quotedComment: Union[bool, 'ForumCommentArgsFromPlayerTierHistory']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromPlayerTierHistory']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTierHistory']


class ForumCommentArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromPlayerTierHistory(TypedDict, total=False):
    """Relational arguments for PlayerTierHistory"""
    user: Union[bool, 'UserArgsFromPlayerTierHistory']
    team: Union[bool, 'TeamArgsFromPlayerTierHistory']


class TeamManagerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromPlayerTierHistory(TypedDict, total=False):
    """Arguments for PlayerTierHistory"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyPlayerTierHistoryArgs = FindManyPlayerTierHistoryArgsFromPlayerTierHistory
FindFirstPlayerTierHistoryArgs = FindManyPlayerTierHistoryArgsFromPlayerTierHistory


class PlayerTierHistoryWhereInput(TypedDict, total=False):
    """PlayerTierHistory arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    playerSeasonId: Union[_str, 'types.StringFilter']
    tierId: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    playerSeason: 'PlayerSeasonRelationFilter'
    tier: 'TierRelationFilter'

    # should be noted that AND and NOT should be Union['PlayerTierHistoryWhereInput', List['PlayerTierHistoryWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlayerTierHistoryWhereInput']
    OR: List['PlayerTierHistoryWhereInput']
    NOT: List['PlayerTierHistoryWhereInput']



# aggregate PlayerTierHistory types


class PlayerTierHistoryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayerTierHistory arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    playerSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    tierId: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PlayerTierHistoryScalarWhereWithAggregatesInput']
    OR: List['PlayerTierHistoryScalarWhereWithAggregatesInput']
    NOT: List['PlayerTierHistoryScalarWhereWithAggregatesInput']



class PlayerTierHistoryGroupByOutput(TypedDict, total=False):
    id: _str
    playerSeasonId: _str
    tierId: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PlayerTierHistorySumAggregateOutput'
    _avg: 'PlayerTierHistoryAvgAggregateOutput'
    _min: 'PlayerTierHistoryMinAggregateOutput'
    _max: 'PlayerTierHistoryMaxAggregateOutput'
    _count: 'PlayerTierHistoryCountAggregateOutput'


class PlayerTierHistoryAvgAggregateOutput(TypedDict, total=False):
    """PlayerTierHistory output for aggregating averages"""


class PlayerTierHistorySumAggregateOutput(TypedDict, total=False):
    """PlayerTierHistory output for aggregating sums"""


class PlayerTierHistoryScalarAggregateOutput(TypedDict, total=False):
    """PlayerTierHistory output including scalar fields"""
    id: _str
    playerSeasonId: _str
    tierId: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PlayerTierHistoryMinAggregateOutput = PlayerTierHistoryScalarAggregateOutput
PlayerTierHistoryMaxAggregateOutput = PlayerTierHistoryScalarAggregateOutput


class PlayerTierHistoryMaxAggregateInput(TypedDict, total=False):
    """PlayerTierHistory input for aggregating by max"""
    id: bool
    playerSeasonId: bool
    tierId: bool
    startDate: bool
    endDate: bool
    createdAt: bool
    updatedAt: bool


class PlayerTierHistoryMinAggregateInput(TypedDict, total=False):
    """PlayerTierHistory input for aggregating by min"""
    id: bool
    playerSeasonId: bool
    tierId: bool
    startDate: bool
    endDate: bool
    createdAt: bool
    updatedAt: bool


class PlayerTierHistoryNumberAggregateInput(TypedDict, total=False):
    """PlayerTierHistory input for aggregating numbers"""


PlayerTierHistoryAvgAggregateInput = PlayerTierHistoryNumberAggregateInput
PlayerTierHistorySumAggregateInput = PlayerTierHistoryNumberAggregateInput


PlayerTierHistoryCountAggregateInput = TypedDict(
    'PlayerTierHistoryCountAggregateInput',
    {
        'id': bool,
        'playerSeasonId': bool,
        'tierId': bool,
        'startDate': bool,
        'endDate': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PlayerTierHistoryCountAggregateOutput = TypedDict(
    'PlayerTierHistoryCountAggregateOutput',
    {
        'id': int,
        'playerSeasonId': int,
        'tierId': int,
        'startDate': int,
        'endDate': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PlayerTierHistoryKeys = Literal[
    'id',
    'playerSeasonId',
    'tierId',
    'startDate',
    'endDate',
    'createdAt',
    'updatedAt',
    'playerSeason',
    'tier',
]
PlayerTierHistoryScalarFieldKeys = Literal[
    'id',
    'playerSeasonId',
    'tierId',
    'startDate',
    'endDate',
    'createdAt',
    'updatedAt',
]
PlayerTierHistoryScalarFieldKeysT = TypeVar('PlayerTierHistoryScalarFieldKeysT', bound=PlayerTierHistoryScalarFieldKeys)

PlayerTierHistoryRelationalFieldKeys = Literal[
        'playerSeason',
        'tier',
    ]

# PlayerTeamSeason types

class PlayerTeamSeasonOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayerTeamSeason create method"""
    id: _str
    playerSeasonId: _str
    teamSeasonId: _str
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: Optional[_int]
    goalsAgainst: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonCreateNestedWithoutRelationsInput'
    teamSeason: 'TeamSeasonCreateNestedWithoutRelationsInput'
    matches: 'PlayerMatchCreateManyNestedWithoutRelationsInput'


class PlayerTeamSeasonCreateInput(PlayerTeamSeasonOptionalCreateInput):
    """Required arguments to the PlayerTeamSeason create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerTeamSeasonOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayerTeamSeason create method, without relations"""
    id: _str
    playerSeasonId: _str
    teamSeasonId: _str
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: Optional[_int]
    goalsAgainst: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerTeamSeasonCreateWithoutRelationsInput(PlayerTeamSeasonOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayerTeamSeason create method, without relations"""

class PlayerTeamSeasonConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerTeamSeasonCreateWithoutRelationsInput'
    where: 'PlayerTeamSeasonWhereUniqueInput'

class PlayerTeamSeasonCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerTeamSeasonCreateWithoutRelationsInput'
    connect: 'PlayerTeamSeasonWhereUniqueInput'
    connect_or_create: 'PlayerTeamSeasonConnectOrCreateWithoutRelationsInput'


class PlayerTeamSeasonCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerTeamSeasonCreateWithoutRelationsInput', List['PlayerTeamSeasonCreateWithoutRelationsInput']]
    connect: Union['PlayerTeamSeasonWhereUniqueInput', List['PlayerTeamSeasonWhereUniqueInput']]
    connect_or_create: Union['PlayerTeamSeasonConnectOrCreateWithoutRelationsInput', List['PlayerTeamSeasonConnectOrCreateWithoutRelationsInput']]

_PlayerTeamSeasonWhereUnique_id_Input = TypedDict(
    '_PlayerTeamSeasonWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlayerTeamSeasonWhereUniqueInput = _PlayerTeamSeasonWhereUnique_id_Input


class PlayerTeamSeasonUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    assists: Union[AtomicIntInput, _int]
    gamesPlayed: Union[AtomicIntInput, _int]
    giveaways: Union[AtomicIntInput, _int]
    goals: Union[AtomicIntInput, _int]
    hits: Union[AtomicIntInput, _int]
    penaltyMinutes: Union[AtomicIntInput, _int]
    plusMinus: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    takeaways: Union[AtomicIntInput, _int]
    saves: Optional[Union[AtomicIntInput, _int]]
    goalsAgainst: Optional[Union[AtomicIntInput, _int]]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonUpdateOneWithoutRelationsInput'
    teamSeason: 'TeamSeasonUpdateOneWithoutRelationsInput'
    matches: 'PlayerMatchUpdateManyWithoutRelationsInput'


class PlayerTeamSeasonUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    assists: Union[AtomicIntInput, _int]
    gamesPlayed: Union[AtomicIntInput, _int]
    giveaways: Union[AtomicIntInput, _int]
    goals: Union[AtomicIntInput, _int]
    hits: Union[AtomicIntInput, _int]
    penaltyMinutes: Union[AtomicIntInput, _int]
    plusMinus: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    takeaways: Union[AtomicIntInput, _int]
    saves: Optional[Union[AtomicIntInput, _int]]
    goalsAgainst: Optional[Union[AtomicIntInput, _int]]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerTeamSeasonUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerTeamSeasonCreateWithoutRelationsInput']
    connect: List['PlayerTeamSeasonWhereUniqueInput']
    connect_or_create: List['PlayerTeamSeasonConnectOrCreateWithoutRelationsInput']
    set: List['PlayerTeamSeasonWhereUniqueInput']
    disconnect: List['PlayerTeamSeasonWhereUniqueInput']
    delete: List['PlayerTeamSeasonWhereUniqueInput']

    # TODO
    # update: List['PlayerTeamSeasonUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerTeamSeasonUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerTeamSeasonScalarWhereInput']
    # upsert: List['PlayerTeamSeasonUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerTeamSeasonUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerTeamSeasonCreateWithoutRelationsInput'
    connect: 'PlayerTeamSeasonWhereUniqueInput'
    connect_or_create: 'PlayerTeamSeasonConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerTeamSeasonUpdateInput'
    # upsert: 'PlayerTeamSeasonUpsertWithoutRelationsInput'


class PlayerTeamSeasonUpsertInput(TypedDict):
    create: 'PlayerTeamSeasonCreateInput'
    update: 'PlayerTeamSeasonUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayerTeamSeason_id_OrderByInput = TypedDict(
    '_PlayerTeamSeason_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_playerSeasonId_OrderByInput = TypedDict(
    '_PlayerTeamSeason_playerSeasonId_OrderByInput',
    {
        'playerSeasonId': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_teamSeasonId_OrderByInput = TypedDict(
    '_PlayerTeamSeason_teamSeasonId_OrderByInput',
    {
        'teamSeasonId': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_assists_OrderByInput = TypedDict(
    '_PlayerTeamSeason_assists_OrderByInput',
    {
        'assists': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_gamesPlayed_OrderByInput = TypedDict(
    '_PlayerTeamSeason_gamesPlayed_OrderByInput',
    {
        'gamesPlayed': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_giveaways_OrderByInput = TypedDict(
    '_PlayerTeamSeason_giveaways_OrderByInput',
    {
        'giveaways': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_goals_OrderByInput = TypedDict(
    '_PlayerTeamSeason_goals_OrderByInput',
    {
        'goals': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_hits_OrderByInput = TypedDict(
    '_PlayerTeamSeason_hits_OrderByInput',
    {
        'hits': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_penaltyMinutes_OrderByInput = TypedDict(
    '_PlayerTeamSeason_penaltyMinutes_OrderByInput',
    {
        'penaltyMinutes': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_plusMinus_OrderByInput = TypedDict(
    '_PlayerTeamSeason_plusMinus_OrderByInput',
    {
        'plusMinus': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_shots_OrderByInput = TypedDict(
    '_PlayerTeamSeason_shots_OrderByInput',
    {
        'shots': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_takeaways_OrderByInput = TypedDict(
    '_PlayerTeamSeason_takeaways_OrderByInput',
    {
        'takeaways': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_saves_OrderByInput = TypedDict(
    '_PlayerTeamSeason_saves_OrderByInput',
    {
        'saves': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_goalsAgainst_OrderByInput = TypedDict(
    '_PlayerTeamSeason_goalsAgainst_OrderByInput',
    {
        'goalsAgainst': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_createdAt_OrderByInput = TypedDict(
    '_PlayerTeamSeason_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_updatedAt_OrderByInput = TypedDict(
    '_PlayerTeamSeason_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_RelevanceInner = TypedDict(
    '_PlayerTeamSeason_RelevanceInner',
    {
        'fields': 'List[PlayerTeamSeasonScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayerTeamSeason_RelevanceOrderByInput = TypedDict(
    '_PlayerTeamSeason_RelevanceOrderByInput',
    {
        '_relevance': '_PlayerTeamSeason_RelevanceInner',
    },
    total=True
)

PlayerTeamSeasonOrderByInput = Union[
    '_PlayerTeamSeason_id_OrderByInput',
    '_PlayerTeamSeason_playerSeasonId_OrderByInput',
    '_PlayerTeamSeason_teamSeasonId_OrderByInput',
    '_PlayerTeamSeason_assists_OrderByInput',
    '_PlayerTeamSeason_gamesPlayed_OrderByInput',
    '_PlayerTeamSeason_giveaways_OrderByInput',
    '_PlayerTeamSeason_goals_OrderByInput',
    '_PlayerTeamSeason_hits_OrderByInput',
    '_PlayerTeamSeason_penaltyMinutes_OrderByInput',
    '_PlayerTeamSeason_plusMinus_OrderByInput',
    '_PlayerTeamSeason_shots_OrderByInput',
    '_PlayerTeamSeason_takeaways_OrderByInput',
    '_PlayerTeamSeason_saves_OrderByInput',
    '_PlayerTeamSeason_goalsAgainst_OrderByInput',
    '_PlayerTeamSeason_createdAt_OrderByInput',
    '_PlayerTeamSeason_updatedAt_OrderByInput',
    '_PlayerTeamSeason_RelevanceOrderByInput',
]



# recursive PlayerTeamSeason types
# TODO: cleanup these types



PlayerTeamSeasonRelationFilter = TypedDict(
    'PlayerTeamSeasonRelationFilter',
    {
        'is': 'PlayerTeamSeasonWhereInput',
        'is_not': 'PlayerTeamSeasonWhereInput',
    },
    total=False,
)


class PlayerTeamSeasonListRelationFilter(TypedDict, total=False):
    some: 'PlayerTeamSeasonWhereInput'
    none: 'PlayerTeamSeasonWhereInput'
    every: 'PlayerTeamSeasonWhereInput'


class PlayerTeamSeasonInclude(TypedDict, total=False):
    """PlayerTeamSeason relational arguments"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTeamSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTeamSeason']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayerTeamSeason']


class UserIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerTeamSeason']
    notifications: Union[bool, 'FindManyNotificationArgsFromPlayerTeamSeason']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromPlayerTeamSeason']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromPlayerTeamSeason']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTeamSeason']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromPlayerTeamSeason']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerTeamSeason']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromPlayerTeamSeason']


class UserArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayerTeamSeason']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerTeamSeason']


class PlayerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerTeamSeason']


class GamertagHistoryArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    tiers: Union[bool, 'FindManyTierArgsFromPlayerTeamSeason']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerTeamSeason']


class SeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    season: Union[bool, 'SeasonArgsFromPlayerTeamSeason']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromPlayerTeamSeason']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerTeamSeason']


class TierArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromPlayerTeamSeason']
    managers: Union[bool, 'FindManyTeamManagerArgsFromPlayerTeamSeason']
    nhlAffiliate: Union[bool, 'TeamArgsFromPlayerTeamSeason']
    ahlAffiliate: Union[bool, 'TeamArgsFromPlayerTeamSeason']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerTeamSeason']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerTeamSeason']


class TeamArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    team: Union[bool, 'TeamArgsFromPlayerTeamSeason']
    tier: Union[bool, 'TierArgsFromPlayerTeamSeason']
    matches: Union[bool, 'FindManyMatchArgsFromPlayerTeamSeason']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerTeamSeason']
    bids: Union[bool, 'FindManyBidArgsFromPlayerTeamSeason']


class TeamSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    player: Union[bool, 'PlayerArgsFromPlayerTeamSeason']
    season: Union[bool, 'SeasonArgsFromPlayerTeamSeason']
    contract: Union[bool, 'ContractArgsFromPlayerTeamSeason']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerTeamSeason']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerTeamSeason']


class PlayerSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTeamSeason']
    tier: Union[bool, 'TierArgsFromPlayerTeamSeason']


class PlayerTierHistoryArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTeamSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTeamSeason']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayerTeamSeason']


class PlayerTeamSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerTeamSeason']
    bids: Union[bool, 'FindManyBidArgsFromPlayerTeamSeason']


class ContractArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    contract: Union[bool, 'ContractArgsFromPlayerTeamSeason']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTeamSeason']


class BidArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerTeamSeason']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromPlayerTeamSeason']


class MatchArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    match: Union[bool, 'MatchArgsFromPlayerTeamSeason']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayerTeamSeason']


class PlayerMatchArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']


class NotificationArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    author: Union[bool, 'UserArgsFromPlayerTeamSeason']
    comments: Union[bool, 'FindManyForumCommentArgsFromPlayerTeamSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTeamSeason']
    followers: Union[bool, 'FindManyForumFollowerArgsFromPlayerTeamSeason']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerTeamSeason']


class ForumPostArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerTeamSeason']
    comment: Union[bool, 'ForumCommentArgsFromPlayerTeamSeason']


class ForumReactionArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerTeamSeason']


class ForumFollowerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerTeamSeason']


class ForumPostSubscriptionArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    author: Union[bool, 'UserArgsFromPlayerTeamSeason']
    post: Union[bool, 'ForumPostArgsFromPlayerTeamSeason']
    quotedComment: Union[bool, 'ForumCommentArgsFromPlayerTeamSeason']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromPlayerTeamSeason']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerTeamSeason']


class ForumCommentArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromPlayerTeamSeason(TypedDict, total=False):
    """Relational arguments for PlayerTeamSeason"""
    user: Union[bool, 'UserArgsFromPlayerTeamSeason']
    team: Union[bool, 'TeamArgsFromPlayerTeamSeason']


class TeamManagerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromPlayerTeamSeason(TypedDict, total=False):
    """Arguments for PlayerTeamSeason"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyPlayerTeamSeasonArgs = FindManyPlayerTeamSeasonArgsFromPlayerTeamSeason
FindFirstPlayerTeamSeasonArgs = FindManyPlayerTeamSeasonArgsFromPlayerTeamSeason


class PlayerTeamSeasonWhereInput(TypedDict, total=False):
    """PlayerTeamSeason arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    playerSeasonId: Union[_str, 'types.StringFilter']
    teamSeasonId: Union[_str, 'types.StringFilter']
    assists: Union[_int, 'types.IntFilter']
    gamesPlayed: Union[_int, 'types.IntFilter']
    giveaways: Union[_int, 'types.IntFilter']
    goals: Union[_int, 'types.IntFilter']
    hits: Union[_int, 'types.IntFilter']
    penaltyMinutes: Union[_int, 'types.IntFilter']
    plusMinus: Union[_int, 'types.IntFilter']
    shots: Union[_int, 'types.IntFilter']
    takeaways: Union[_int, 'types.IntFilter']
    saves: Union[None, _int, 'types.IntFilter']
    goalsAgainst: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    playerSeason: 'PlayerSeasonRelationFilter'
    teamSeason: 'TeamSeasonRelationFilter'
    matches: 'PlayerMatchListRelationFilter'

    # should be noted that AND and NOT should be Union['PlayerTeamSeasonWhereInput', List['PlayerTeamSeasonWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlayerTeamSeasonWhereInput']
    OR: List['PlayerTeamSeasonWhereInput']
    NOT: List['PlayerTeamSeasonWhereInput']



# aggregate PlayerTeamSeason types


class PlayerTeamSeasonScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayerTeamSeason arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    playerSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    teamSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    assists: Union[_int, 'types.IntWithAggregatesFilter']
    gamesPlayed: Union[_int, 'types.IntWithAggregatesFilter']
    giveaways: Union[_int, 'types.IntWithAggregatesFilter']
    goals: Union[_int, 'types.IntWithAggregatesFilter']
    hits: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    plusMinus: Union[_int, 'types.IntWithAggregatesFilter']
    shots: Union[_int, 'types.IntWithAggregatesFilter']
    takeaways: Union[_int, 'types.IntWithAggregatesFilter']
    saves: Union[_int, 'types.IntWithAggregatesFilter']
    goalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PlayerTeamSeasonScalarWhereWithAggregatesInput']
    OR: List['PlayerTeamSeasonScalarWhereWithAggregatesInput']
    NOT: List['PlayerTeamSeasonScalarWhereWithAggregatesInput']



class PlayerTeamSeasonGroupByOutput(TypedDict, total=False):
    id: _str
    playerSeasonId: _str
    teamSeasonId: _str
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: _int
    goalsAgainst: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PlayerTeamSeasonSumAggregateOutput'
    _avg: 'PlayerTeamSeasonAvgAggregateOutput'
    _min: 'PlayerTeamSeasonMinAggregateOutput'
    _max: 'PlayerTeamSeasonMaxAggregateOutput'
    _count: 'PlayerTeamSeasonCountAggregateOutput'


class PlayerTeamSeasonAvgAggregateOutput(TypedDict, total=False):
    """PlayerTeamSeason output for aggregating averages"""
    assists: float
    gamesPlayed: float
    giveaways: float
    goals: float
    hits: float
    penaltyMinutes: float
    plusMinus: float
    shots: float
    takeaways: float
    saves: float
    goalsAgainst: float


class PlayerTeamSeasonSumAggregateOutput(TypedDict, total=False):
    """PlayerTeamSeason output for aggregating sums"""
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: _int
    goalsAgainst: _int


class PlayerTeamSeasonScalarAggregateOutput(TypedDict, total=False):
    """PlayerTeamSeason output including scalar fields"""
    id: _str
    playerSeasonId: _str
    teamSeasonId: _str
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: _int
    goalsAgainst: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PlayerTeamSeasonMinAggregateOutput = PlayerTeamSeasonScalarAggregateOutput
PlayerTeamSeasonMaxAggregateOutput = PlayerTeamSeasonScalarAggregateOutput


class PlayerTeamSeasonMaxAggregateInput(TypedDict, total=False):
    """PlayerTeamSeason input for aggregating by max"""
    id: bool
    playerSeasonId: bool
    teamSeasonId: bool
    assists: bool
    gamesPlayed: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    shots: bool
    takeaways: bool
    saves: bool
    goalsAgainst: bool
    createdAt: bool
    updatedAt: bool


class PlayerTeamSeasonMinAggregateInput(TypedDict, total=False):
    """PlayerTeamSeason input for aggregating by min"""
    id: bool
    playerSeasonId: bool
    teamSeasonId: bool
    assists: bool
    gamesPlayed: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    shots: bool
    takeaways: bool
    saves: bool
    goalsAgainst: bool
    createdAt: bool
    updatedAt: bool


class PlayerTeamSeasonNumberAggregateInput(TypedDict, total=False):
    """PlayerTeamSeason input for aggregating numbers"""
    assists: bool
    gamesPlayed: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    shots: bool
    takeaways: bool
    saves: bool
    goalsAgainst: bool


PlayerTeamSeasonAvgAggregateInput = PlayerTeamSeasonNumberAggregateInput
PlayerTeamSeasonSumAggregateInput = PlayerTeamSeasonNumberAggregateInput


PlayerTeamSeasonCountAggregateInput = TypedDict(
    'PlayerTeamSeasonCountAggregateInput',
    {
        'id': bool,
        'playerSeasonId': bool,
        'teamSeasonId': bool,
        'assists': bool,
        'gamesPlayed': bool,
        'giveaways': bool,
        'goals': bool,
        'hits': bool,
        'penaltyMinutes': bool,
        'plusMinus': bool,
        'shots': bool,
        'takeaways': bool,
        'saves': bool,
        'goalsAgainst': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PlayerTeamSeasonCountAggregateOutput = TypedDict(
    'PlayerTeamSeasonCountAggregateOutput',
    {
        'id': int,
        'playerSeasonId': int,
        'teamSeasonId': int,
        'assists': int,
        'gamesPlayed': int,
        'giveaways': int,
        'goals': int,
        'hits': int,
        'penaltyMinutes': int,
        'plusMinus': int,
        'shots': int,
        'takeaways': int,
        'saves': int,
        'goalsAgainst': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PlayerTeamSeasonKeys = Literal[
    'id',
    'playerSeasonId',
    'teamSeasonId',
    'assists',
    'gamesPlayed',
    'giveaways',
    'goals',
    'hits',
    'penaltyMinutes',
    'plusMinus',
    'shots',
    'takeaways',
    'saves',
    'goalsAgainst',
    'createdAt',
    'updatedAt',
    'playerSeason',
    'teamSeason',
    'matches',
]
PlayerTeamSeasonScalarFieldKeys = Literal[
    'id',
    'playerSeasonId',
    'teamSeasonId',
    'assists',
    'gamesPlayed',
    'giveaways',
    'goals',
    'hits',
    'penaltyMinutes',
    'plusMinus',
    'shots',
    'takeaways',
    'saves',
    'goalsAgainst',
    'createdAt',
    'updatedAt',
]
PlayerTeamSeasonScalarFieldKeysT = TypeVar('PlayerTeamSeasonScalarFieldKeysT', bound=PlayerTeamSeasonScalarFieldKeys)

PlayerTeamSeasonRelationalFieldKeys = Literal[
        'playerSeason',
        'teamSeason',
        'matches',
    ]

# Contract types

class ContractOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Contract create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonCreateNestedWithoutRelationsInput'
    bids: 'BidCreateManyNestedWithoutRelationsInput'


class ContractCreateInput(ContractOptionalCreateInput):
    """Required arguments to the Contract create method"""
    amount: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ContractOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Contract create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ContractCreateWithoutRelationsInput(ContractOptionalCreateWithoutRelationsInput):
    """Required arguments to the Contract create method, without relations"""
    amount: _int

class ContractConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ContractCreateWithoutRelationsInput'
    where: 'ContractWhereUniqueInput'

class ContractCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ContractCreateWithoutRelationsInput'
    connect: 'ContractWhereUniqueInput'
    connect_or_create: 'ContractConnectOrCreateWithoutRelationsInput'


class ContractCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ContractCreateWithoutRelationsInput', List['ContractCreateWithoutRelationsInput']]
    connect: Union['ContractWhereUniqueInput', List['ContractWhereUniqueInput']]
    connect_or_create: Union['ContractConnectOrCreateWithoutRelationsInput', List['ContractConnectOrCreateWithoutRelationsInput']]

_ContractWhereUnique_id_Input = TypedDict(
    '_ContractWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ContractWhereUniqueInput = _ContractWhereUnique_id_Input


class ContractUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    amount: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: 'PlayerSeasonUpdateOneWithoutRelationsInput'
    bids: 'BidUpdateManyWithoutRelationsInput'


class ContractUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ContractUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ContractCreateWithoutRelationsInput']
    connect: List['ContractWhereUniqueInput']
    connect_or_create: List['ContractConnectOrCreateWithoutRelationsInput']
    set: List['ContractWhereUniqueInput']
    disconnect: List['ContractWhereUniqueInput']
    delete: List['ContractWhereUniqueInput']

    # TODO
    # update: List['ContractUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ContractUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ContractScalarWhereInput']
    # upsert: List['ContractUpserteWithWhereUniqueWithoutRelationsInput']


class ContractUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ContractCreateWithoutRelationsInput'
    connect: 'ContractWhereUniqueInput'
    connect_or_create: 'ContractConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ContractUpdateInput'
    # upsert: 'ContractUpsertWithoutRelationsInput'


class ContractUpsertInput(TypedDict):
    create: 'ContractCreateInput'
    update: 'ContractUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Contract_id_OrderByInput = TypedDict(
    '_Contract_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Contract_amount_OrderByInput = TypedDict(
    '_Contract_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Contract_createdAt_OrderByInput = TypedDict(
    '_Contract_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Contract_updatedAt_OrderByInput = TypedDict(
    '_Contract_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Contract_RelevanceInner = TypedDict(
    '_Contract_RelevanceInner',
    {
        'fields': 'List[ContractScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Contract_RelevanceOrderByInput = TypedDict(
    '_Contract_RelevanceOrderByInput',
    {
        '_relevance': '_Contract_RelevanceInner',
    },
    total=True
)

ContractOrderByInput = Union[
    '_Contract_id_OrderByInput',
    '_Contract_amount_OrderByInput',
    '_Contract_createdAt_OrderByInput',
    '_Contract_updatedAt_OrderByInput',
    '_Contract_RelevanceOrderByInput',
]



# recursive Contract types
# TODO: cleanup these types



ContractRelationFilter = TypedDict(
    'ContractRelationFilter',
    {
        'is': 'ContractWhereInput',
        'is_not': 'ContractWhereInput',
    },
    total=False,
)


class ContractListRelationFilter(TypedDict, total=False):
    some: 'ContractWhereInput'
    none: 'ContractWhereInput'
    every: 'ContractWhereInput'


class ContractInclude(TypedDict, total=False):
    """Contract relational arguments"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromContract']
    bids: Union[bool, 'FindManyBidArgsFromContract']


class UserIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    player: Union[bool, 'PlayerArgsFromContract']
    notifications: Union[bool, 'FindManyNotificationArgsFromContract']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromContract']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromContract']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromContract']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromContract']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromContract']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromContract']


class UserArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromContract']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromContract']


class PlayerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    player: Union[bool, 'PlayerArgsFromContract']


class GamertagHistoryArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    tiers: Union[bool, 'FindManyTierArgsFromContract']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromContract']


class SeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    season: Union[bool, 'SeasonArgsFromContract']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromContract']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromContract']


class TierArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromContract']
    managers: Union[bool, 'FindManyTeamManagerArgsFromContract']
    nhlAffiliate: Union[bool, 'TeamArgsFromContract']
    ahlAffiliate: Union[bool, 'TeamArgsFromContract']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromContract']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromContract']


class TeamArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    team: Union[bool, 'TeamArgsFromContract']
    tier: Union[bool, 'TierArgsFromContract']
    matches: Union[bool, 'FindManyMatchArgsFromContract']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromContract']
    bids: Union[bool, 'FindManyBidArgsFromContract']


class TeamSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    player: Union[bool, 'PlayerArgsFromContract']
    season: Union[bool, 'SeasonArgsFromContract']
    contract: Union[bool, 'ContractArgsFromContract']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromContract']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromContract']


class PlayerSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromContract']
    tier: Union[bool, 'TierArgsFromContract']


class PlayerTierHistoryArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromContract']
    teamSeason: Union[bool, 'TeamSeasonArgsFromContract']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromContract']


class PlayerTeamSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromContract']
    bids: Union[bool, 'FindManyBidArgsFromContract']


class ContractArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    contract: Union[bool, 'ContractArgsFromContract']
    teamSeason: Union[bool, 'TeamSeasonArgsFromContract']


class BidArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromContract']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromContract']


class MatchArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    match: Union[bool, 'MatchArgsFromContract']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromContract']


class PlayerMatchArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']


class NotificationArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    author: Union[bool, 'UserArgsFromContract']
    comments: Union[bool, 'FindManyForumCommentArgsFromContract']
    reactions: Union[bool, 'FindManyForumReactionArgsFromContract']
    followers: Union[bool, 'FindManyForumFollowerArgsFromContract']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromContract']


class ForumPostArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']
    post: Union[bool, 'ForumPostArgsFromContract']
    comment: Union[bool, 'ForumCommentArgsFromContract']


class ForumReactionArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']
    post: Union[bool, 'ForumPostArgsFromContract']


class ForumFollowerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']
    post: Union[bool, 'ForumPostArgsFromContract']


class ForumPostSubscriptionArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    author: Union[bool, 'UserArgsFromContract']
    post: Union[bool, 'ForumPostArgsFromContract']
    quotedComment: Union[bool, 'ForumCommentArgsFromContract']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromContract']
    reactions: Union[bool, 'FindManyForumReactionArgsFromContract']


class ForumCommentArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromContract(TypedDict, total=False):
    """Relational arguments for Contract"""
    user: Union[bool, 'UserArgsFromContract']
    team: Union[bool, 'TeamArgsFromContract']


class TeamManagerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromContract(TypedDict, total=False):
    """Arguments for Contract"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyContractArgs = FindManyContractArgsFromContract
FindFirstContractArgs = FindManyContractArgsFromContract


class ContractWhereInput(TypedDict, total=False):
    """Contract arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    amount: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    playerSeason: 'PlayerSeasonRelationFilter'
    bids: 'BidListRelationFilter'

    # should be noted that AND and NOT should be Union['ContractWhereInput', List['ContractWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ContractWhereInput']
    OR: List['ContractWhereInput']
    NOT: List['ContractWhereInput']



# aggregate Contract types


class ContractScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Contract arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ContractScalarWhereWithAggregatesInput']
    OR: List['ContractScalarWhereWithAggregatesInput']
    NOT: List['ContractScalarWhereWithAggregatesInput']



class ContractGroupByOutput(TypedDict, total=False):
    id: _str
    amount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ContractSumAggregateOutput'
    _avg: 'ContractAvgAggregateOutput'
    _min: 'ContractMinAggregateOutput'
    _max: 'ContractMaxAggregateOutput'
    _count: 'ContractCountAggregateOutput'


class ContractAvgAggregateOutput(TypedDict, total=False):
    """Contract output for aggregating averages"""
    amount: float


class ContractSumAggregateOutput(TypedDict, total=False):
    """Contract output for aggregating sums"""
    amount: _int


class ContractScalarAggregateOutput(TypedDict, total=False):
    """Contract output including scalar fields"""
    id: _str
    amount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ContractMinAggregateOutput = ContractScalarAggregateOutput
ContractMaxAggregateOutput = ContractScalarAggregateOutput


class ContractMaxAggregateInput(TypedDict, total=False):
    """Contract input for aggregating by max"""
    id: bool
    amount: bool
    createdAt: bool
    updatedAt: bool


class ContractMinAggregateInput(TypedDict, total=False):
    """Contract input for aggregating by min"""
    id: bool
    amount: bool
    createdAt: bool
    updatedAt: bool


class ContractNumberAggregateInput(TypedDict, total=False):
    """Contract input for aggregating numbers"""
    amount: bool


ContractAvgAggregateInput = ContractNumberAggregateInput
ContractSumAggregateInput = ContractNumberAggregateInput


ContractCountAggregateInput = TypedDict(
    'ContractCountAggregateInput',
    {
        'id': bool,
        'amount': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ContractCountAggregateOutput = TypedDict(
    'ContractCountAggregateOutput',
    {
        'id': int,
        'amount': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ContractKeys = Literal[
    'id',
    'amount',
    'createdAt',
    'updatedAt',
    'playerSeason',
    'bids',
]
ContractScalarFieldKeys = Literal[
    'id',
    'amount',
    'createdAt',
    'updatedAt',
]
ContractScalarFieldKeysT = TypeVar('ContractScalarFieldKeysT', bound=ContractScalarFieldKeys)

ContractRelationalFieldKeys = Literal[
        'playerSeason',
        'bids',
    ]

# Bid types

class BidOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Bid create method"""
    id: _str
    contract: 'ContractCreateNestedWithoutRelationsInput'
    contractId: _str
    teamSeason: 'TeamSeasonCreateNestedWithoutRelationsInput'
    teamSeasonId: _str
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BidCreateInput(BidOptionalCreateInput):
    """Required arguments to the Bid create method"""
    amount: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BidOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Bid create method, without relations"""
    id: _str
    contractId: _str
    teamSeasonId: _str
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BidCreateWithoutRelationsInput(BidOptionalCreateWithoutRelationsInput):
    """Required arguments to the Bid create method, without relations"""
    amount: _int

class BidConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BidCreateWithoutRelationsInput'
    where: 'BidWhereUniqueInput'

class BidCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BidCreateWithoutRelationsInput'
    connect: 'BidWhereUniqueInput'
    connect_or_create: 'BidConnectOrCreateWithoutRelationsInput'


class BidCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BidCreateWithoutRelationsInput', List['BidCreateWithoutRelationsInput']]
    connect: Union['BidWhereUniqueInput', List['BidWhereUniqueInput']]
    connect_or_create: Union['BidConnectOrCreateWithoutRelationsInput', List['BidConnectOrCreateWithoutRelationsInput']]

_BidWhereUnique_id_Input = TypedDict(
    '_BidWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

BidWhereUniqueInput = _BidWhereUnique_id_Input


class BidUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    contract: 'ContractUpdateOneWithoutRelationsInput'
    teamSeason: 'TeamSeasonUpdateOneWithoutRelationsInput'
    amount: Union[AtomicIntInput, _int]
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BidUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: Union[AtomicIntInput, _int]
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BidUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BidCreateWithoutRelationsInput']
    connect: List['BidWhereUniqueInput']
    connect_or_create: List['BidConnectOrCreateWithoutRelationsInput']
    set: List['BidWhereUniqueInput']
    disconnect: List['BidWhereUniqueInput']
    delete: List['BidWhereUniqueInput']

    # TODO
    # update: List['BidUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BidUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BidScalarWhereInput']
    # upsert: List['BidUpserteWithWhereUniqueWithoutRelationsInput']


class BidUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BidCreateWithoutRelationsInput'
    connect: 'BidWhereUniqueInput'
    connect_or_create: 'BidConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BidUpdateInput'
    # upsert: 'BidUpsertWithoutRelationsInput'


class BidUpsertInput(TypedDict):
    create: 'BidCreateInput'
    update: 'BidUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Bid_id_OrderByInput = TypedDict(
    '_Bid_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Bid_contractId_OrderByInput = TypedDict(
    '_Bid_contractId_OrderByInput',
    {
        'contractId': 'SortOrder',
    },
    total=True
)

_Bid_teamSeasonId_OrderByInput = TypedDict(
    '_Bid_teamSeasonId_OrderByInput',
    {
        'teamSeasonId': 'SortOrder',
    },
    total=True
)

_Bid_amount_OrderByInput = TypedDict(
    '_Bid_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Bid_status_OrderByInput = TypedDict(
    '_Bid_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Bid_createdAt_OrderByInput = TypedDict(
    '_Bid_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Bid_updatedAt_OrderByInput = TypedDict(
    '_Bid_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Bid_RelevanceInner = TypedDict(
    '_Bid_RelevanceInner',
    {
        'fields': 'List[BidScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Bid_RelevanceOrderByInput = TypedDict(
    '_Bid_RelevanceOrderByInput',
    {
        '_relevance': '_Bid_RelevanceInner',
    },
    total=True
)

BidOrderByInput = Union[
    '_Bid_id_OrderByInput',
    '_Bid_contractId_OrderByInput',
    '_Bid_teamSeasonId_OrderByInput',
    '_Bid_amount_OrderByInput',
    '_Bid_status_OrderByInput',
    '_Bid_createdAt_OrderByInput',
    '_Bid_updatedAt_OrderByInput',
    '_Bid_RelevanceOrderByInput',
]



# recursive Bid types
# TODO: cleanup these types



BidRelationFilter = TypedDict(
    'BidRelationFilter',
    {
        'is': 'BidWhereInput',
        'is_not': 'BidWhereInput',
    },
    total=False,
)


class BidListRelationFilter(TypedDict, total=False):
    some: 'BidWhereInput'
    none: 'BidWhereInput'
    every: 'BidWhereInput'


class BidInclude(TypedDict, total=False):
    """Bid relational arguments"""
    contract: Union[bool, 'ContractArgsFromBid']
    teamSeason: Union[bool, 'TeamSeasonArgsFromBid']


class UserIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    player: Union[bool, 'PlayerArgsFromBid']
    notifications: Union[bool, 'FindManyNotificationArgsFromBid']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromBid']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromBid']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromBid']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromBid']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromBid']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromBid']


class UserArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromBid']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromBid']


class PlayerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    player: Union[bool, 'PlayerArgsFromBid']


class GamertagHistoryArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    tiers: Union[bool, 'FindManyTierArgsFromBid']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromBid']


class SeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    season: Union[bool, 'SeasonArgsFromBid']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromBid']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromBid']


class TierArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromBid']
    managers: Union[bool, 'FindManyTeamManagerArgsFromBid']
    nhlAffiliate: Union[bool, 'TeamArgsFromBid']
    ahlAffiliate: Union[bool, 'TeamArgsFromBid']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromBid']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromBid']


class TeamArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    team: Union[bool, 'TeamArgsFromBid']
    tier: Union[bool, 'TierArgsFromBid']
    matches: Union[bool, 'FindManyMatchArgsFromBid']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromBid']
    bids: Union[bool, 'FindManyBidArgsFromBid']


class TeamSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    player: Union[bool, 'PlayerArgsFromBid']
    season: Union[bool, 'SeasonArgsFromBid']
    contract: Union[bool, 'ContractArgsFromBid']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromBid']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromBid']


class PlayerSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromBid']
    tier: Union[bool, 'TierArgsFromBid']


class PlayerTierHistoryArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromBid']
    teamSeason: Union[bool, 'TeamSeasonArgsFromBid']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromBid']


class PlayerTeamSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromBid']
    bids: Union[bool, 'FindManyBidArgsFromBid']


class ContractArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    contract: Union[bool, 'ContractArgsFromBid']
    teamSeason: Union[bool, 'TeamSeasonArgsFromBid']


class BidArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromBid']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromBid']


class MatchArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    match: Union[bool, 'MatchArgsFromBid']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromBid']


class PlayerMatchArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']


class NotificationArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    author: Union[bool, 'UserArgsFromBid']
    comments: Union[bool, 'FindManyForumCommentArgsFromBid']
    reactions: Union[bool, 'FindManyForumReactionArgsFromBid']
    followers: Union[bool, 'FindManyForumFollowerArgsFromBid']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromBid']


class ForumPostArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']
    post: Union[bool, 'ForumPostArgsFromBid']
    comment: Union[bool, 'ForumCommentArgsFromBid']


class ForumReactionArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']
    post: Union[bool, 'ForumPostArgsFromBid']


class ForumFollowerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']
    post: Union[bool, 'ForumPostArgsFromBid']


class ForumPostSubscriptionArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    author: Union[bool, 'UserArgsFromBid']
    post: Union[bool, 'ForumPostArgsFromBid']
    quotedComment: Union[bool, 'ForumCommentArgsFromBid']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromBid']
    reactions: Union[bool, 'FindManyForumReactionArgsFromBid']


class ForumCommentArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromBid(TypedDict, total=False):
    """Relational arguments for Bid"""
    user: Union[bool, 'UserArgsFromBid']
    team: Union[bool, 'TeamArgsFromBid']


class TeamManagerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromBid(TypedDict, total=False):
    """Arguments for Bid"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyBidArgs = FindManyBidArgsFromBid
FindFirstBidArgs = FindManyBidArgsFromBid


class BidWhereInput(TypedDict, total=False):
    """Bid arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    contract: 'ContractRelationFilter'
    contractId: Union[_str, 'types.StringFilter']
    teamSeason: 'TeamSeasonRelationFilter'
    teamSeasonId: Union[_str, 'types.StringFilter']
    amount: Union[_int, 'types.IntFilter']
    status: 'enums.BidStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BidWhereInput', List['BidWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BidWhereInput']
    OR: List['BidWhereInput']
    NOT: List['BidWhereInput']



# aggregate Bid types


class BidScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Bid arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    contractId: Union[_str, 'types.StringWithAggregatesFilter']
    teamSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.BidStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BidScalarWhereWithAggregatesInput']
    OR: List['BidScalarWhereWithAggregatesInput']
    NOT: List['BidScalarWhereWithAggregatesInput']



class BidGroupByOutput(TypedDict, total=False):
    id: _str
    contractId: _str
    teamSeasonId: _str
    amount: _int
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'BidSumAggregateOutput'
    _avg: 'BidAvgAggregateOutput'
    _min: 'BidMinAggregateOutput'
    _max: 'BidMaxAggregateOutput'
    _count: 'BidCountAggregateOutput'


class BidAvgAggregateOutput(TypedDict, total=False):
    """Bid output for aggregating averages"""
    amount: float


class BidSumAggregateOutput(TypedDict, total=False):
    """Bid output for aggregating sums"""
    amount: _int


class BidScalarAggregateOutput(TypedDict, total=False):
    """Bid output including scalar fields"""
    id: _str
    contractId: _str
    teamSeasonId: _str
    amount: _int
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


BidMinAggregateOutput = BidScalarAggregateOutput
BidMaxAggregateOutput = BidScalarAggregateOutput


class BidMaxAggregateInput(TypedDict, total=False):
    """Bid input for aggregating by max"""
    id: bool
    contractId: bool
    teamSeasonId: bool
    amount: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class BidMinAggregateInput(TypedDict, total=False):
    """Bid input for aggregating by min"""
    id: bool
    contractId: bool
    teamSeasonId: bool
    amount: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class BidNumberAggregateInput(TypedDict, total=False):
    """Bid input for aggregating numbers"""
    amount: bool


BidAvgAggregateInput = BidNumberAggregateInput
BidSumAggregateInput = BidNumberAggregateInput


BidCountAggregateInput = TypedDict(
    'BidCountAggregateInput',
    {
        'id': bool,
        'contractId': bool,
        'teamSeasonId': bool,
        'amount': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

BidCountAggregateOutput = TypedDict(
    'BidCountAggregateOutput',
    {
        'id': int,
        'contractId': int,
        'teamSeasonId': int,
        'amount': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


BidKeys = Literal[
    'id',
    'contract',
    'contractId',
    'teamSeason',
    'teamSeasonId',
    'amount',
    'status',
    'createdAt',
    'updatedAt',
]
BidScalarFieldKeys = Literal[
    'id',
    'contractId',
    'teamSeasonId',
    'amount',
    'status',
    'createdAt',
    'updatedAt',
]
BidScalarFieldKeysT = TypeVar('BidScalarFieldKeysT', bound=BidScalarFieldKeys)

BidRelationalFieldKeys = Literal[
        'contract',
        'teamSeason',
    ]

# Match types

class MatchOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Match create method"""
    id: _str
    teamSeasonId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    teamSeason: 'TeamSeasonCreateNestedWithoutRelationsInput'
    playerStats: 'PlayerMatchCreateManyNestedWithoutRelationsInput'


class MatchCreateInput(MatchOptionalCreateInput):
    """Required arguments to the Match create method"""
    eaMatchId: _str
    goalsAgainst: _int
    goalsFor: _int
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MatchOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Match create method, without relations"""
    id: _str
    teamSeasonId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MatchCreateWithoutRelationsInput(MatchOptionalCreateWithoutRelationsInput):
    """Required arguments to the Match create method, without relations"""
    eaMatchId: _str
    goalsAgainst: _int
    goalsFor: _int
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int

class MatchConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MatchCreateWithoutRelationsInput'
    where: 'MatchWhereUniqueInput'

class MatchCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MatchCreateWithoutRelationsInput'
    connect: 'MatchWhereUniqueInput'
    connect_or_create: 'MatchConnectOrCreateWithoutRelationsInput'


class MatchCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MatchCreateWithoutRelationsInput', List['MatchCreateWithoutRelationsInput']]
    connect: Union['MatchWhereUniqueInput', List['MatchWhereUniqueInput']]
    connect_or_create: Union['MatchConnectOrCreateWithoutRelationsInput', List['MatchConnectOrCreateWithoutRelationsInput']]

_MatchWhereUnique_id_Input = TypedDict(
    '_MatchWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

MatchWhereUniqueInput = _MatchWhereUnique_id_Input


class MatchUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    eaMatchId: _str
    goalsAgainst: Union[AtomicIntInput, _int]
    goalsFor: Union[AtomicIntInput, _int]
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: Union[AtomicIntInput, _int]
    penaltyKillOpportunities: Union[AtomicIntInput, _int]
    powerplayGoals: Union[AtomicIntInput, _int]
    powerplayOpportunities: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    shotsAgainst: Union[AtomicIntInput, _int]
    timeOnAttack: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    teamSeason: 'TeamSeasonUpdateOneWithoutRelationsInput'
    playerStats: 'PlayerMatchUpdateManyWithoutRelationsInput'


class MatchUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    eaMatchId: _str
    goalsAgainst: Union[AtomicIntInput, _int]
    goalsFor: Union[AtomicIntInput, _int]
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: Union[AtomicIntInput, _int]
    penaltyKillOpportunities: Union[AtomicIntInput, _int]
    powerplayGoals: Union[AtomicIntInput, _int]
    powerplayOpportunities: Union[AtomicIntInput, _int]
    shots: Union[AtomicIntInput, _int]
    shotsAgainst: Union[AtomicIntInput, _int]
    timeOnAttack: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MatchUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MatchCreateWithoutRelationsInput']
    connect: List['MatchWhereUniqueInput']
    connect_or_create: List['MatchConnectOrCreateWithoutRelationsInput']
    set: List['MatchWhereUniqueInput']
    disconnect: List['MatchWhereUniqueInput']
    delete: List['MatchWhereUniqueInput']

    # TODO
    # update: List['MatchUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MatchUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MatchScalarWhereInput']
    # upsert: List['MatchUpserteWithWhereUniqueWithoutRelationsInput']


class MatchUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MatchCreateWithoutRelationsInput'
    connect: 'MatchWhereUniqueInput'
    connect_or_create: 'MatchConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MatchUpdateInput'
    # upsert: 'MatchUpsertWithoutRelationsInput'


class MatchUpsertInput(TypedDict):
    create: 'MatchCreateInput'
    update: 'MatchUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Match_id_OrderByInput = TypedDict(
    '_Match_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Match_teamSeasonId_OrderByInput = TypedDict(
    '_Match_teamSeasonId_OrderByInput',
    {
        'teamSeasonId': 'SortOrder',
    },
    total=True
)

_Match_eaMatchId_OrderByInput = TypedDict(
    '_Match_eaMatchId_OrderByInput',
    {
        'eaMatchId': 'SortOrder',
    },
    total=True
)

_Match_goalsAgainst_OrderByInput = TypedDict(
    '_Match_goalsAgainst_OrderByInput',
    {
        'goalsAgainst': 'SortOrder',
    },
    total=True
)

_Match_goalsFor_OrderByInput = TypedDict(
    '_Match_goalsFor_OrderByInput',
    {
        'goalsFor': 'SortOrder',
    },
    total=True
)

_Match_opponentClubId_OrderByInput = TypedDict(
    '_Match_opponentClubId_OrderByInput',
    {
        'opponentClubId': 'SortOrder',
    },
    total=True
)

_Match_opponentTeamId_OrderByInput = TypedDict(
    '_Match_opponentTeamId_OrderByInput',
    {
        'opponentTeamId': 'SortOrder',
    },
    total=True
)

_Match_penaltyKillGoalsAgainst_OrderByInput = TypedDict(
    '_Match_penaltyKillGoalsAgainst_OrderByInput',
    {
        'penaltyKillGoalsAgainst': 'SortOrder',
    },
    total=True
)

_Match_penaltyKillOpportunities_OrderByInput = TypedDict(
    '_Match_penaltyKillOpportunities_OrderByInput',
    {
        'penaltyKillOpportunities': 'SortOrder',
    },
    total=True
)

_Match_powerplayGoals_OrderByInput = TypedDict(
    '_Match_powerplayGoals_OrderByInput',
    {
        'powerplayGoals': 'SortOrder',
    },
    total=True
)

_Match_powerplayOpportunities_OrderByInput = TypedDict(
    '_Match_powerplayOpportunities_OrderByInput',
    {
        'powerplayOpportunities': 'SortOrder',
    },
    total=True
)

_Match_shots_OrderByInput = TypedDict(
    '_Match_shots_OrderByInput',
    {
        'shots': 'SortOrder',
    },
    total=True
)

_Match_shotsAgainst_OrderByInput = TypedDict(
    '_Match_shotsAgainst_OrderByInput',
    {
        'shotsAgainst': 'SortOrder',
    },
    total=True
)

_Match_timeOnAttack_OrderByInput = TypedDict(
    '_Match_timeOnAttack_OrderByInput',
    {
        'timeOnAttack': 'SortOrder',
    },
    total=True
)

_Match_createdAt_OrderByInput = TypedDict(
    '_Match_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Match_updatedAt_OrderByInput = TypedDict(
    '_Match_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Match_RelevanceInner = TypedDict(
    '_Match_RelevanceInner',
    {
        'fields': 'List[MatchScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Match_RelevanceOrderByInput = TypedDict(
    '_Match_RelevanceOrderByInput',
    {
        '_relevance': '_Match_RelevanceInner',
    },
    total=True
)

MatchOrderByInput = Union[
    '_Match_id_OrderByInput',
    '_Match_teamSeasonId_OrderByInput',
    '_Match_eaMatchId_OrderByInput',
    '_Match_goalsAgainst_OrderByInput',
    '_Match_goalsFor_OrderByInput',
    '_Match_opponentClubId_OrderByInput',
    '_Match_opponentTeamId_OrderByInput',
    '_Match_penaltyKillGoalsAgainst_OrderByInput',
    '_Match_penaltyKillOpportunities_OrderByInput',
    '_Match_powerplayGoals_OrderByInput',
    '_Match_powerplayOpportunities_OrderByInput',
    '_Match_shots_OrderByInput',
    '_Match_shotsAgainst_OrderByInput',
    '_Match_timeOnAttack_OrderByInput',
    '_Match_createdAt_OrderByInput',
    '_Match_updatedAt_OrderByInput',
    '_Match_RelevanceOrderByInput',
]



# recursive Match types
# TODO: cleanup these types



MatchRelationFilter = TypedDict(
    'MatchRelationFilter',
    {
        'is': 'MatchWhereInput',
        'is_not': 'MatchWhereInput',
    },
    total=False,
)


class MatchListRelationFilter(TypedDict, total=False):
    some: 'MatchWhereInput'
    none: 'MatchWhereInput'
    every: 'MatchWhereInput'


class MatchInclude(TypedDict, total=False):
    """Match relational arguments"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromMatch']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromMatch']


class UserIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    player: Union[bool, 'PlayerArgsFromMatch']
    notifications: Union[bool, 'FindManyNotificationArgsFromMatch']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromMatch']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromMatch']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromMatch']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromMatch']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromMatch']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromMatch']


class UserArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromMatch']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromMatch']


class PlayerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    player: Union[bool, 'PlayerArgsFromMatch']


class GamertagHistoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tiers: Union[bool, 'FindManyTierArgsFromMatch']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromMatch']


class SeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    season: Union[bool, 'SeasonArgsFromMatch']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromMatch']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromMatch']


class TierArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromMatch']
    managers: Union[bool, 'FindManyTeamManagerArgsFromMatch']
    nhlAffiliate: Union[bool, 'TeamArgsFromMatch']
    ahlAffiliate: Union[bool, 'TeamArgsFromMatch']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromMatch']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromMatch']


class TeamArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    team: Union[bool, 'TeamArgsFromMatch']
    tier: Union[bool, 'TierArgsFromMatch']
    matches: Union[bool, 'FindManyMatchArgsFromMatch']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromMatch']
    bids: Union[bool, 'FindManyBidArgsFromMatch']


class TeamSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    player: Union[bool, 'PlayerArgsFromMatch']
    season: Union[bool, 'SeasonArgsFromMatch']
    contract: Union[bool, 'ContractArgsFromMatch']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromMatch']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromMatch']


class PlayerSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromMatch']
    tier: Union[bool, 'TierArgsFromMatch']


class PlayerTierHistoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromMatch']
    teamSeason: Union[bool, 'TeamSeasonArgsFromMatch']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromMatch']


class PlayerTeamSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromMatch']
    bids: Union[bool, 'FindManyBidArgsFromMatch']


class ContractArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    contract: Union[bool, 'ContractArgsFromMatch']
    teamSeason: Union[bool, 'TeamSeasonArgsFromMatch']


class BidArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromMatch']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromMatch']


class MatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    match: Union[bool, 'MatchArgsFromMatch']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromMatch']


class PlayerMatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']


class NotificationArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    author: Union[bool, 'UserArgsFromMatch']
    comments: Union[bool, 'FindManyForumCommentArgsFromMatch']
    reactions: Union[bool, 'FindManyForumReactionArgsFromMatch']
    followers: Union[bool, 'FindManyForumFollowerArgsFromMatch']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromMatch']


class ForumPostArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']
    post: Union[bool, 'ForumPostArgsFromMatch']
    comment: Union[bool, 'ForumCommentArgsFromMatch']


class ForumReactionArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']
    post: Union[bool, 'ForumPostArgsFromMatch']


class ForumFollowerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']
    post: Union[bool, 'ForumPostArgsFromMatch']


class ForumPostSubscriptionArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    author: Union[bool, 'UserArgsFromMatch']
    post: Union[bool, 'ForumPostArgsFromMatch']
    quotedComment: Union[bool, 'ForumCommentArgsFromMatch']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromMatch']
    reactions: Union[bool, 'FindManyForumReactionArgsFromMatch']


class ForumCommentArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    user: Union[bool, 'UserArgsFromMatch']
    team: Union[bool, 'TeamArgsFromMatch']


class TeamManagerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyMatchArgs = FindManyMatchArgsFromMatch
FindFirstMatchArgs = FindManyMatchArgsFromMatch


class MatchWhereInput(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    teamSeasonId: Union[_str, 'types.StringFilter']
    eaMatchId: Union[_str, 'types.StringFilter']
    goalsAgainst: Union[_int, 'types.IntFilter']
    goalsFor: Union[_int, 'types.IntFilter']
    opponentClubId: Union[_str, 'types.StringFilter']
    opponentTeamId: Union[_str, 'types.StringFilter']
    penaltyKillGoalsAgainst: Union[_int, 'types.IntFilter']
    penaltyKillOpportunities: Union[_int, 'types.IntFilter']
    powerplayGoals: Union[_int, 'types.IntFilter']
    powerplayOpportunities: Union[_int, 'types.IntFilter']
    shots: Union[_int, 'types.IntFilter']
    shotsAgainst: Union[_int, 'types.IntFilter']
    timeOnAttack: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    teamSeason: 'TeamSeasonRelationFilter'
    playerStats: 'PlayerMatchListRelationFilter'

    # should be noted that AND and NOT should be Union['MatchWhereInput', List['MatchWhereInput']]
    # but this causes mypy to hang :/
    AND: List['MatchWhereInput']
    OR: List['MatchWhereInput']
    NOT: List['MatchWhereInput']



# aggregate Match types


class MatchScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    teamSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    eaMatchId: Union[_str, 'types.StringWithAggregatesFilter']
    goalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    goalsFor: Union[_int, 'types.IntWithAggregatesFilter']
    opponentClubId: Union[_str, 'types.StringWithAggregatesFilter']
    opponentTeamId: Union[_str, 'types.StringWithAggregatesFilter']
    penaltyKillGoalsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyKillOpportunities: Union[_int, 'types.IntWithAggregatesFilter']
    powerplayGoals: Union[_int, 'types.IntWithAggregatesFilter']
    powerplayOpportunities: Union[_int, 'types.IntWithAggregatesFilter']
    shots: Union[_int, 'types.IntWithAggregatesFilter']
    shotsAgainst: Union[_int, 'types.IntWithAggregatesFilter']
    timeOnAttack: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MatchScalarWhereWithAggregatesInput']
    OR: List['MatchScalarWhereWithAggregatesInput']
    NOT: List['MatchScalarWhereWithAggregatesInput']



class MatchGroupByOutput(TypedDict, total=False):
    id: _str
    teamSeasonId: _str
    eaMatchId: _str
    goalsAgainst: _int
    goalsFor: _int
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'MatchSumAggregateOutput'
    _avg: 'MatchAvgAggregateOutput'
    _min: 'MatchMinAggregateOutput'
    _max: 'MatchMaxAggregateOutput'
    _count: 'MatchCountAggregateOutput'


class MatchAvgAggregateOutput(TypedDict, total=False):
    """Match output for aggregating averages"""
    goalsAgainst: float
    goalsFor: float
    penaltyKillGoalsAgainst: float
    penaltyKillOpportunities: float
    powerplayGoals: float
    powerplayOpportunities: float
    shots: float
    shotsAgainst: float
    timeOnAttack: float


class MatchSumAggregateOutput(TypedDict, total=False):
    """Match output for aggregating sums"""
    goalsAgainst: _int
    goalsFor: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int


class MatchScalarAggregateOutput(TypedDict, total=False):
    """Match output including scalar fields"""
    id: _str
    teamSeasonId: _str
    eaMatchId: _str
    goalsAgainst: _int
    goalsFor: _int
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


MatchMinAggregateOutput = MatchScalarAggregateOutput
MatchMaxAggregateOutput = MatchScalarAggregateOutput


class MatchMaxAggregateInput(TypedDict, total=False):
    """Match input for aggregating by max"""
    id: bool
    teamSeasonId: bool
    eaMatchId: bool
    goalsAgainst: bool
    goalsFor: bool
    opponentClubId: bool
    opponentTeamId: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool
    createdAt: bool
    updatedAt: bool


class MatchMinAggregateInput(TypedDict, total=False):
    """Match input for aggregating by min"""
    id: bool
    teamSeasonId: bool
    eaMatchId: bool
    goalsAgainst: bool
    goalsFor: bool
    opponentClubId: bool
    opponentTeamId: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool
    createdAt: bool
    updatedAt: bool


class MatchNumberAggregateInput(TypedDict, total=False):
    """Match input for aggregating numbers"""
    goalsAgainst: bool
    goalsFor: bool
    penaltyKillGoalsAgainst: bool
    penaltyKillOpportunities: bool
    powerplayGoals: bool
    powerplayOpportunities: bool
    shots: bool
    shotsAgainst: bool
    timeOnAttack: bool


MatchAvgAggregateInput = MatchNumberAggregateInput
MatchSumAggregateInput = MatchNumberAggregateInput


MatchCountAggregateInput = TypedDict(
    'MatchCountAggregateInput',
    {
        'id': bool,
        'teamSeasonId': bool,
        'eaMatchId': bool,
        'goalsAgainst': bool,
        'goalsFor': bool,
        'opponentClubId': bool,
        'opponentTeamId': bool,
        'penaltyKillGoalsAgainst': bool,
        'penaltyKillOpportunities': bool,
        'powerplayGoals': bool,
        'powerplayOpportunities': bool,
        'shots': bool,
        'shotsAgainst': bool,
        'timeOnAttack': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

MatchCountAggregateOutput = TypedDict(
    'MatchCountAggregateOutput',
    {
        'id': int,
        'teamSeasonId': int,
        'eaMatchId': int,
        'goalsAgainst': int,
        'goalsFor': int,
        'opponentClubId': int,
        'opponentTeamId': int,
        'penaltyKillGoalsAgainst': int,
        'penaltyKillOpportunities': int,
        'powerplayGoals': int,
        'powerplayOpportunities': int,
        'shots': int,
        'shotsAgainst': int,
        'timeOnAttack': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


MatchKeys = Literal[
    'id',
    'teamSeasonId',
    'eaMatchId',
    'goalsAgainst',
    'goalsFor',
    'opponentClubId',
    'opponentTeamId',
    'penaltyKillGoalsAgainst',
    'penaltyKillOpportunities',
    'powerplayGoals',
    'powerplayOpportunities',
    'shots',
    'shotsAgainst',
    'timeOnAttack',
    'createdAt',
    'updatedAt',
    'teamSeason',
    'playerStats',
]
MatchScalarFieldKeys = Literal[
    'id',
    'teamSeasonId',
    'eaMatchId',
    'goalsAgainst',
    'goalsFor',
    'opponentClubId',
    'opponentTeamId',
    'penaltyKillGoalsAgainst',
    'penaltyKillOpportunities',
    'powerplayGoals',
    'powerplayOpportunities',
    'shots',
    'shotsAgainst',
    'timeOnAttack',
    'createdAt',
    'updatedAt',
]
MatchScalarFieldKeysT = TypeVar('MatchScalarFieldKeysT', bound=MatchScalarFieldKeys)

MatchRelationalFieldKeys = Literal[
        'teamSeason',
        'playerStats',
    ]

# PlayerMatch types

class PlayerMatchOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayerMatch create method"""
    id: _str
    matchId: _str
    playerTeamSeasonId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    match: 'MatchCreateNestedWithoutRelationsInput'
    playerTeamSeason: 'PlayerTeamSeasonCreateNestedWithoutRelationsInput'


class PlayerMatchCreateInput(PlayerMatchOptionalCreateInput):
    """Required arguments to the PlayerMatch create method"""
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerMatchOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayerMatch create method, without relations"""
    id: _str
    matchId: _str
    playerTeamSeasonId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerMatchCreateWithoutRelationsInput(PlayerMatchOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayerMatch create method, without relations"""
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int

class PlayerMatchConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerMatchCreateWithoutRelationsInput'
    where: 'PlayerMatchWhereUniqueInput'

class PlayerMatchCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerMatchCreateWithoutRelationsInput'
    connect: 'PlayerMatchWhereUniqueInput'
    connect_or_create: 'PlayerMatchConnectOrCreateWithoutRelationsInput'


class PlayerMatchCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerMatchCreateWithoutRelationsInput', List['PlayerMatchCreateWithoutRelationsInput']]
    connect: Union['PlayerMatchWhereUniqueInput', List['PlayerMatchWhereUniqueInput']]
    connect_or_create: Union['PlayerMatchConnectOrCreateWithoutRelationsInput', List['PlayerMatchConnectOrCreateWithoutRelationsInput']]

_PlayerMatchWhereUnique_id_Input = TypedDict(
    '_PlayerMatchWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlayerMatchWhereUniqueInput = _PlayerMatchWhereUnique_id_Input


class PlayerMatchUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    assists: Union[AtomicIntInput, _int]
    giveaways: Union[AtomicIntInput, _int]
    goals: Union[AtomicIntInput, _int]
    hits: Union[AtomicIntInput, _int]
    penaltyMinutes: Union[AtomicIntInput, _int]
    plusMinus: Union[AtomicIntInput, _int]
    ratingDefense: Union[AtomicFloatInput, _float]
    ratingOffense: Union[AtomicFloatInput, _float]
    ratingTeamplay: Union[AtomicFloatInput, _float]
    shots: Union[AtomicIntInput, _int]
    takeaways: Union[AtomicIntInput, _int]
    timeOnIce: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    match: 'MatchUpdateOneWithoutRelationsInput'
    playerTeamSeason: 'PlayerTeamSeasonUpdateOneWithoutRelationsInput'


class PlayerMatchUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    assists: Union[AtomicIntInput, _int]
    giveaways: Union[AtomicIntInput, _int]
    goals: Union[AtomicIntInput, _int]
    hits: Union[AtomicIntInput, _int]
    penaltyMinutes: Union[AtomicIntInput, _int]
    plusMinus: Union[AtomicIntInput, _int]
    ratingDefense: Union[AtomicFloatInput, _float]
    ratingOffense: Union[AtomicFloatInput, _float]
    ratingTeamplay: Union[AtomicFloatInput, _float]
    shots: Union[AtomicIntInput, _int]
    takeaways: Union[AtomicIntInput, _int]
    timeOnIce: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PlayerMatchUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerMatchCreateWithoutRelationsInput']
    connect: List['PlayerMatchWhereUniqueInput']
    connect_or_create: List['PlayerMatchConnectOrCreateWithoutRelationsInput']
    set: List['PlayerMatchWhereUniqueInput']
    disconnect: List['PlayerMatchWhereUniqueInput']
    delete: List['PlayerMatchWhereUniqueInput']

    # TODO
    # update: List['PlayerMatchUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerMatchUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerMatchScalarWhereInput']
    # upsert: List['PlayerMatchUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerMatchUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerMatchCreateWithoutRelationsInput'
    connect: 'PlayerMatchWhereUniqueInput'
    connect_or_create: 'PlayerMatchConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerMatchUpdateInput'
    # upsert: 'PlayerMatchUpsertWithoutRelationsInput'


class PlayerMatchUpsertInput(TypedDict):
    create: 'PlayerMatchCreateInput'
    update: 'PlayerMatchUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayerMatch_id_OrderByInput = TypedDict(
    '_PlayerMatch_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayerMatch_matchId_OrderByInput = TypedDict(
    '_PlayerMatch_matchId_OrderByInput',
    {
        'matchId': 'SortOrder',
    },
    total=True
)

_PlayerMatch_playerTeamSeasonId_OrderByInput = TypedDict(
    '_PlayerMatch_playerTeamSeasonId_OrderByInput',
    {
        'playerTeamSeasonId': 'SortOrder',
    },
    total=True
)

_PlayerMatch_assists_OrderByInput = TypedDict(
    '_PlayerMatch_assists_OrderByInput',
    {
        'assists': 'SortOrder',
    },
    total=True
)

_PlayerMatch_giveaways_OrderByInput = TypedDict(
    '_PlayerMatch_giveaways_OrderByInput',
    {
        'giveaways': 'SortOrder',
    },
    total=True
)

_PlayerMatch_goals_OrderByInput = TypedDict(
    '_PlayerMatch_goals_OrderByInput',
    {
        'goals': 'SortOrder',
    },
    total=True
)

_PlayerMatch_hits_OrderByInput = TypedDict(
    '_PlayerMatch_hits_OrderByInput',
    {
        'hits': 'SortOrder',
    },
    total=True
)

_PlayerMatch_penaltyMinutes_OrderByInput = TypedDict(
    '_PlayerMatch_penaltyMinutes_OrderByInput',
    {
        'penaltyMinutes': 'SortOrder',
    },
    total=True
)

_PlayerMatch_plusMinus_OrderByInput = TypedDict(
    '_PlayerMatch_plusMinus_OrderByInput',
    {
        'plusMinus': 'SortOrder',
    },
    total=True
)

_PlayerMatch_ratingDefense_OrderByInput = TypedDict(
    '_PlayerMatch_ratingDefense_OrderByInput',
    {
        'ratingDefense': 'SortOrder',
    },
    total=True
)

_PlayerMatch_ratingOffense_OrderByInput = TypedDict(
    '_PlayerMatch_ratingOffense_OrderByInput',
    {
        'ratingOffense': 'SortOrder',
    },
    total=True
)

_PlayerMatch_ratingTeamplay_OrderByInput = TypedDict(
    '_PlayerMatch_ratingTeamplay_OrderByInput',
    {
        'ratingTeamplay': 'SortOrder',
    },
    total=True
)

_PlayerMatch_shots_OrderByInput = TypedDict(
    '_PlayerMatch_shots_OrderByInput',
    {
        'shots': 'SortOrder',
    },
    total=True
)

_PlayerMatch_takeaways_OrderByInput = TypedDict(
    '_PlayerMatch_takeaways_OrderByInput',
    {
        'takeaways': 'SortOrder',
    },
    total=True
)

_PlayerMatch_timeOnIce_OrderByInput = TypedDict(
    '_PlayerMatch_timeOnIce_OrderByInput',
    {
        'timeOnIce': 'SortOrder',
    },
    total=True
)

_PlayerMatch_createdAt_OrderByInput = TypedDict(
    '_PlayerMatch_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PlayerMatch_updatedAt_OrderByInput = TypedDict(
    '_PlayerMatch_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_PlayerMatch_RelevanceInner = TypedDict(
    '_PlayerMatch_RelevanceInner',
    {
        'fields': 'List[PlayerMatchScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayerMatch_RelevanceOrderByInput = TypedDict(
    '_PlayerMatch_RelevanceOrderByInput',
    {
        '_relevance': '_PlayerMatch_RelevanceInner',
    },
    total=True
)

PlayerMatchOrderByInput = Union[
    '_PlayerMatch_id_OrderByInput',
    '_PlayerMatch_matchId_OrderByInput',
    '_PlayerMatch_playerTeamSeasonId_OrderByInput',
    '_PlayerMatch_assists_OrderByInput',
    '_PlayerMatch_giveaways_OrderByInput',
    '_PlayerMatch_goals_OrderByInput',
    '_PlayerMatch_hits_OrderByInput',
    '_PlayerMatch_penaltyMinutes_OrderByInput',
    '_PlayerMatch_plusMinus_OrderByInput',
    '_PlayerMatch_ratingDefense_OrderByInput',
    '_PlayerMatch_ratingOffense_OrderByInput',
    '_PlayerMatch_ratingTeamplay_OrderByInput',
    '_PlayerMatch_shots_OrderByInput',
    '_PlayerMatch_takeaways_OrderByInput',
    '_PlayerMatch_timeOnIce_OrderByInput',
    '_PlayerMatch_createdAt_OrderByInput',
    '_PlayerMatch_updatedAt_OrderByInput',
    '_PlayerMatch_RelevanceOrderByInput',
]



# recursive PlayerMatch types
# TODO: cleanup these types



PlayerMatchRelationFilter = TypedDict(
    'PlayerMatchRelationFilter',
    {
        'is': 'PlayerMatchWhereInput',
        'is_not': 'PlayerMatchWhereInput',
    },
    total=False,
)


class PlayerMatchListRelationFilter(TypedDict, total=False):
    some: 'PlayerMatchWhereInput'
    none: 'PlayerMatchWhereInput'
    every: 'PlayerMatchWhereInput'


class PlayerMatchInclude(TypedDict, total=False):
    """PlayerMatch relational arguments"""
    match: Union[bool, 'MatchArgsFromPlayerMatch']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayerMatch']


class UserIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    player: Union[bool, 'PlayerArgsFromPlayerMatch']
    notifications: Union[bool, 'FindManyNotificationArgsFromPlayerMatch']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromPlayerMatch']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromPlayerMatch']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromPlayerMatch']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromPlayerMatch']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerMatch']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromPlayerMatch']


class UserArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromPlayerMatch']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerMatch']


class PlayerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    player: Union[bool, 'PlayerArgsFromPlayerMatch']


class GamertagHistoryArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    tiers: Union[bool, 'FindManyTierArgsFromPlayerMatch']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromPlayerMatch']


class SeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    season: Union[bool, 'SeasonArgsFromPlayerMatch']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromPlayerMatch']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerMatch']


class TierArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromPlayerMatch']
    managers: Union[bool, 'FindManyTeamManagerArgsFromPlayerMatch']
    nhlAffiliate: Union[bool, 'TeamArgsFromPlayerMatch']
    ahlAffiliate: Union[bool, 'TeamArgsFromPlayerMatch']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerMatch']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromPlayerMatch']


class TeamArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    team: Union[bool, 'TeamArgsFromPlayerMatch']
    tier: Union[bool, 'TierArgsFromPlayerMatch']
    matches: Union[bool, 'FindManyMatchArgsFromPlayerMatch']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerMatch']
    bids: Union[bool, 'FindManyBidArgsFromPlayerMatch']


class TeamSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    player: Union[bool, 'PlayerArgsFromPlayerMatch']
    season: Union[bool, 'SeasonArgsFromPlayerMatch']
    contract: Union[bool, 'ContractArgsFromPlayerMatch']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromPlayerMatch']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromPlayerMatch']


class PlayerSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerMatch']
    tier: Union[bool, 'TierArgsFromPlayerMatch']


class PlayerTierHistoryArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerMatch']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerMatch']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromPlayerMatch']


class PlayerTeamSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromPlayerMatch']
    bids: Union[bool, 'FindManyBidArgsFromPlayerMatch']


class ContractArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    contract: Union[bool, 'ContractArgsFromPlayerMatch']
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerMatch']


class BidArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromPlayerMatch']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromPlayerMatch']


class MatchArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    match: Union[bool, 'MatchArgsFromPlayerMatch']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromPlayerMatch']


class PlayerMatchArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']


class NotificationArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    author: Union[bool, 'UserArgsFromPlayerMatch']
    comments: Union[bool, 'FindManyForumCommentArgsFromPlayerMatch']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerMatch']
    followers: Union[bool, 'FindManyForumFollowerArgsFromPlayerMatch']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromPlayerMatch']


class ForumPostArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']
    post: Union[bool, 'ForumPostArgsFromPlayerMatch']
    comment: Union[bool, 'ForumCommentArgsFromPlayerMatch']


class ForumReactionArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']
    post: Union[bool, 'ForumPostArgsFromPlayerMatch']


class ForumFollowerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']
    post: Union[bool, 'ForumPostArgsFromPlayerMatch']


class ForumPostSubscriptionArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    author: Union[bool, 'UserArgsFromPlayerMatch']
    post: Union[bool, 'ForumPostArgsFromPlayerMatch']
    quotedComment: Union[bool, 'ForumCommentArgsFromPlayerMatch']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromPlayerMatch']
    reactions: Union[bool, 'FindManyForumReactionArgsFromPlayerMatch']


class ForumCommentArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromPlayerMatch(TypedDict, total=False):
    """Relational arguments for PlayerMatch"""
    user: Union[bool, 'UserArgsFromPlayerMatch']
    team: Union[bool, 'TeamArgsFromPlayerMatch']


class TeamManagerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromPlayerMatch(TypedDict, total=False):
    """Arguments for PlayerMatch"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyPlayerMatchArgs = FindManyPlayerMatchArgsFromPlayerMatch
FindFirstPlayerMatchArgs = FindManyPlayerMatchArgsFromPlayerMatch


class PlayerMatchWhereInput(TypedDict, total=False):
    """PlayerMatch arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    matchId: Union[_str, 'types.StringFilter']
    playerTeamSeasonId: Union[_str, 'types.StringFilter']
    assists: Union[_int, 'types.IntFilter']
    giveaways: Union[_int, 'types.IntFilter']
    goals: Union[_int, 'types.IntFilter']
    hits: Union[_int, 'types.IntFilter']
    penaltyMinutes: Union[_int, 'types.IntFilter']
    plusMinus: Union[_int, 'types.IntFilter']
    ratingDefense: Union[_float, 'types.FloatFilter']
    ratingOffense: Union[_float, 'types.FloatFilter']
    ratingTeamplay: Union[_float, 'types.FloatFilter']
    shots: Union[_int, 'types.IntFilter']
    takeaways: Union[_int, 'types.IntFilter']
    timeOnIce: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    match: 'MatchRelationFilter'
    playerTeamSeason: 'PlayerTeamSeasonRelationFilter'

    # should be noted that AND and NOT should be Union['PlayerMatchWhereInput', List['PlayerMatchWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlayerMatchWhereInput']
    OR: List['PlayerMatchWhereInput']
    NOT: List['PlayerMatchWhereInput']



# aggregate PlayerMatch types


class PlayerMatchScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayerMatch arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    matchId: Union[_str, 'types.StringWithAggregatesFilter']
    playerTeamSeasonId: Union[_str, 'types.StringWithAggregatesFilter']
    assists: Union[_int, 'types.IntWithAggregatesFilter']
    giveaways: Union[_int, 'types.IntWithAggregatesFilter']
    goals: Union[_int, 'types.IntWithAggregatesFilter']
    hits: Union[_int, 'types.IntWithAggregatesFilter']
    penaltyMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    plusMinus: Union[_int, 'types.IntWithAggregatesFilter']
    ratingDefense: Union[_float, 'types.FloatWithAggregatesFilter']
    ratingOffense: Union[_float, 'types.FloatWithAggregatesFilter']
    ratingTeamplay: Union[_float, 'types.FloatWithAggregatesFilter']
    shots: Union[_int, 'types.IntWithAggregatesFilter']
    takeaways: Union[_int, 'types.IntWithAggregatesFilter']
    timeOnIce: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PlayerMatchScalarWhereWithAggregatesInput']
    OR: List['PlayerMatchScalarWhereWithAggregatesInput']
    NOT: List['PlayerMatchScalarWhereWithAggregatesInput']



class PlayerMatchGroupByOutput(TypedDict, total=False):
    id: _str
    matchId: _str
    playerTeamSeasonId: _str
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PlayerMatchSumAggregateOutput'
    _avg: 'PlayerMatchAvgAggregateOutput'
    _min: 'PlayerMatchMinAggregateOutput'
    _max: 'PlayerMatchMaxAggregateOutput'
    _count: 'PlayerMatchCountAggregateOutput'


class PlayerMatchAvgAggregateOutput(TypedDict, total=False):
    """PlayerMatch output for aggregating averages"""
    assists: float
    giveaways: float
    goals: float
    hits: float
    penaltyMinutes: float
    plusMinus: float
    ratingDefense: float
    ratingOffense: float
    ratingTeamplay: float
    shots: float
    takeaways: float
    timeOnIce: float


class PlayerMatchSumAggregateOutput(TypedDict, total=False):
    """PlayerMatch output for aggregating sums"""
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int


class PlayerMatchScalarAggregateOutput(TypedDict, total=False):
    """PlayerMatch output including scalar fields"""
    id: _str
    matchId: _str
    playerTeamSeasonId: _str
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PlayerMatchMinAggregateOutput = PlayerMatchScalarAggregateOutput
PlayerMatchMaxAggregateOutput = PlayerMatchScalarAggregateOutput


class PlayerMatchMaxAggregateInput(TypedDict, total=False):
    """PlayerMatch input for aggregating by max"""
    id: bool
    matchId: bool
    playerTeamSeasonId: bool
    assists: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    ratingDefense: bool
    ratingOffense: bool
    ratingTeamplay: bool
    shots: bool
    takeaways: bool
    timeOnIce: bool
    createdAt: bool
    updatedAt: bool


class PlayerMatchMinAggregateInput(TypedDict, total=False):
    """PlayerMatch input for aggregating by min"""
    id: bool
    matchId: bool
    playerTeamSeasonId: bool
    assists: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    ratingDefense: bool
    ratingOffense: bool
    ratingTeamplay: bool
    shots: bool
    takeaways: bool
    timeOnIce: bool
    createdAt: bool
    updatedAt: bool


class PlayerMatchNumberAggregateInput(TypedDict, total=False):
    """PlayerMatch input for aggregating numbers"""
    assists: bool
    giveaways: bool
    goals: bool
    hits: bool
    penaltyMinutes: bool
    plusMinus: bool
    ratingDefense: bool
    ratingOffense: bool
    ratingTeamplay: bool
    shots: bool
    takeaways: bool
    timeOnIce: bool


PlayerMatchAvgAggregateInput = PlayerMatchNumberAggregateInput
PlayerMatchSumAggregateInput = PlayerMatchNumberAggregateInput


PlayerMatchCountAggregateInput = TypedDict(
    'PlayerMatchCountAggregateInput',
    {
        'id': bool,
        'matchId': bool,
        'playerTeamSeasonId': bool,
        'assists': bool,
        'giveaways': bool,
        'goals': bool,
        'hits': bool,
        'penaltyMinutes': bool,
        'plusMinus': bool,
        'ratingDefense': bool,
        'ratingOffense': bool,
        'ratingTeamplay': bool,
        'shots': bool,
        'takeaways': bool,
        'timeOnIce': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PlayerMatchCountAggregateOutput = TypedDict(
    'PlayerMatchCountAggregateOutput',
    {
        'id': int,
        'matchId': int,
        'playerTeamSeasonId': int,
        'assists': int,
        'giveaways': int,
        'goals': int,
        'hits': int,
        'penaltyMinutes': int,
        'plusMinus': int,
        'ratingDefense': int,
        'ratingOffense': int,
        'ratingTeamplay': int,
        'shots': int,
        'takeaways': int,
        'timeOnIce': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PlayerMatchKeys = Literal[
    'id',
    'matchId',
    'playerTeamSeasonId',
    'assists',
    'giveaways',
    'goals',
    'hits',
    'penaltyMinutes',
    'plusMinus',
    'ratingDefense',
    'ratingOffense',
    'ratingTeamplay',
    'shots',
    'takeaways',
    'timeOnIce',
    'createdAt',
    'updatedAt',
    'match',
    'playerTeamSeason',
]
PlayerMatchScalarFieldKeys = Literal[
    'id',
    'matchId',
    'playerTeamSeasonId',
    'assists',
    'giveaways',
    'goals',
    'hits',
    'penaltyMinutes',
    'plusMinus',
    'ratingDefense',
    'ratingOffense',
    'ratingTeamplay',
    'shots',
    'takeaways',
    'timeOnIce',
    'createdAt',
    'updatedAt',
]
PlayerMatchScalarFieldKeysT = TypeVar('PlayerMatchScalarFieldKeysT', bound=PlayerMatchScalarFieldKeys)

PlayerMatchRelationalFieldKeys = Literal[
        'match',
        'playerTeamSeason',
    ]

# Notification types

class NotificationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Notification create method"""
    id: _str
    userId: _str
    status: 'enums.NotificationStatus'
    link: Optional[_str]
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'


class NotificationCreateInput(NotificationOptionalCreateInput):
    """Required arguments to the Notification create method"""
    type: 'enums.NotificationType'
    title: _str
    message: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NotificationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Notification create method, without relations"""
    id: _str
    userId: _str
    status: 'enums.NotificationStatus'
    link: Optional[_str]
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationCreateWithoutRelationsInput(NotificationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Notification create method, without relations"""
    type: 'enums.NotificationType'
    title: _str
    message: _str

class NotificationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'NotificationCreateWithoutRelationsInput'
    where: 'NotificationWhereUniqueInput'

class NotificationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'
    connect_or_create: 'NotificationConnectOrCreateWithoutRelationsInput'


class NotificationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NotificationCreateWithoutRelationsInput', List['NotificationCreateWithoutRelationsInput']]
    connect: Union['NotificationWhereUniqueInput', List['NotificationWhereUniqueInput']]
    connect_or_create: Union['NotificationConnectOrCreateWithoutRelationsInput', List['NotificationConnectOrCreateWithoutRelationsInput']]

_NotificationWhereUnique_id_Input = TypedDict(
    '_NotificationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

NotificationWhereUniqueInput = _NotificationWhereUnique_id_Input


class NotificationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: 'enums.NotificationType'
    title: _str
    message: _str
    status: 'enums.NotificationStatus'
    link: Optional[_str]
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class NotificationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: 'enums.NotificationType'
    title: _str
    message: _str
    status: 'enums.NotificationStatus'
    link: Optional[_str]
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NotificationCreateWithoutRelationsInput']
    connect: List['NotificationWhereUniqueInput']
    connect_or_create: List['NotificationConnectOrCreateWithoutRelationsInput']
    set: List['NotificationWhereUniqueInput']
    disconnect: List['NotificationWhereUniqueInput']
    delete: List['NotificationWhereUniqueInput']

    # TODO
    # update: List['NotificationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NotificationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NotificationScalarWhereInput']
    # upsert: List['NotificationUpserteWithWhereUniqueWithoutRelationsInput']


class NotificationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'
    connect_or_create: 'NotificationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NotificationUpdateInput'
    # upsert: 'NotificationUpsertWithoutRelationsInput'


class NotificationUpsertInput(TypedDict):
    create: 'NotificationCreateInput'
    update: 'NotificationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Notification_id_OrderByInput = TypedDict(
    '_Notification_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Notification_userId_OrderByInput = TypedDict(
    '_Notification_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Notification_type_OrderByInput = TypedDict(
    '_Notification_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Notification_title_OrderByInput = TypedDict(
    '_Notification_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Notification_message_OrderByInput = TypedDict(
    '_Notification_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Notification_status_OrderByInput = TypedDict(
    '_Notification_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Notification_link_OrderByInput = TypedDict(
    '_Notification_link_OrderByInput',
    {
        'link': 'SortOrder',
    },
    total=True
)

_Notification_metadata_OrderByInput = TypedDict(
    '_Notification_metadata_OrderByInput',
    {
        'metadata': 'SortOrder',
    },
    total=True
)

_Notification_createdAt_OrderByInput = TypedDict(
    '_Notification_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Notification_updatedAt_OrderByInput = TypedDict(
    '_Notification_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Notification_RelevanceInner = TypedDict(
    '_Notification_RelevanceInner',
    {
        'fields': 'List[NotificationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Notification_RelevanceOrderByInput = TypedDict(
    '_Notification_RelevanceOrderByInput',
    {
        '_relevance': '_Notification_RelevanceInner',
    },
    total=True
)

NotificationOrderByInput = Union[
    '_Notification_id_OrderByInput',
    '_Notification_userId_OrderByInput',
    '_Notification_type_OrderByInput',
    '_Notification_title_OrderByInput',
    '_Notification_message_OrderByInput',
    '_Notification_status_OrderByInput',
    '_Notification_link_OrderByInput',
    '_Notification_metadata_OrderByInput',
    '_Notification_createdAt_OrderByInput',
    '_Notification_updatedAt_OrderByInput',
    '_Notification_RelevanceOrderByInput',
]



# recursive Notification types
# TODO: cleanup these types



NotificationRelationFilter = TypedDict(
    'NotificationRelationFilter',
    {
        'is': 'NotificationWhereInput',
        'is_not': 'NotificationWhereInput',
    },
    total=False,
)


class NotificationListRelationFilter(TypedDict, total=False):
    some: 'NotificationWhereInput'
    none: 'NotificationWhereInput'
    every: 'NotificationWhereInput'


class NotificationInclude(TypedDict, total=False):
    """Notification relational arguments"""
    user: Union[bool, 'UserArgsFromNotification']


class UserIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    player: Union[bool, 'PlayerArgsFromNotification']
    notifications: Union[bool, 'FindManyNotificationArgsFromNotification']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromNotification']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromNotification']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromNotification']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromNotification']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromNotification']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromNotification']


class UserArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromNotification']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromNotification']


class PlayerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    player: Union[bool, 'PlayerArgsFromNotification']


class GamertagHistoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    tiers: Union[bool, 'FindManyTierArgsFromNotification']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromNotification']


class SeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    season: Union[bool, 'SeasonArgsFromNotification']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromNotification']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromNotification']


class TierArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromNotification']
    managers: Union[bool, 'FindManyTeamManagerArgsFromNotification']
    nhlAffiliate: Union[bool, 'TeamArgsFromNotification']
    ahlAffiliate: Union[bool, 'TeamArgsFromNotification']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromNotification']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromNotification']


class TeamArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    team: Union[bool, 'TeamArgsFromNotification']
    tier: Union[bool, 'TierArgsFromNotification']
    matches: Union[bool, 'FindManyMatchArgsFromNotification']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromNotification']
    bids: Union[bool, 'FindManyBidArgsFromNotification']


class TeamSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    player: Union[bool, 'PlayerArgsFromNotification']
    season: Union[bool, 'SeasonArgsFromNotification']
    contract: Union[bool, 'ContractArgsFromNotification']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromNotification']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromNotification']


class PlayerSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromNotification']
    tier: Union[bool, 'TierArgsFromNotification']


class PlayerTierHistoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromNotification']
    teamSeason: Union[bool, 'TeamSeasonArgsFromNotification']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromNotification']


class PlayerTeamSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromNotification']
    bids: Union[bool, 'FindManyBidArgsFromNotification']


class ContractArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    contract: Union[bool, 'ContractArgsFromNotification']
    teamSeason: Union[bool, 'TeamSeasonArgsFromNotification']


class BidArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromNotification']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromNotification']


class MatchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    match: Union[bool, 'MatchArgsFromNotification']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromNotification']


class PlayerMatchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']


class NotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    author: Union[bool, 'UserArgsFromNotification']
    comments: Union[bool, 'FindManyForumCommentArgsFromNotification']
    reactions: Union[bool, 'FindManyForumReactionArgsFromNotification']
    followers: Union[bool, 'FindManyForumFollowerArgsFromNotification']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromNotification']


class ForumPostArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']
    post: Union[bool, 'ForumPostArgsFromNotification']
    comment: Union[bool, 'ForumCommentArgsFromNotification']


class ForumReactionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']
    post: Union[bool, 'ForumPostArgsFromNotification']


class ForumFollowerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']
    post: Union[bool, 'ForumPostArgsFromNotification']


class ForumPostSubscriptionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    author: Union[bool, 'UserArgsFromNotification']
    post: Union[bool, 'ForumPostArgsFromNotification']
    quotedComment: Union[bool, 'ForumCommentArgsFromNotification']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromNotification']
    reactions: Union[bool, 'FindManyForumReactionArgsFromNotification']


class ForumCommentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']
    team: Union[bool, 'TeamArgsFromNotification']


class TeamManagerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyNotificationArgs = FindManyNotificationArgsFromNotification
FindFirstNotificationArgs = FindManyNotificationArgsFromNotification


class NotificationWhereInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    type: 'enums.NotificationType'
    title: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: 'enums.NotificationStatus'
    link: Union[None, _str, 'types.StringFilter']
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['NotificationWhereInput', List['NotificationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NotificationWhereInput']
    OR: List['NotificationWhereInput']
    NOT: List['NotificationWhereInput']



# aggregate Notification types


class NotificationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.NotificationType'
    title: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.NotificationStatus'
    link: Union[_str, 'types.StringWithAggregatesFilter']
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['NotificationScalarWhereWithAggregatesInput']
    OR: List['NotificationScalarWhereWithAggregatesInput']
    NOT: List['NotificationScalarWhereWithAggregatesInput']



class NotificationGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    type: 'enums.NotificationType'
    title: _str
    message: _str
    status: 'enums.NotificationStatus'
    link: _str
    metadata: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'NotificationSumAggregateOutput'
    _avg: 'NotificationAvgAggregateOutput'
    _min: 'NotificationMinAggregateOutput'
    _max: 'NotificationMaxAggregateOutput'
    _count: 'NotificationCountAggregateOutput'


class NotificationAvgAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating averages"""


class NotificationSumAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating sums"""


class NotificationScalarAggregateOutput(TypedDict, total=False):
    """Notification output including scalar fields"""
    id: _str
    userId: _str
    type: 'enums.NotificationType'
    title: _str
    message: _str
    status: 'enums.NotificationStatus'
    link: _str
    metadata: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


NotificationMinAggregateOutput = NotificationScalarAggregateOutput
NotificationMaxAggregateOutput = NotificationScalarAggregateOutput


class NotificationMaxAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by max"""
    id: bool
    userId: bool
    type: bool
    title: bool
    message: bool
    status: bool
    link: bool
    metadata: bool
    createdAt: bool
    updatedAt: bool


class NotificationMinAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by min"""
    id: bool
    userId: bool
    type: bool
    title: bool
    message: bool
    status: bool
    link: bool
    metadata: bool
    createdAt: bool
    updatedAt: bool


class NotificationNumberAggregateInput(TypedDict, total=False):
    """Notification input for aggregating numbers"""


NotificationAvgAggregateInput = NotificationNumberAggregateInput
NotificationSumAggregateInput = NotificationNumberAggregateInput


NotificationCountAggregateInput = TypedDict(
    'NotificationCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'type': bool,
        'title': bool,
        'message': bool,
        'status': bool,
        'link': bool,
        'metadata': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

NotificationCountAggregateOutput = TypedDict(
    'NotificationCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'type': int,
        'title': int,
        'message': int,
        'status': int,
        'link': int,
        'metadata': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


NotificationKeys = Literal[
    'id',
    'userId',
    'type',
    'title',
    'message',
    'status',
    'link',
    'metadata',
    'createdAt',
    'updatedAt',
    'user',
]
NotificationScalarFieldKeys = Literal[
    'id',
    'userId',
    'type',
    'title',
    'message',
    'status',
    'link',
    'metadata',
    'createdAt',
    'updatedAt',
]
NotificationScalarFieldKeysT = TypeVar('NotificationScalarFieldKeysT', bound=NotificationScalarFieldKeys)

NotificationRelationalFieldKeys = Literal[
        'user',
    ]

# ForumPost types

class ForumPostOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ForumPost create method"""
    id: _str
    status: 'enums.ForumPostStatus'
    authorId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: 'UserCreateNestedWithoutRelationsInput'
    comments: 'ForumCommentCreateManyNestedWithoutRelationsInput'
    reactions: 'ForumReactionCreateManyNestedWithoutRelationsInput'
    followers: 'ForumFollowerCreateManyNestedWithoutRelationsInput'
    subscribers: 'ForumPostSubscriptionCreateManyNestedWithoutRelationsInput'
    gif: Optional['fields.Json']


class ForumPostCreateInput(ForumPostOptionalCreateInput):
    """Required arguments to the ForumPost create method"""
    title: _str
    content: _str
    leagueId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ForumPostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ForumPost create method, without relations"""
    id: _str
    status: 'enums.ForumPostStatus'
    authorId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gif: Optional['fields.Json']


class ForumPostCreateWithoutRelationsInput(ForumPostOptionalCreateWithoutRelationsInput):
    """Required arguments to the ForumPost create method, without relations"""
    title: _str
    content: _str
    leagueId: _str

class ForumPostConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ForumPostCreateWithoutRelationsInput'
    where: 'ForumPostWhereUniqueInput'

class ForumPostCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumPostCreateWithoutRelationsInput'
    connect: 'ForumPostWhereUniqueInput'
    connect_or_create: 'ForumPostConnectOrCreateWithoutRelationsInput'


class ForumPostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ForumPostCreateWithoutRelationsInput', List['ForumPostCreateWithoutRelationsInput']]
    connect: Union['ForumPostWhereUniqueInput', List['ForumPostWhereUniqueInput']]
    connect_or_create: Union['ForumPostConnectOrCreateWithoutRelationsInput', List['ForumPostConnectOrCreateWithoutRelationsInput']]

_ForumPostWhereUnique_id_Input = TypedDict(
    '_ForumPostWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ForumPostWhereUniqueInput = _ForumPostWhereUnique_id_Input


class ForumPostUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    content: _str
    status: 'enums.ForumPostStatus'
    leagueId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: 'UserUpdateOneWithoutRelationsInput'
    comments: 'ForumCommentUpdateManyWithoutRelationsInput'
    reactions: 'ForumReactionUpdateManyWithoutRelationsInput'
    followers: 'ForumFollowerUpdateManyWithoutRelationsInput'
    subscribers: 'ForumPostSubscriptionUpdateManyWithoutRelationsInput'
    gif: Optional['fields.Json']


class ForumPostUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    content: _str
    status: 'enums.ForumPostStatus'
    leagueId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gif: Optional['fields.Json']


class ForumPostUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ForumPostCreateWithoutRelationsInput']
    connect: List['ForumPostWhereUniqueInput']
    connect_or_create: List['ForumPostConnectOrCreateWithoutRelationsInput']
    set: List['ForumPostWhereUniqueInput']
    disconnect: List['ForumPostWhereUniqueInput']
    delete: List['ForumPostWhereUniqueInput']

    # TODO
    # update: List['ForumPostUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ForumPostUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ForumPostScalarWhereInput']
    # upsert: List['ForumPostUpserteWithWhereUniqueWithoutRelationsInput']


class ForumPostUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumPostCreateWithoutRelationsInput'
    connect: 'ForumPostWhereUniqueInput'
    connect_or_create: 'ForumPostConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ForumPostUpdateInput'
    # upsert: 'ForumPostUpsertWithoutRelationsInput'


class ForumPostUpsertInput(TypedDict):
    create: 'ForumPostCreateInput'
    update: 'ForumPostUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ForumPost_id_OrderByInput = TypedDict(
    '_ForumPost_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ForumPost_title_OrderByInput = TypedDict(
    '_ForumPost_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_ForumPost_content_OrderByInput = TypedDict(
    '_ForumPost_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_ForumPost_status_OrderByInput = TypedDict(
    '_ForumPost_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_ForumPost_authorId_OrderByInput = TypedDict(
    '_ForumPost_authorId_OrderByInput',
    {
        'authorId': 'SortOrder',
    },
    total=True
)

_ForumPost_leagueId_OrderByInput = TypedDict(
    '_ForumPost_leagueId_OrderByInput',
    {
        'leagueId': 'SortOrder',
    },
    total=True
)

_ForumPost_createdAt_OrderByInput = TypedDict(
    '_ForumPost_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ForumPost_updatedAt_OrderByInput = TypedDict(
    '_ForumPost_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_ForumPost_gif_OrderByInput = TypedDict(
    '_ForumPost_gif_OrderByInput',
    {
        'gif': 'SortOrder',
    },
    total=True
)

_ForumPost_RelevanceInner = TypedDict(
    '_ForumPost_RelevanceInner',
    {
        'fields': 'List[ForumPostScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ForumPost_RelevanceOrderByInput = TypedDict(
    '_ForumPost_RelevanceOrderByInput',
    {
        '_relevance': '_ForumPost_RelevanceInner',
    },
    total=True
)

ForumPostOrderByInput = Union[
    '_ForumPost_id_OrderByInput',
    '_ForumPost_title_OrderByInput',
    '_ForumPost_content_OrderByInput',
    '_ForumPost_status_OrderByInput',
    '_ForumPost_authorId_OrderByInput',
    '_ForumPost_leagueId_OrderByInput',
    '_ForumPost_createdAt_OrderByInput',
    '_ForumPost_updatedAt_OrderByInput',
    '_ForumPost_gif_OrderByInput',
    '_ForumPost_RelevanceOrderByInput',
]



# recursive ForumPost types
# TODO: cleanup these types



ForumPostRelationFilter = TypedDict(
    'ForumPostRelationFilter',
    {
        'is': 'ForumPostWhereInput',
        'is_not': 'ForumPostWhereInput',
    },
    total=False,
)


class ForumPostListRelationFilter(TypedDict, total=False):
    some: 'ForumPostWhereInput'
    none: 'ForumPostWhereInput'
    every: 'ForumPostWhereInput'


class ForumPostInclude(TypedDict, total=False):
    """ForumPost relational arguments"""
    author: Union[bool, 'UserArgsFromForumPost']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumPost']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumPost']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumPost']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumPost']


class UserIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    player: Union[bool, 'PlayerArgsFromForumPost']
    notifications: Union[bool, 'FindManyNotificationArgsFromForumPost']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromForumPost']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromForumPost']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromForumPost']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromForumPost']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumPost']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromForumPost']


class UserArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromForumPost']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromForumPost']


class PlayerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    player: Union[bool, 'PlayerArgsFromForumPost']


class GamertagHistoryArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    tiers: Union[bool, 'FindManyTierArgsFromForumPost']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromForumPost']


class SeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    season: Union[bool, 'SeasonArgsFromForumPost']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromForumPost']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumPost']


class TierArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromForumPost']
    managers: Union[bool, 'FindManyTeamManagerArgsFromForumPost']
    nhlAffiliate: Union[bool, 'TeamArgsFromForumPost']
    ahlAffiliate: Union[bool, 'TeamArgsFromForumPost']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromForumPost']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromForumPost']


class TeamArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    team: Union[bool, 'TeamArgsFromForumPost']
    tier: Union[bool, 'TierArgsFromForumPost']
    matches: Union[bool, 'FindManyMatchArgsFromForumPost']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumPost']
    bids: Union[bool, 'FindManyBidArgsFromForumPost']


class TeamSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    player: Union[bool, 'PlayerArgsFromForumPost']
    season: Union[bool, 'SeasonArgsFromForumPost']
    contract: Union[bool, 'ContractArgsFromForumPost']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumPost']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumPost']


class PlayerSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPost']
    tier: Union[bool, 'TierArgsFromForumPost']


class PlayerTierHistoryArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPost']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPost']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromForumPost']


class PlayerTeamSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPost']
    bids: Union[bool, 'FindManyBidArgsFromForumPost']


class ContractArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    contract: Union[bool, 'ContractArgsFromForumPost']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPost']


class BidArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPost']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromForumPost']


class MatchArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    match: Union[bool, 'MatchArgsFromForumPost']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromForumPost']


class PlayerMatchArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']


class NotificationArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    author: Union[bool, 'UserArgsFromForumPost']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumPost']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumPost']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumPost']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumPost']


class ForumPostArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']
    post: Union[bool, 'ForumPostArgsFromForumPost']
    comment: Union[bool, 'ForumCommentArgsFromForumPost']


class ForumReactionArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']
    post: Union[bool, 'ForumPostArgsFromForumPost']


class ForumFollowerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']
    post: Union[bool, 'ForumPostArgsFromForumPost']


class ForumPostSubscriptionArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    author: Union[bool, 'UserArgsFromForumPost']
    post: Union[bool, 'ForumPostArgsFromForumPost']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumPost']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumPost']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumPost']


class ForumCommentArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromForumPost(TypedDict, total=False):
    """Relational arguments for ForumPost"""
    user: Union[bool, 'UserArgsFromForumPost']
    team: Union[bool, 'TeamArgsFromForumPost']


class TeamManagerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromForumPost(TypedDict, total=False):
    """Arguments for ForumPost"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyForumPostArgs = FindManyForumPostArgsFromForumPost
FindFirstForumPostArgs = FindManyForumPostArgsFromForumPost


class ForumPostWhereInput(TypedDict, total=False):
    """ForumPost arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    status: 'enums.ForumPostStatus'
    authorId: Union[_str, 'types.StringFilter']
    leagueId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    author: 'UserRelationFilter'
    comments: 'ForumCommentListRelationFilter'
    reactions: 'ForumReactionListRelationFilter'
    followers: 'ForumFollowerListRelationFilter'
    subscribers: 'ForumPostSubscriptionListRelationFilter'
    gif: Union[None, 'fields.Json', 'types.JsonFilter']

    # should be noted that AND and NOT should be Union['ForumPostWhereInput', List['ForumPostWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ForumPostWhereInput']
    OR: List['ForumPostWhereInput']
    NOT: List['ForumPostWhereInput']



# aggregate ForumPost types


class ForumPostScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ForumPost arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.ForumPostStatus'
    authorId: Union[_str, 'types.StringWithAggregatesFilter']
    leagueId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gif: Union['fields.Json', 'types.JsonWithAggregatesFilter']

    AND: List['ForumPostScalarWhereWithAggregatesInput']
    OR: List['ForumPostScalarWhereWithAggregatesInput']
    NOT: List['ForumPostScalarWhereWithAggregatesInput']



class ForumPostGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    content: _str
    status: 'enums.ForumPostStatus'
    authorId: _str
    leagueId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gif: 'fields.Json'
    _sum: 'ForumPostSumAggregateOutput'
    _avg: 'ForumPostAvgAggregateOutput'
    _min: 'ForumPostMinAggregateOutput'
    _max: 'ForumPostMaxAggregateOutput'
    _count: 'ForumPostCountAggregateOutput'


class ForumPostAvgAggregateOutput(TypedDict, total=False):
    """ForumPost output for aggregating averages"""


class ForumPostSumAggregateOutput(TypedDict, total=False):
    """ForumPost output for aggregating sums"""


class ForumPostScalarAggregateOutput(TypedDict, total=False):
    """ForumPost output including scalar fields"""
    id: _str
    title: _str
    content: _str
    status: 'enums.ForumPostStatus'
    authorId: _str
    leagueId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gif: 'fields.Json'


ForumPostMinAggregateOutput = ForumPostScalarAggregateOutput
ForumPostMaxAggregateOutput = ForumPostScalarAggregateOutput


class ForumPostMaxAggregateInput(TypedDict, total=False):
    """ForumPost input for aggregating by max"""
    id: bool
    title: bool
    content: bool
    status: bool
    authorId: bool
    leagueId: bool
    createdAt: bool
    updatedAt: bool
    gif: bool


class ForumPostMinAggregateInput(TypedDict, total=False):
    """ForumPost input for aggregating by min"""
    id: bool
    title: bool
    content: bool
    status: bool
    authorId: bool
    leagueId: bool
    createdAt: bool
    updatedAt: bool
    gif: bool


class ForumPostNumberAggregateInput(TypedDict, total=False):
    """ForumPost input for aggregating numbers"""


ForumPostAvgAggregateInput = ForumPostNumberAggregateInput
ForumPostSumAggregateInput = ForumPostNumberAggregateInput


ForumPostCountAggregateInput = TypedDict(
    'ForumPostCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'content': bool,
        'status': bool,
        'authorId': bool,
        'leagueId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'gif': bool,
        '_all': bool,
    },
    total=False,
)

ForumPostCountAggregateOutput = TypedDict(
    'ForumPostCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'content': int,
        'status': int,
        'authorId': int,
        'leagueId': int,
        'createdAt': int,
        'updatedAt': int,
        'gif': int,
        '_all': int,
    },
    total=False,
)


ForumPostKeys = Literal[
    'id',
    'title',
    'content',
    'status',
    'authorId',
    'leagueId',
    'createdAt',
    'updatedAt',
    'author',
    'comments',
    'reactions',
    'followers',
    'subscribers',
    'gif',
]
ForumPostScalarFieldKeys = Literal[
    'id',
    'title',
    'content',
    'status',
    'authorId',
    'leagueId',
    'createdAt',
    'updatedAt',
    'gif',
]
ForumPostScalarFieldKeysT = TypeVar('ForumPostScalarFieldKeysT', bound=ForumPostScalarFieldKeys)

ForumPostRelationalFieldKeys = Literal[
        'author',
        'comments',
        'reactions',
        'followers',
        'subscribers',
    ]

# ForumReaction types

class ForumReactionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ForumReaction create method"""
    id: _str
    userId: _str
    postId: Optional[_str]
    commentId: Optional[_str]
    createdAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    post: 'ForumPostCreateNestedWithoutRelationsInput'
    comment: 'ForumCommentCreateNestedWithoutRelationsInput'


class ForumReactionCreateInput(ForumReactionOptionalCreateInput):
    """Required arguments to the ForumReaction create method"""
    type: 'enums.ReactionType'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ForumReactionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ForumReaction create method, without relations"""
    id: _str
    userId: _str
    postId: Optional[_str]
    commentId: Optional[_str]
    createdAt: datetime.datetime


class ForumReactionCreateWithoutRelationsInput(ForumReactionOptionalCreateWithoutRelationsInput):
    """Required arguments to the ForumReaction create method, without relations"""
    type: 'enums.ReactionType'

class ForumReactionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ForumReactionCreateWithoutRelationsInput'
    where: 'ForumReactionWhereUniqueInput'

class ForumReactionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumReactionCreateWithoutRelationsInput'
    connect: 'ForumReactionWhereUniqueInput'
    connect_or_create: 'ForumReactionConnectOrCreateWithoutRelationsInput'


class ForumReactionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ForumReactionCreateWithoutRelationsInput', List['ForumReactionCreateWithoutRelationsInput']]
    connect: Union['ForumReactionWhereUniqueInput', List['ForumReactionWhereUniqueInput']]
    connect_or_create: Union['ForumReactionConnectOrCreateWithoutRelationsInput', List['ForumReactionConnectOrCreateWithoutRelationsInput']]

_ForumReactionWhereUnique_id_Input = TypedDict(
    '_ForumReactionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ForumReactionCompounduserId_postId_commentId_typeKeyInner = TypedDict(
    '_ForumReactionCompounduserId_postId_commentId_typeKeyInner',
    {
        'userId': '_str',
        'postId': '_str',
        'commentId': '_str',
        'type': 'enums.ReactionType',
    },
    total=True
)

_ForumReactionCompounduserId_postId_commentId_typeKey = TypedDict(
    '_ForumReactionCompounduserId_postId_commentId_typeKey',
    {
        'userId_postId_commentId_type': '_ForumReactionCompounduserId_postId_commentId_typeKeyInner',
    },
    total=True
)

ForumReactionWhereUniqueInput = Union[
    '_ForumReactionWhereUnique_id_Input',
    '_ForumReactionCompounduserId_postId_commentId_typeKey',
]


class ForumReactionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: 'enums.ReactionType'
    createdAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    post: 'ForumPostUpdateOneWithoutRelationsInput'
    comment: 'ForumCommentUpdateOneWithoutRelationsInput'


class ForumReactionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: 'enums.ReactionType'
    createdAt: datetime.datetime


class ForumReactionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ForumReactionCreateWithoutRelationsInput']
    connect: List['ForumReactionWhereUniqueInput']
    connect_or_create: List['ForumReactionConnectOrCreateWithoutRelationsInput']
    set: List['ForumReactionWhereUniqueInput']
    disconnect: List['ForumReactionWhereUniqueInput']
    delete: List['ForumReactionWhereUniqueInput']

    # TODO
    # update: List['ForumReactionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ForumReactionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ForumReactionScalarWhereInput']
    # upsert: List['ForumReactionUpserteWithWhereUniqueWithoutRelationsInput']


class ForumReactionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumReactionCreateWithoutRelationsInput'
    connect: 'ForumReactionWhereUniqueInput'
    connect_or_create: 'ForumReactionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ForumReactionUpdateInput'
    # upsert: 'ForumReactionUpsertWithoutRelationsInput'


class ForumReactionUpsertInput(TypedDict):
    create: 'ForumReactionCreateInput'
    update: 'ForumReactionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ForumReaction_id_OrderByInput = TypedDict(
    '_ForumReaction_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ForumReaction_type_OrderByInput = TypedDict(
    '_ForumReaction_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_ForumReaction_userId_OrderByInput = TypedDict(
    '_ForumReaction_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_ForumReaction_postId_OrderByInput = TypedDict(
    '_ForumReaction_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_ForumReaction_commentId_OrderByInput = TypedDict(
    '_ForumReaction_commentId_OrderByInput',
    {
        'commentId': 'SortOrder',
    },
    total=True
)

_ForumReaction_createdAt_OrderByInput = TypedDict(
    '_ForumReaction_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ForumReaction_RelevanceInner = TypedDict(
    '_ForumReaction_RelevanceInner',
    {
        'fields': 'List[ForumReactionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ForumReaction_RelevanceOrderByInput = TypedDict(
    '_ForumReaction_RelevanceOrderByInput',
    {
        '_relevance': '_ForumReaction_RelevanceInner',
    },
    total=True
)

ForumReactionOrderByInput = Union[
    '_ForumReaction_id_OrderByInput',
    '_ForumReaction_type_OrderByInput',
    '_ForumReaction_userId_OrderByInput',
    '_ForumReaction_postId_OrderByInput',
    '_ForumReaction_commentId_OrderByInput',
    '_ForumReaction_createdAt_OrderByInput',
    '_ForumReaction_RelevanceOrderByInput',
]



# recursive ForumReaction types
# TODO: cleanup these types



ForumReactionRelationFilter = TypedDict(
    'ForumReactionRelationFilter',
    {
        'is': 'ForumReactionWhereInput',
        'is_not': 'ForumReactionWhereInput',
    },
    total=False,
)


class ForumReactionListRelationFilter(TypedDict, total=False):
    some: 'ForumReactionWhereInput'
    none: 'ForumReactionWhereInput'
    every: 'ForumReactionWhereInput'


class ForumReactionInclude(TypedDict, total=False):
    """ForumReaction relational arguments"""
    user: Union[bool, 'UserArgsFromForumReaction']
    post: Union[bool, 'ForumPostArgsFromForumReaction']
    comment: Union[bool, 'ForumCommentArgsFromForumReaction']


class UserIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    player: Union[bool, 'PlayerArgsFromForumReaction']
    notifications: Union[bool, 'FindManyNotificationArgsFromForumReaction']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromForumReaction']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromForumReaction']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromForumReaction']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromForumReaction']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumReaction']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromForumReaction']


class UserArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromForumReaction']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromForumReaction']


class PlayerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    player: Union[bool, 'PlayerArgsFromForumReaction']


class GamertagHistoryArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    tiers: Union[bool, 'FindManyTierArgsFromForumReaction']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromForumReaction']


class SeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    season: Union[bool, 'SeasonArgsFromForumReaction']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromForumReaction']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumReaction']


class TierArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromForumReaction']
    managers: Union[bool, 'FindManyTeamManagerArgsFromForumReaction']
    nhlAffiliate: Union[bool, 'TeamArgsFromForumReaction']
    ahlAffiliate: Union[bool, 'TeamArgsFromForumReaction']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromForumReaction']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromForumReaction']


class TeamArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    team: Union[bool, 'TeamArgsFromForumReaction']
    tier: Union[bool, 'TierArgsFromForumReaction']
    matches: Union[bool, 'FindManyMatchArgsFromForumReaction']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumReaction']
    bids: Union[bool, 'FindManyBidArgsFromForumReaction']


class TeamSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    player: Union[bool, 'PlayerArgsFromForumReaction']
    season: Union[bool, 'SeasonArgsFromForumReaction']
    contract: Union[bool, 'ContractArgsFromForumReaction']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumReaction']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumReaction']


class PlayerSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumReaction']
    tier: Union[bool, 'TierArgsFromForumReaction']


class PlayerTierHistoryArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumReaction']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumReaction']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromForumReaction']


class PlayerTeamSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumReaction']
    bids: Union[bool, 'FindManyBidArgsFromForumReaction']


class ContractArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    contract: Union[bool, 'ContractArgsFromForumReaction']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumReaction']


class BidArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumReaction']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromForumReaction']


class MatchArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    match: Union[bool, 'MatchArgsFromForumReaction']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromForumReaction']


class PlayerMatchArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']


class NotificationArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    author: Union[bool, 'UserArgsFromForumReaction']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumReaction']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumReaction']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumReaction']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumReaction']


class ForumPostArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']
    post: Union[bool, 'ForumPostArgsFromForumReaction']
    comment: Union[bool, 'ForumCommentArgsFromForumReaction']


class ForumReactionArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']
    post: Union[bool, 'ForumPostArgsFromForumReaction']


class ForumFollowerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']
    post: Union[bool, 'ForumPostArgsFromForumReaction']


class ForumPostSubscriptionArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    author: Union[bool, 'UserArgsFromForumReaction']
    post: Union[bool, 'ForumPostArgsFromForumReaction']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumReaction']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumReaction']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumReaction']


class ForumCommentArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromForumReaction(TypedDict, total=False):
    """Relational arguments for ForumReaction"""
    user: Union[bool, 'UserArgsFromForumReaction']
    team: Union[bool, 'TeamArgsFromForumReaction']


class TeamManagerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromForumReaction(TypedDict, total=False):
    """Arguments for ForumReaction"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyForumReactionArgs = FindManyForumReactionArgsFromForumReaction
FindFirstForumReactionArgs = FindManyForumReactionArgsFromForumReaction


class ForumReactionWhereInput(TypedDict, total=False):
    """ForumReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: 'enums.ReactionType'
    userId: Union[_str, 'types.StringFilter']
    postId: Union[None, _str, 'types.StringFilter']
    commentId: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    post: 'ForumPostRelationFilter'
    comment: 'ForumCommentRelationFilter'

    # should be noted that AND and NOT should be Union['ForumReactionWhereInput', List['ForumReactionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ForumReactionWhereInput']
    OR: List['ForumReactionWhereInput']
    NOT: List['ForumReactionWhereInput']



# aggregate ForumReaction types


class ForumReactionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ForumReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.ReactionType'
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    commentId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ForumReactionScalarWhereWithAggregatesInput']
    OR: List['ForumReactionScalarWhereWithAggregatesInput']
    NOT: List['ForumReactionScalarWhereWithAggregatesInput']



class ForumReactionGroupByOutput(TypedDict, total=False):
    id: _str
    type: 'enums.ReactionType'
    userId: _str
    postId: _str
    commentId: _str
    createdAt: datetime.datetime
    _sum: 'ForumReactionSumAggregateOutput'
    _avg: 'ForumReactionAvgAggregateOutput'
    _min: 'ForumReactionMinAggregateOutput'
    _max: 'ForumReactionMaxAggregateOutput'
    _count: 'ForumReactionCountAggregateOutput'


class ForumReactionAvgAggregateOutput(TypedDict, total=False):
    """ForumReaction output for aggregating averages"""


class ForumReactionSumAggregateOutput(TypedDict, total=False):
    """ForumReaction output for aggregating sums"""


class ForumReactionScalarAggregateOutput(TypedDict, total=False):
    """ForumReaction output including scalar fields"""
    id: _str
    type: 'enums.ReactionType'
    userId: _str
    postId: _str
    commentId: _str
    createdAt: datetime.datetime


ForumReactionMinAggregateOutput = ForumReactionScalarAggregateOutput
ForumReactionMaxAggregateOutput = ForumReactionScalarAggregateOutput


class ForumReactionMaxAggregateInput(TypedDict, total=False):
    """ForumReaction input for aggregating by max"""
    id: bool
    type: bool
    userId: bool
    postId: bool
    commentId: bool
    createdAt: bool


class ForumReactionMinAggregateInput(TypedDict, total=False):
    """ForumReaction input for aggregating by min"""
    id: bool
    type: bool
    userId: bool
    postId: bool
    commentId: bool
    createdAt: bool


class ForumReactionNumberAggregateInput(TypedDict, total=False):
    """ForumReaction input for aggregating numbers"""


ForumReactionAvgAggregateInput = ForumReactionNumberAggregateInput
ForumReactionSumAggregateInput = ForumReactionNumberAggregateInput


ForumReactionCountAggregateInput = TypedDict(
    'ForumReactionCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'userId': bool,
        'postId': bool,
        'commentId': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ForumReactionCountAggregateOutput = TypedDict(
    'ForumReactionCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'userId': int,
        'postId': int,
        'commentId': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ForumReactionKeys = Literal[
    'id',
    'type',
    'userId',
    'postId',
    'commentId',
    'createdAt',
    'user',
    'post',
    'comment',
]
ForumReactionScalarFieldKeys = Literal[
    'id',
    'type',
    'userId',
    'postId',
    'commentId',
    'createdAt',
]
ForumReactionScalarFieldKeysT = TypeVar('ForumReactionScalarFieldKeysT', bound=ForumReactionScalarFieldKeys)

ForumReactionRelationalFieldKeys = Literal[
        'user',
        'post',
        'comment',
    ]

# ForumFollower types

class ForumFollowerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ForumFollower create method"""
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    post: 'ForumPostCreateNestedWithoutRelationsInput'


class ForumFollowerCreateInput(ForumFollowerOptionalCreateInput):
    """Required arguments to the ForumFollower create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ForumFollowerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ForumFollower create method, without relations"""
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime


class ForumFollowerCreateWithoutRelationsInput(ForumFollowerOptionalCreateWithoutRelationsInput):
    """Required arguments to the ForumFollower create method, without relations"""

class ForumFollowerConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ForumFollowerCreateWithoutRelationsInput'
    where: 'ForumFollowerWhereUniqueInput'

class ForumFollowerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumFollowerCreateWithoutRelationsInput'
    connect: 'ForumFollowerWhereUniqueInput'
    connect_or_create: 'ForumFollowerConnectOrCreateWithoutRelationsInput'


class ForumFollowerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ForumFollowerCreateWithoutRelationsInput', List['ForumFollowerCreateWithoutRelationsInput']]
    connect: Union['ForumFollowerWhereUniqueInput', List['ForumFollowerWhereUniqueInput']]
    connect_or_create: Union['ForumFollowerConnectOrCreateWithoutRelationsInput', List['ForumFollowerConnectOrCreateWithoutRelationsInput']]

_ForumFollowerWhereUnique_id_Input = TypedDict(
    '_ForumFollowerWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ForumFollowerCompounduserId_postIdKeyInner = TypedDict(
    '_ForumFollowerCompounduserId_postIdKeyInner',
    {
        'userId': '_str',
        'postId': '_str',
    },
    total=True
)

_ForumFollowerCompounduserId_postIdKey = TypedDict(
    '_ForumFollowerCompounduserId_postIdKey',
    {
        'userId_postId': '_ForumFollowerCompounduserId_postIdKeyInner',
    },
    total=True
)

ForumFollowerWhereUniqueInput = Union[
    '_ForumFollowerWhereUnique_id_Input',
    '_ForumFollowerCompounduserId_postIdKey',
]


class ForumFollowerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    post: 'ForumPostUpdateOneWithoutRelationsInput'


class ForumFollowerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime


class ForumFollowerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ForumFollowerCreateWithoutRelationsInput']
    connect: List['ForumFollowerWhereUniqueInput']
    connect_or_create: List['ForumFollowerConnectOrCreateWithoutRelationsInput']
    set: List['ForumFollowerWhereUniqueInput']
    disconnect: List['ForumFollowerWhereUniqueInput']
    delete: List['ForumFollowerWhereUniqueInput']

    # TODO
    # update: List['ForumFollowerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ForumFollowerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ForumFollowerScalarWhereInput']
    # upsert: List['ForumFollowerUpserteWithWhereUniqueWithoutRelationsInput']


class ForumFollowerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumFollowerCreateWithoutRelationsInput'
    connect: 'ForumFollowerWhereUniqueInput'
    connect_or_create: 'ForumFollowerConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ForumFollowerUpdateInput'
    # upsert: 'ForumFollowerUpsertWithoutRelationsInput'


class ForumFollowerUpsertInput(TypedDict):
    create: 'ForumFollowerCreateInput'
    update: 'ForumFollowerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ForumFollower_id_OrderByInput = TypedDict(
    '_ForumFollower_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ForumFollower_userId_OrderByInput = TypedDict(
    '_ForumFollower_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_ForumFollower_postId_OrderByInput = TypedDict(
    '_ForumFollower_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_ForumFollower_createdAt_OrderByInput = TypedDict(
    '_ForumFollower_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ForumFollower_RelevanceInner = TypedDict(
    '_ForumFollower_RelevanceInner',
    {
        'fields': 'List[ForumFollowerScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ForumFollower_RelevanceOrderByInput = TypedDict(
    '_ForumFollower_RelevanceOrderByInput',
    {
        '_relevance': '_ForumFollower_RelevanceInner',
    },
    total=True
)

ForumFollowerOrderByInput = Union[
    '_ForumFollower_id_OrderByInput',
    '_ForumFollower_userId_OrderByInput',
    '_ForumFollower_postId_OrderByInput',
    '_ForumFollower_createdAt_OrderByInput',
    '_ForumFollower_RelevanceOrderByInput',
]



# recursive ForumFollower types
# TODO: cleanup these types



ForumFollowerRelationFilter = TypedDict(
    'ForumFollowerRelationFilter',
    {
        'is': 'ForumFollowerWhereInput',
        'is_not': 'ForumFollowerWhereInput',
    },
    total=False,
)


class ForumFollowerListRelationFilter(TypedDict, total=False):
    some: 'ForumFollowerWhereInput'
    none: 'ForumFollowerWhereInput'
    every: 'ForumFollowerWhereInput'


class ForumFollowerInclude(TypedDict, total=False):
    """ForumFollower relational arguments"""
    user: Union[bool, 'UserArgsFromForumFollower']
    post: Union[bool, 'ForumPostArgsFromForumFollower']


class UserIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    player: Union[bool, 'PlayerArgsFromForumFollower']
    notifications: Union[bool, 'FindManyNotificationArgsFromForumFollower']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromForumFollower']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromForumFollower']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromForumFollower']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromForumFollower']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumFollower']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromForumFollower']


class UserArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromForumFollower']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromForumFollower']


class PlayerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    player: Union[bool, 'PlayerArgsFromForumFollower']


class GamertagHistoryArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    tiers: Union[bool, 'FindManyTierArgsFromForumFollower']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromForumFollower']


class SeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    season: Union[bool, 'SeasonArgsFromForumFollower']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromForumFollower']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumFollower']


class TierArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromForumFollower']
    managers: Union[bool, 'FindManyTeamManagerArgsFromForumFollower']
    nhlAffiliate: Union[bool, 'TeamArgsFromForumFollower']
    ahlAffiliate: Union[bool, 'TeamArgsFromForumFollower']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromForumFollower']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromForumFollower']


class TeamArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    team: Union[bool, 'TeamArgsFromForumFollower']
    tier: Union[bool, 'TierArgsFromForumFollower']
    matches: Union[bool, 'FindManyMatchArgsFromForumFollower']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumFollower']
    bids: Union[bool, 'FindManyBidArgsFromForumFollower']


class TeamSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    player: Union[bool, 'PlayerArgsFromForumFollower']
    season: Union[bool, 'SeasonArgsFromForumFollower']
    contract: Union[bool, 'ContractArgsFromForumFollower']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumFollower']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumFollower']


class PlayerSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumFollower']
    tier: Union[bool, 'TierArgsFromForumFollower']


class PlayerTierHistoryArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumFollower']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumFollower']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromForumFollower']


class PlayerTeamSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumFollower']
    bids: Union[bool, 'FindManyBidArgsFromForumFollower']


class ContractArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    contract: Union[bool, 'ContractArgsFromForumFollower']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumFollower']


class BidArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumFollower']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromForumFollower']


class MatchArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    match: Union[bool, 'MatchArgsFromForumFollower']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromForumFollower']


class PlayerMatchArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']


class NotificationArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    author: Union[bool, 'UserArgsFromForumFollower']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumFollower']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumFollower']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumFollower']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumFollower']


class ForumPostArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']
    post: Union[bool, 'ForumPostArgsFromForumFollower']
    comment: Union[bool, 'ForumCommentArgsFromForumFollower']


class ForumReactionArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']
    post: Union[bool, 'ForumPostArgsFromForumFollower']


class ForumFollowerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']
    post: Union[bool, 'ForumPostArgsFromForumFollower']


class ForumPostSubscriptionArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    author: Union[bool, 'UserArgsFromForumFollower']
    post: Union[bool, 'ForumPostArgsFromForumFollower']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumFollower']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumFollower']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumFollower']


class ForumCommentArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromForumFollower(TypedDict, total=False):
    """Relational arguments for ForumFollower"""
    user: Union[bool, 'UserArgsFromForumFollower']
    team: Union[bool, 'TeamArgsFromForumFollower']


class TeamManagerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromForumFollower(TypedDict, total=False):
    """Arguments for ForumFollower"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyForumFollowerArgs = FindManyForumFollowerArgsFromForumFollower
FindFirstForumFollowerArgs = FindManyForumFollowerArgsFromForumFollower


class ForumFollowerWhereInput(TypedDict, total=False):
    """ForumFollower arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    postId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    post: 'ForumPostRelationFilter'

    # should be noted that AND and NOT should be Union['ForumFollowerWhereInput', List['ForumFollowerWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ForumFollowerWhereInput']
    OR: List['ForumFollowerWhereInput']
    NOT: List['ForumFollowerWhereInput']



# aggregate ForumFollower types


class ForumFollowerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ForumFollower arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ForumFollowerScalarWhereWithAggregatesInput']
    OR: List['ForumFollowerScalarWhereWithAggregatesInput']
    NOT: List['ForumFollowerScalarWhereWithAggregatesInput']



class ForumFollowerGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime
    _sum: 'ForumFollowerSumAggregateOutput'
    _avg: 'ForumFollowerAvgAggregateOutput'
    _min: 'ForumFollowerMinAggregateOutput'
    _max: 'ForumFollowerMaxAggregateOutput'
    _count: 'ForumFollowerCountAggregateOutput'


class ForumFollowerAvgAggregateOutput(TypedDict, total=False):
    """ForumFollower output for aggregating averages"""


class ForumFollowerSumAggregateOutput(TypedDict, total=False):
    """ForumFollower output for aggregating sums"""


class ForumFollowerScalarAggregateOutput(TypedDict, total=False):
    """ForumFollower output including scalar fields"""
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime


ForumFollowerMinAggregateOutput = ForumFollowerScalarAggregateOutput
ForumFollowerMaxAggregateOutput = ForumFollowerScalarAggregateOutput


class ForumFollowerMaxAggregateInput(TypedDict, total=False):
    """ForumFollower input for aggregating by max"""
    id: bool
    userId: bool
    postId: bool
    createdAt: bool


class ForumFollowerMinAggregateInput(TypedDict, total=False):
    """ForumFollower input for aggregating by min"""
    id: bool
    userId: bool
    postId: bool
    createdAt: bool


class ForumFollowerNumberAggregateInput(TypedDict, total=False):
    """ForumFollower input for aggregating numbers"""


ForumFollowerAvgAggregateInput = ForumFollowerNumberAggregateInput
ForumFollowerSumAggregateInput = ForumFollowerNumberAggregateInput


ForumFollowerCountAggregateInput = TypedDict(
    'ForumFollowerCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'postId': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ForumFollowerCountAggregateOutput = TypedDict(
    'ForumFollowerCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'postId': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ForumFollowerKeys = Literal[
    'id',
    'userId',
    'postId',
    'createdAt',
    'user',
    'post',
]
ForumFollowerScalarFieldKeys = Literal[
    'id',
    'userId',
    'postId',
    'createdAt',
]
ForumFollowerScalarFieldKeysT = TypeVar('ForumFollowerScalarFieldKeysT', bound=ForumFollowerScalarFieldKeys)

ForumFollowerRelationalFieldKeys = Literal[
        'user',
        'post',
    ]

# ForumPostSubscription types

class ForumPostSubscriptionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ForumPostSubscription create method"""
    id: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    userId: _str
    post: 'ForumPostCreateNestedWithoutRelationsInput'
    postId: _str
    createdAt: datetime.datetime


class ForumPostSubscriptionCreateInput(ForumPostSubscriptionOptionalCreateInput):
    """Required arguments to the ForumPostSubscription create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ForumPostSubscriptionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ForumPostSubscription create method, without relations"""
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime


class ForumPostSubscriptionCreateWithoutRelationsInput(ForumPostSubscriptionOptionalCreateWithoutRelationsInput):
    """Required arguments to the ForumPostSubscription create method, without relations"""

class ForumPostSubscriptionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ForumPostSubscriptionCreateWithoutRelationsInput'
    where: 'ForumPostSubscriptionWhereUniqueInput'

class ForumPostSubscriptionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumPostSubscriptionCreateWithoutRelationsInput'
    connect: 'ForumPostSubscriptionWhereUniqueInput'
    connect_or_create: 'ForumPostSubscriptionConnectOrCreateWithoutRelationsInput'


class ForumPostSubscriptionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ForumPostSubscriptionCreateWithoutRelationsInput', List['ForumPostSubscriptionCreateWithoutRelationsInput']]
    connect: Union['ForumPostSubscriptionWhereUniqueInput', List['ForumPostSubscriptionWhereUniqueInput']]
    connect_or_create: Union['ForumPostSubscriptionConnectOrCreateWithoutRelationsInput', List['ForumPostSubscriptionConnectOrCreateWithoutRelationsInput']]

_ForumPostSubscriptionWhereUnique_id_Input = TypedDict(
    '_ForumPostSubscriptionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ForumPostSubscriptionCompounduserId_postIdKeyInner = TypedDict(
    '_ForumPostSubscriptionCompounduserId_postIdKeyInner',
    {
        'userId': '_str',
        'postId': '_str',
    },
    total=True
)

_ForumPostSubscriptionCompounduserId_postIdKey = TypedDict(
    '_ForumPostSubscriptionCompounduserId_postIdKey',
    {
        'userId_postId': '_ForumPostSubscriptionCompounduserId_postIdKeyInner',
    },
    total=True
)

ForumPostSubscriptionWhereUniqueInput = Union[
    '_ForumPostSubscriptionWhereUnique_id_Input',
    '_ForumPostSubscriptionCompounduserId_postIdKey',
]


class ForumPostSubscriptionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    post: 'ForumPostUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime


class ForumPostSubscriptionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime


class ForumPostSubscriptionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ForumPostSubscriptionCreateWithoutRelationsInput']
    connect: List['ForumPostSubscriptionWhereUniqueInput']
    connect_or_create: List['ForumPostSubscriptionConnectOrCreateWithoutRelationsInput']
    set: List['ForumPostSubscriptionWhereUniqueInput']
    disconnect: List['ForumPostSubscriptionWhereUniqueInput']
    delete: List['ForumPostSubscriptionWhereUniqueInput']

    # TODO
    # update: List['ForumPostSubscriptionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ForumPostSubscriptionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ForumPostSubscriptionScalarWhereInput']
    # upsert: List['ForumPostSubscriptionUpserteWithWhereUniqueWithoutRelationsInput']


class ForumPostSubscriptionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumPostSubscriptionCreateWithoutRelationsInput'
    connect: 'ForumPostSubscriptionWhereUniqueInput'
    connect_or_create: 'ForumPostSubscriptionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ForumPostSubscriptionUpdateInput'
    # upsert: 'ForumPostSubscriptionUpsertWithoutRelationsInput'


class ForumPostSubscriptionUpsertInput(TypedDict):
    create: 'ForumPostSubscriptionCreateInput'
    update: 'ForumPostSubscriptionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ForumPostSubscription_id_OrderByInput = TypedDict(
    '_ForumPostSubscription_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ForumPostSubscription_userId_OrderByInput = TypedDict(
    '_ForumPostSubscription_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_ForumPostSubscription_postId_OrderByInput = TypedDict(
    '_ForumPostSubscription_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_ForumPostSubscription_createdAt_OrderByInput = TypedDict(
    '_ForumPostSubscription_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ForumPostSubscription_RelevanceInner = TypedDict(
    '_ForumPostSubscription_RelevanceInner',
    {
        'fields': 'List[ForumPostSubscriptionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ForumPostSubscription_RelevanceOrderByInput = TypedDict(
    '_ForumPostSubscription_RelevanceOrderByInput',
    {
        '_relevance': '_ForumPostSubscription_RelevanceInner',
    },
    total=True
)

ForumPostSubscriptionOrderByInput = Union[
    '_ForumPostSubscription_id_OrderByInput',
    '_ForumPostSubscription_userId_OrderByInput',
    '_ForumPostSubscription_postId_OrderByInput',
    '_ForumPostSubscription_createdAt_OrderByInput',
    '_ForumPostSubscription_RelevanceOrderByInput',
]



# recursive ForumPostSubscription types
# TODO: cleanup these types



ForumPostSubscriptionRelationFilter = TypedDict(
    'ForumPostSubscriptionRelationFilter',
    {
        'is': 'ForumPostSubscriptionWhereInput',
        'is_not': 'ForumPostSubscriptionWhereInput',
    },
    total=False,
)


class ForumPostSubscriptionListRelationFilter(TypedDict, total=False):
    some: 'ForumPostSubscriptionWhereInput'
    none: 'ForumPostSubscriptionWhereInput'
    every: 'ForumPostSubscriptionWhereInput'


class ForumPostSubscriptionInclude(TypedDict, total=False):
    """ForumPostSubscription relational arguments"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    post: Union[bool, 'ForumPostArgsFromForumPostSubscription']


class UserIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    player: Union[bool, 'PlayerArgsFromForumPostSubscription']
    notifications: Union[bool, 'FindManyNotificationArgsFromForumPostSubscription']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromForumPostSubscription']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromForumPostSubscription']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromForumPostSubscription']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromForumPostSubscription']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumPostSubscription']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromForumPostSubscription']


class UserArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromForumPostSubscription']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromForumPostSubscription']


class PlayerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    player: Union[bool, 'PlayerArgsFromForumPostSubscription']


class GamertagHistoryArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    tiers: Union[bool, 'FindManyTierArgsFromForumPostSubscription']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromForumPostSubscription']


class SeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    season: Union[bool, 'SeasonArgsFromForumPostSubscription']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromForumPostSubscription']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumPostSubscription']


class TierArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromForumPostSubscription']
    managers: Union[bool, 'FindManyTeamManagerArgsFromForumPostSubscription']
    nhlAffiliate: Union[bool, 'TeamArgsFromForumPostSubscription']
    ahlAffiliate: Union[bool, 'TeamArgsFromForumPostSubscription']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromForumPostSubscription']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromForumPostSubscription']


class TeamArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    team: Union[bool, 'TeamArgsFromForumPostSubscription']
    tier: Union[bool, 'TierArgsFromForumPostSubscription']
    matches: Union[bool, 'FindManyMatchArgsFromForumPostSubscription']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumPostSubscription']
    bids: Union[bool, 'FindManyBidArgsFromForumPostSubscription']


class TeamSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    player: Union[bool, 'PlayerArgsFromForumPostSubscription']
    season: Union[bool, 'SeasonArgsFromForumPostSubscription']
    contract: Union[bool, 'ContractArgsFromForumPostSubscription']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumPostSubscription']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumPostSubscription']


class PlayerSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPostSubscription']
    tier: Union[bool, 'TierArgsFromForumPostSubscription']


class PlayerTierHistoryArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPostSubscription']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPostSubscription']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromForumPostSubscription']


class PlayerTeamSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumPostSubscription']
    bids: Union[bool, 'FindManyBidArgsFromForumPostSubscription']


class ContractArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    contract: Union[bool, 'ContractArgsFromForumPostSubscription']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPostSubscription']


class BidArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumPostSubscription']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromForumPostSubscription']


class MatchArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    match: Union[bool, 'MatchArgsFromForumPostSubscription']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromForumPostSubscription']


class PlayerMatchArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']


class NotificationArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    author: Union[bool, 'UserArgsFromForumPostSubscription']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumPostSubscription']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumPostSubscription']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumPostSubscription']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumPostSubscription']


class ForumPostArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    post: Union[bool, 'ForumPostArgsFromForumPostSubscription']
    comment: Union[bool, 'ForumCommentArgsFromForumPostSubscription']


class ForumReactionArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    post: Union[bool, 'ForumPostArgsFromForumPostSubscription']


class ForumFollowerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    post: Union[bool, 'ForumPostArgsFromForumPostSubscription']


class ForumPostSubscriptionArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    author: Union[bool, 'UserArgsFromForumPostSubscription']
    post: Union[bool, 'ForumPostArgsFromForumPostSubscription']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumPostSubscription']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumPostSubscription']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumPostSubscription']


class ForumCommentArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromForumPostSubscription(TypedDict, total=False):
    """Relational arguments for ForumPostSubscription"""
    user: Union[bool, 'UserArgsFromForumPostSubscription']
    team: Union[bool, 'TeamArgsFromForumPostSubscription']


class TeamManagerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromForumPostSubscription(TypedDict, total=False):
    """Arguments for ForumPostSubscription"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyForumPostSubscriptionArgs = FindManyForumPostSubscriptionArgsFromForumPostSubscription
FindFirstForumPostSubscriptionArgs = FindManyForumPostSubscriptionArgsFromForumPostSubscription


class ForumPostSubscriptionWhereInput(TypedDict, total=False):
    """ForumPostSubscription arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    post: 'ForumPostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ForumPostSubscriptionWhereInput', List['ForumPostSubscriptionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ForumPostSubscriptionWhereInput']
    OR: List['ForumPostSubscriptionWhereInput']
    NOT: List['ForumPostSubscriptionWhereInput']



# aggregate ForumPostSubscription types


class ForumPostSubscriptionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ForumPostSubscription arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ForumPostSubscriptionScalarWhereWithAggregatesInput']
    OR: List['ForumPostSubscriptionScalarWhereWithAggregatesInput']
    NOT: List['ForumPostSubscriptionScalarWhereWithAggregatesInput']



class ForumPostSubscriptionGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime
    _sum: 'ForumPostSubscriptionSumAggregateOutput'
    _avg: 'ForumPostSubscriptionAvgAggregateOutput'
    _min: 'ForumPostSubscriptionMinAggregateOutput'
    _max: 'ForumPostSubscriptionMaxAggregateOutput'
    _count: 'ForumPostSubscriptionCountAggregateOutput'


class ForumPostSubscriptionAvgAggregateOutput(TypedDict, total=False):
    """ForumPostSubscription output for aggregating averages"""


class ForumPostSubscriptionSumAggregateOutput(TypedDict, total=False):
    """ForumPostSubscription output for aggregating sums"""


class ForumPostSubscriptionScalarAggregateOutput(TypedDict, total=False):
    """ForumPostSubscription output including scalar fields"""
    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime


ForumPostSubscriptionMinAggregateOutput = ForumPostSubscriptionScalarAggregateOutput
ForumPostSubscriptionMaxAggregateOutput = ForumPostSubscriptionScalarAggregateOutput


class ForumPostSubscriptionMaxAggregateInput(TypedDict, total=False):
    """ForumPostSubscription input for aggregating by max"""
    id: bool
    userId: bool
    postId: bool
    createdAt: bool


class ForumPostSubscriptionMinAggregateInput(TypedDict, total=False):
    """ForumPostSubscription input for aggregating by min"""
    id: bool
    userId: bool
    postId: bool
    createdAt: bool


class ForumPostSubscriptionNumberAggregateInput(TypedDict, total=False):
    """ForumPostSubscription input for aggregating numbers"""


ForumPostSubscriptionAvgAggregateInput = ForumPostSubscriptionNumberAggregateInput
ForumPostSubscriptionSumAggregateInput = ForumPostSubscriptionNumberAggregateInput


ForumPostSubscriptionCountAggregateInput = TypedDict(
    'ForumPostSubscriptionCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'postId': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ForumPostSubscriptionCountAggregateOutput = TypedDict(
    'ForumPostSubscriptionCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'postId': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ForumPostSubscriptionKeys = Literal[
    'id',
    'user',
    'userId',
    'post',
    'postId',
    'createdAt',
]
ForumPostSubscriptionScalarFieldKeys = Literal[
    'id',
    'userId',
    'postId',
    'createdAt',
]
ForumPostSubscriptionScalarFieldKeysT = TypeVar('ForumPostSubscriptionScalarFieldKeysT', bound=ForumPostSubscriptionScalarFieldKeys)

ForumPostSubscriptionRelationalFieldKeys = Literal[
        'user',
        'post',
    ]

# ForumComment types

class ForumCommentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ForumComment create method"""
    id: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: 'UserCreateNestedWithoutRelationsInput'
    authorId: _str
    post: 'ForumPostCreateNestedWithoutRelationsInput'
    postId: _str
    quotedComment: 'ForumCommentCreateNestedWithoutRelationsInput'
    quotedCommentId: Optional[_str]
    quotedBy: 'ForumCommentCreateManyNestedWithoutRelationsInput'
    reactions: 'ForumReactionCreateManyNestedWithoutRelationsInput'
    gif: Optional['fields.Json']


class ForumCommentCreateInput(ForumCommentOptionalCreateInput):
    """Required arguments to the ForumComment create method"""
    content: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ForumCommentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ForumComment create method, without relations"""
    id: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    authorId: _str
    postId: _str
    quotedCommentId: Optional[_str]
    gif: Optional['fields.Json']


class ForumCommentCreateWithoutRelationsInput(ForumCommentOptionalCreateWithoutRelationsInput):
    """Required arguments to the ForumComment create method, without relations"""
    content: _str

class ForumCommentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ForumCommentCreateWithoutRelationsInput'
    where: 'ForumCommentWhereUniqueInput'

class ForumCommentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumCommentCreateWithoutRelationsInput'
    connect: 'ForumCommentWhereUniqueInput'
    connect_or_create: 'ForumCommentConnectOrCreateWithoutRelationsInput'


class ForumCommentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ForumCommentCreateWithoutRelationsInput', List['ForumCommentCreateWithoutRelationsInput']]
    connect: Union['ForumCommentWhereUniqueInput', List['ForumCommentWhereUniqueInput']]
    connect_or_create: Union['ForumCommentConnectOrCreateWithoutRelationsInput', List['ForumCommentConnectOrCreateWithoutRelationsInput']]

_ForumCommentWhereUnique_id_Input = TypedDict(
    '_ForumCommentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ForumCommentWhereUniqueInput = _ForumCommentWhereUnique_id_Input


class ForumCommentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    content: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: 'UserUpdateOneWithoutRelationsInput'
    post: 'ForumPostUpdateOneWithoutRelationsInput'
    quotedComment: 'ForumCommentUpdateOneWithoutRelationsInput'
    quotedBy: 'ForumCommentUpdateManyWithoutRelationsInput'
    reactions: 'ForumReactionUpdateManyWithoutRelationsInput'
    gif: Optional['fields.Json']


class ForumCommentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    content: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gif: Optional['fields.Json']


class ForumCommentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ForumCommentCreateWithoutRelationsInput']
    connect: List['ForumCommentWhereUniqueInput']
    connect_or_create: List['ForumCommentConnectOrCreateWithoutRelationsInput']
    set: List['ForumCommentWhereUniqueInput']
    disconnect: List['ForumCommentWhereUniqueInput']
    delete: List['ForumCommentWhereUniqueInput']

    # TODO
    # update: List['ForumCommentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ForumCommentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ForumCommentScalarWhereInput']
    # upsert: List['ForumCommentUpserteWithWhereUniqueWithoutRelationsInput']


class ForumCommentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ForumCommentCreateWithoutRelationsInput'
    connect: 'ForumCommentWhereUniqueInput'
    connect_or_create: 'ForumCommentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ForumCommentUpdateInput'
    # upsert: 'ForumCommentUpsertWithoutRelationsInput'


class ForumCommentUpsertInput(TypedDict):
    create: 'ForumCommentCreateInput'
    update: 'ForumCommentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ForumComment_id_OrderByInput = TypedDict(
    '_ForumComment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ForumComment_content_OrderByInput = TypedDict(
    '_ForumComment_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_ForumComment_status_OrderByInput = TypedDict(
    '_ForumComment_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_ForumComment_createdAt_OrderByInput = TypedDict(
    '_ForumComment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ForumComment_updatedAt_OrderByInput = TypedDict(
    '_ForumComment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_ForumComment_authorId_OrderByInput = TypedDict(
    '_ForumComment_authorId_OrderByInput',
    {
        'authorId': 'SortOrder',
    },
    total=True
)

_ForumComment_postId_OrderByInput = TypedDict(
    '_ForumComment_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_ForumComment_quotedCommentId_OrderByInput = TypedDict(
    '_ForumComment_quotedCommentId_OrderByInput',
    {
        'quotedCommentId': 'SortOrder',
    },
    total=True
)

_ForumComment_gif_OrderByInput = TypedDict(
    '_ForumComment_gif_OrderByInput',
    {
        'gif': 'SortOrder',
    },
    total=True
)

_ForumComment_RelevanceInner = TypedDict(
    '_ForumComment_RelevanceInner',
    {
        'fields': 'List[ForumCommentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ForumComment_RelevanceOrderByInput = TypedDict(
    '_ForumComment_RelevanceOrderByInput',
    {
        '_relevance': '_ForumComment_RelevanceInner',
    },
    total=True
)

ForumCommentOrderByInput = Union[
    '_ForumComment_id_OrderByInput',
    '_ForumComment_content_OrderByInput',
    '_ForumComment_status_OrderByInput',
    '_ForumComment_createdAt_OrderByInput',
    '_ForumComment_updatedAt_OrderByInput',
    '_ForumComment_authorId_OrderByInput',
    '_ForumComment_postId_OrderByInput',
    '_ForumComment_quotedCommentId_OrderByInput',
    '_ForumComment_gif_OrderByInput',
    '_ForumComment_RelevanceOrderByInput',
]



# recursive ForumComment types
# TODO: cleanup these types



ForumCommentRelationFilter = TypedDict(
    'ForumCommentRelationFilter',
    {
        'is': 'ForumCommentWhereInput',
        'is_not': 'ForumCommentWhereInput',
    },
    total=False,
)


class ForumCommentListRelationFilter(TypedDict, total=False):
    some: 'ForumCommentWhereInput'
    none: 'ForumCommentWhereInput'
    every: 'ForumCommentWhereInput'


class ForumCommentInclude(TypedDict, total=False):
    """ForumComment relational arguments"""
    author: Union[bool, 'UserArgsFromForumComment']
    post: Union[bool, 'ForumPostArgsFromForumComment']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumComment']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumComment']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumComment']


class UserIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    player: Union[bool, 'PlayerArgsFromForumComment']
    notifications: Union[bool, 'FindManyNotificationArgsFromForumComment']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromForumComment']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromForumComment']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromForumComment']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromForumComment']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumComment']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromForumComment']


class UserArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromForumComment']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromForumComment']


class PlayerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    player: Union[bool, 'PlayerArgsFromForumComment']


class GamertagHistoryArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    tiers: Union[bool, 'FindManyTierArgsFromForumComment']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromForumComment']


class SeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    season: Union[bool, 'SeasonArgsFromForumComment']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromForumComment']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumComment']


class TierArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromForumComment']
    managers: Union[bool, 'FindManyTeamManagerArgsFromForumComment']
    nhlAffiliate: Union[bool, 'TeamArgsFromForumComment']
    ahlAffiliate: Union[bool, 'TeamArgsFromForumComment']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromForumComment']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromForumComment']


class TeamArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    team: Union[bool, 'TeamArgsFromForumComment']
    tier: Union[bool, 'TierArgsFromForumComment']
    matches: Union[bool, 'FindManyMatchArgsFromForumComment']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumComment']
    bids: Union[bool, 'FindManyBidArgsFromForumComment']


class TeamSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    player: Union[bool, 'PlayerArgsFromForumComment']
    season: Union[bool, 'SeasonArgsFromForumComment']
    contract: Union[bool, 'ContractArgsFromForumComment']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromForumComment']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromForumComment']


class PlayerSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumComment']
    tier: Union[bool, 'TierArgsFromForumComment']


class PlayerTierHistoryArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumComment']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumComment']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromForumComment']


class PlayerTeamSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromForumComment']
    bids: Union[bool, 'FindManyBidArgsFromForumComment']


class ContractArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    contract: Union[bool, 'ContractArgsFromForumComment']
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumComment']


class BidArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromForumComment']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromForumComment']


class MatchArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    match: Union[bool, 'MatchArgsFromForumComment']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromForumComment']


class PlayerMatchArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']


class NotificationArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    author: Union[bool, 'UserArgsFromForumComment']
    comments: Union[bool, 'FindManyForumCommentArgsFromForumComment']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumComment']
    followers: Union[bool, 'FindManyForumFollowerArgsFromForumComment']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromForumComment']


class ForumPostArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']
    post: Union[bool, 'ForumPostArgsFromForumComment']
    comment: Union[bool, 'ForumCommentArgsFromForumComment']


class ForumReactionArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']
    post: Union[bool, 'ForumPostArgsFromForumComment']


class ForumFollowerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']
    post: Union[bool, 'ForumPostArgsFromForumComment']


class ForumPostSubscriptionArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    author: Union[bool, 'UserArgsFromForumComment']
    post: Union[bool, 'ForumPostArgsFromForumComment']
    quotedComment: Union[bool, 'ForumCommentArgsFromForumComment']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromForumComment']
    reactions: Union[bool, 'FindManyForumReactionArgsFromForumComment']


class ForumCommentArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromForumComment(TypedDict, total=False):
    """Relational arguments for ForumComment"""
    user: Union[bool, 'UserArgsFromForumComment']
    team: Union[bool, 'TeamArgsFromForumComment']


class TeamManagerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromForumComment(TypedDict, total=False):
    """Arguments for ForumComment"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyForumCommentArgs = FindManyForumCommentArgsFromForumComment
FindFirstForumCommentArgs = FindManyForumCommentArgsFromForumComment


class ForumCommentWhereInput(TypedDict, total=False):
    """ForumComment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    status: 'enums.ForumPostStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    author: 'UserRelationFilter'
    authorId: Union[_str, 'types.StringFilter']
    post: 'ForumPostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    quotedComment: 'ForumCommentRelationFilter'
    quotedCommentId: Union[None, _str, 'types.StringFilter']
    quotedBy: 'ForumCommentListRelationFilter'
    reactions: 'ForumReactionListRelationFilter'
    gif: Union[None, 'fields.Json', 'types.JsonFilter']

    # should be noted that AND and NOT should be Union['ForumCommentWhereInput', List['ForumCommentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ForumCommentWhereInput']
    OR: List['ForumCommentWhereInput']
    NOT: List['ForumCommentWhereInput']



# aggregate ForumComment types


class ForumCommentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ForumComment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.ForumPostStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    authorId: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    quotedCommentId: Union[_str, 'types.StringWithAggregatesFilter']
    gif: Union['fields.Json', 'types.JsonWithAggregatesFilter']

    AND: List['ForumCommentScalarWhereWithAggregatesInput']
    OR: List['ForumCommentScalarWhereWithAggregatesInput']
    NOT: List['ForumCommentScalarWhereWithAggregatesInput']



class ForumCommentGroupByOutput(TypedDict, total=False):
    id: _str
    content: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    authorId: _str
    postId: _str
    quotedCommentId: _str
    gif: 'fields.Json'
    _sum: 'ForumCommentSumAggregateOutput'
    _avg: 'ForumCommentAvgAggregateOutput'
    _min: 'ForumCommentMinAggregateOutput'
    _max: 'ForumCommentMaxAggregateOutput'
    _count: 'ForumCommentCountAggregateOutput'


class ForumCommentAvgAggregateOutput(TypedDict, total=False):
    """ForumComment output for aggregating averages"""


class ForumCommentSumAggregateOutput(TypedDict, total=False):
    """ForumComment output for aggregating sums"""


class ForumCommentScalarAggregateOutput(TypedDict, total=False):
    """ForumComment output including scalar fields"""
    id: _str
    content: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    authorId: _str
    postId: _str
    quotedCommentId: _str
    gif: 'fields.Json'


ForumCommentMinAggregateOutput = ForumCommentScalarAggregateOutput
ForumCommentMaxAggregateOutput = ForumCommentScalarAggregateOutput


class ForumCommentMaxAggregateInput(TypedDict, total=False):
    """ForumComment input for aggregating by max"""
    id: bool
    content: bool
    status: bool
    createdAt: bool
    updatedAt: bool
    authorId: bool
    postId: bool
    quotedCommentId: bool
    gif: bool


class ForumCommentMinAggregateInput(TypedDict, total=False):
    """ForumComment input for aggregating by min"""
    id: bool
    content: bool
    status: bool
    createdAt: bool
    updatedAt: bool
    authorId: bool
    postId: bool
    quotedCommentId: bool
    gif: bool


class ForumCommentNumberAggregateInput(TypedDict, total=False):
    """ForumComment input for aggregating numbers"""


ForumCommentAvgAggregateInput = ForumCommentNumberAggregateInput
ForumCommentSumAggregateInput = ForumCommentNumberAggregateInput


ForumCommentCountAggregateInput = TypedDict(
    'ForumCommentCountAggregateInput',
    {
        'id': bool,
        'content': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'authorId': bool,
        'postId': bool,
        'quotedCommentId': bool,
        'gif': bool,
        '_all': bool,
    },
    total=False,
)

ForumCommentCountAggregateOutput = TypedDict(
    'ForumCommentCountAggregateOutput',
    {
        'id': int,
        'content': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        'authorId': int,
        'postId': int,
        'quotedCommentId': int,
        'gif': int,
        '_all': int,
    },
    total=False,
)


ForumCommentKeys = Literal[
    'id',
    'content',
    'status',
    'createdAt',
    'updatedAt',
    'author',
    'authorId',
    'post',
    'postId',
    'quotedComment',
    'quotedCommentId',
    'quotedBy',
    'reactions',
    'gif',
]
ForumCommentScalarFieldKeys = Literal[
    'id',
    'content',
    'status',
    'createdAt',
    'updatedAt',
    'authorId',
    'postId',
    'quotedCommentId',
    'gif',
]
ForumCommentScalarFieldKeysT = TypeVar('ForumCommentScalarFieldKeysT', bound=ForumCommentScalarFieldKeys)

ForumCommentRelationalFieldKeys = Literal[
        'author',
        'post',
        'quotedComment',
        'quotedBy',
        'reactions',
    ]

# TeamManager types

class TeamManagerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TeamManager create method"""
    id: _str
    userId: _str
    teamId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'
    team: 'TeamCreateNestedWithoutRelationsInput'


class TeamManagerCreateInput(TeamManagerOptionalCreateInput):
    """Required arguments to the TeamManager create method"""
    role: 'enums.TeamManagementRole'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamManagerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TeamManager create method, without relations"""
    id: _str
    userId: _str
    teamId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TeamManagerCreateWithoutRelationsInput(TeamManagerOptionalCreateWithoutRelationsInput):
    """Required arguments to the TeamManager create method, without relations"""
    role: 'enums.TeamManagementRole'

class TeamManagerConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeamManagerCreateWithoutRelationsInput'
    where: 'TeamManagerWhereUniqueInput'

class TeamManagerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamManagerCreateWithoutRelationsInput'
    connect: 'TeamManagerWhereUniqueInput'
    connect_or_create: 'TeamManagerConnectOrCreateWithoutRelationsInput'


class TeamManagerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamManagerCreateWithoutRelationsInput', List['TeamManagerCreateWithoutRelationsInput']]
    connect: Union['TeamManagerWhereUniqueInput', List['TeamManagerWhereUniqueInput']]
    connect_or_create: Union['TeamManagerConnectOrCreateWithoutRelationsInput', List['TeamManagerConnectOrCreateWithoutRelationsInput']]

_TeamManagerWhereUnique_id_Input = TypedDict(
    '_TeamManagerWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_TeamManagerCompounduserId_teamId_roleKeyInner = TypedDict(
    '_TeamManagerCompounduserId_teamId_roleKeyInner',
    {
        'userId': '_str',
        'teamId': '_str',
        'role': 'enums.TeamManagementRole',
    },
    total=True
)

_TeamManagerCompounduserId_teamId_roleKey = TypedDict(
    '_TeamManagerCompounduserId_teamId_roleKey',
    {
        'userId_teamId_role': '_TeamManagerCompounduserId_teamId_roleKeyInner',
    },
    total=True
)

TeamManagerWhereUniqueInput = Union[
    '_TeamManagerWhereUnique_id_Input',
    '_TeamManagerCompounduserId_teamId_roleKey',
]


class TeamManagerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    role: 'enums.TeamManagementRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    team: 'TeamUpdateOneWithoutRelationsInput'


class TeamManagerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    role: 'enums.TeamManagementRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TeamManagerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamManagerCreateWithoutRelationsInput']
    connect: List['TeamManagerWhereUniqueInput']
    connect_or_create: List['TeamManagerConnectOrCreateWithoutRelationsInput']
    set: List['TeamManagerWhereUniqueInput']
    disconnect: List['TeamManagerWhereUniqueInput']
    delete: List['TeamManagerWhereUniqueInput']

    # TODO
    # update: List['TeamManagerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamManagerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamManagerScalarWhereInput']
    # upsert: List['TeamManagerUpserteWithWhereUniqueWithoutRelationsInput']


class TeamManagerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamManagerCreateWithoutRelationsInput'
    connect: 'TeamManagerWhereUniqueInput'
    connect_or_create: 'TeamManagerConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamManagerUpdateInput'
    # upsert: 'TeamManagerUpsertWithoutRelationsInput'


class TeamManagerUpsertInput(TypedDict):
    create: 'TeamManagerCreateInput'
    update: 'TeamManagerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TeamManager_id_OrderByInput = TypedDict(
    '_TeamManager_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TeamManager_userId_OrderByInput = TypedDict(
    '_TeamManager_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_TeamManager_teamId_OrderByInput = TypedDict(
    '_TeamManager_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

_TeamManager_role_OrderByInput = TypedDict(
    '_TeamManager_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_TeamManager_createdAt_OrderByInput = TypedDict(
    '_TeamManager_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_TeamManager_updatedAt_OrderByInput = TypedDict(
    '_TeamManager_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_TeamManager_RelevanceInner = TypedDict(
    '_TeamManager_RelevanceInner',
    {
        'fields': 'List[TeamManagerScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_TeamManager_RelevanceOrderByInput = TypedDict(
    '_TeamManager_RelevanceOrderByInput',
    {
        '_relevance': '_TeamManager_RelevanceInner',
    },
    total=True
)

TeamManagerOrderByInput = Union[
    '_TeamManager_id_OrderByInput',
    '_TeamManager_userId_OrderByInput',
    '_TeamManager_teamId_OrderByInput',
    '_TeamManager_role_OrderByInput',
    '_TeamManager_createdAt_OrderByInput',
    '_TeamManager_updatedAt_OrderByInput',
    '_TeamManager_RelevanceOrderByInput',
]



# recursive TeamManager types
# TODO: cleanup these types



TeamManagerRelationFilter = TypedDict(
    'TeamManagerRelationFilter',
    {
        'is': 'TeamManagerWhereInput',
        'is_not': 'TeamManagerWhereInput',
    },
    total=False,
)


class TeamManagerListRelationFilter(TypedDict, total=False):
    some: 'TeamManagerWhereInput'
    none: 'TeamManagerWhereInput'
    every: 'TeamManagerWhereInput'


class TeamManagerInclude(TypedDict, total=False):
    """TeamManager relational arguments"""
    user: Union[bool, 'UserArgsFromTeamManager']
    team: Union[bool, 'TeamArgsFromTeamManager']


class UserIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    player: Union[bool, 'PlayerArgsFromTeamManager']
    notifications: Union[bool, 'FindManyNotificationArgsFromTeamManager']
    forumPosts: Union[bool, 'FindManyForumPostArgsFromTeamManager']
    forumComments: Union[bool, 'FindManyForumCommentArgsFromTeamManager']
    forumReactions: Union[bool, 'FindManyForumReactionArgsFromTeamManager']
    forumFollowing: Union[bool, 'FindManyForumFollowerArgsFromTeamManager']
    forumSubscriptions: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeamManager']
    teamManagement: Union[bool, 'FindManyTeamManagerArgsFromTeamManager']


class UserArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class PlayerIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']
    gamertags: Union[bool, 'FindManyGamertagHistoryArgsFromTeamManager']
    seasons: Union[bool, 'FindManyPlayerSeasonArgsFromTeamManager']


class PlayerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'PlayerIncludeFromPlayer'


class FindManyPlayerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['PlayerOrderByInput', List['PlayerOrderByInput']]
    where: 'PlayerWhereInput'
    cursor: 'PlayerWhereUniqueInput'
    distinct: List['PlayerScalarFieldKeys']
    include: 'PlayerIncludeFromPlayer'


class GamertagHistoryIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    player: Union[bool, 'PlayerArgsFromTeamManager']


class GamertagHistoryArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class FindManyGamertagHistoryArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['GamertagHistoryOrderByInput', List['GamertagHistoryOrderByInput']]
    where: 'GamertagHistoryWhereInput'
    cursor: 'GamertagHistoryWhereUniqueInput'
    distinct: List['GamertagHistoryScalarFieldKeys']
    include: 'GamertagHistoryIncludeFromGamertagHistory'


class SeasonIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    tiers: Union[bool, 'FindManyTierArgsFromTeamManager']
    players: Union[bool, 'FindManyPlayerSeasonArgsFromTeamManager']


class SeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'SeasonIncludeFromSeason'


class FindManySeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['SeasonOrderByInput', List['SeasonOrderByInput']]
    where: 'SeasonWhereInput'
    cursor: 'SeasonWhereUniqueInput'
    distinct: List['SeasonScalarFieldKeys']
    include: 'SeasonIncludeFromSeason'


class TierIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    season: Union[bool, 'SeasonArgsFromTeamManager']
    teams: Union[bool, 'FindManyTeamSeasonArgsFromTeamManager']
    playerHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeamManager']


class TierArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'TierIncludeFromTier'


class FindManyTierArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['TierOrderByInput', List['TierOrderByInput']]
    where: 'TierWhereInput'
    cursor: 'TierWhereUniqueInput'
    distinct: List['TierScalarFieldKeys']
    include: 'TierIncludeFromTier'


class TeamIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    seasons: Union[bool, 'FindManyTeamSeasonArgsFromTeamManager']
    managers: Union[bool, 'FindManyTeamManagerArgsFromTeamManager']
    nhlAffiliate: Union[bool, 'TeamArgsFromTeamManager']
    ahlAffiliate: Union[bool, 'TeamArgsFromTeamManager']
    ahlAffiliates: Union[bool, 'FindManyTeamArgsFromTeamManager']
    echlAffiliates: Union[bool, 'FindManyTeamArgsFromTeamManager']


class TeamArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'TeamIncludeFromTeam'


class FindManyTeamArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeam'


class TeamSeasonIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    team: Union[bool, 'TeamArgsFromTeamManager']
    tier: Union[bool, 'TierArgsFromTeamManager']
    matches: Union[bool, 'FindManyMatchArgsFromTeamManager']
    players: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeamManager']
    bids: Union[bool, 'FindManyBidArgsFromTeamManager']


class TeamSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'TeamSeasonIncludeFromTeamSeason'


class FindManyTeamSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['TeamSeasonOrderByInput', List['TeamSeasonOrderByInput']]
    where: 'TeamSeasonWhereInput'
    cursor: 'TeamSeasonWhereUniqueInput'
    distinct: List['TeamSeasonScalarFieldKeys']
    include: 'TeamSeasonIncludeFromTeamSeason'


class PlayerSeasonIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    player: Union[bool, 'PlayerArgsFromTeamManager']
    season: Union[bool, 'SeasonArgsFromTeamManager']
    contract: Union[bool, 'ContractArgsFromTeamManager']
    teamSeasons: Union[bool, 'FindManyPlayerTeamSeasonArgsFromTeamManager']
    tierHistory: Union[bool, 'FindManyPlayerTierHistoryArgsFromTeamManager']


class PlayerSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class FindManyPlayerSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['PlayerSeasonOrderByInput', List['PlayerSeasonOrderByInput']]
    where: 'PlayerSeasonWhereInput'
    cursor: 'PlayerSeasonWhereUniqueInput'
    distinct: List['PlayerSeasonScalarFieldKeys']
    include: 'PlayerSeasonIncludeFromPlayerSeason'


class PlayerTierHistoryIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamManager']
    tier: Union[bool, 'TierArgsFromTeamManager']


class PlayerTierHistoryArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class FindManyPlayerTierHistoryArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['PlayerTierHistoryOrderByInput', List['PlayerTierHistoryOrderByInput']]
    where: 'PlayerTierHistoryWhereInput'
    cursor: 'PlayerTierHistoryWhereUniqueInput'
    distinct: List['PlayerTierHistoryScalarFieldKeys']
    include: 'PlayerTierHistoryIncludeFromPlayerTierHistory'


class PlayerTeamSeasonIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamManager']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamManager']
    matches: Union[bool, 'FindManyPlayerMatchArgsFromTeamManager']


class PlayerTeamSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class FindManyPlayerTeamSeasonArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['PlayerTeamSeasonOrderByInput', List['PlayerTeamSeasonOrderByInput']]
    where: 'PlayerTeamSeasonWhereInput'
    cursor: 'PlayerTeamSeasonWhereUniqueInput'
    distinct: List['PlayerTeamSeasonScalarFieldKeys']
    include: 'PlayerTeamSeasonIncludeFromPlayerTeamSeason'


class ContractIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    playerSeason: Union[bool, 'PlayerSeasonArgsFromTeamManager']
    bids: Union[bool, 'FindManyBidArgsFromTeamManager']


class ContractArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ContractIncludeFromContract'


class FindManyContractArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ContractOrderByInput', List['ContractOrderByInput']]
    where: 'ContractWhereInput'
    cursor: 'ContractWhereUniqueInput'
    distinct: List['ContractScalarFieldKeys']
    include: 'ContractIncludeFromContract'


class BidIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    contract: Union[bool, 'ContractArgsFromTeamManager']
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamManager']


class BidArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'BidIncludeFromBid'


class FindManyBidArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['BidOrderByInput', List['BidOrderByInput']]
    where: 'BidWhereInput'
    cursor: 'BidWhereUniqueInput'
    distinct: List['BidScalarFieldKeys']
    include: 'BidIncludeFromBid'


class MatchIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    teamSeason: Union[bool, 'TeamSeasonArgsFromTeamManager']
    playerStats: Union[bool, 'FindManyPlayerMatchArgsFromTeamManager']


class MatchArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'MatchIncludeFromMatch'


class FindManyMatchArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatch'


class PlayerMatchIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    match: Union[bool, 'MatchArgsFromTeamManager']
    playerTeamSeason: Union[bool, 'PlayerTeamSeasonArgsFromTeamManager']


class PlayerMatchArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'PlayerMatchIncludeFromPlayerMatch'


class FindManyPlayerMatchArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['PlayerMatchOrderByInput', List['PlayerMatchOrderByInput']]
    where: 'PlayerMatchWhereInput'
    cursor: 'PlayerMatchWhereUniqueInput'
    distinct: List['PlayerMatchScalarFieldKeys']
    include: 'PlayerMatchIncludeFromPlayerMatch'


class NotificationIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']


class NotificationArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class ForumPostIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    author: Union[bool, 'UserArgsFromTeamManager']
    comments: Union[bool, 'FindManyForumCommentArgsFromTeamManager']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeamManager']
    followers: Union[bool, 'FindManyForumFollowerArgsFromTeamManager']
    subscribers: Union[bool, 'FindManyForumPostSubscriptionArgsFromTeamManager']


class ForumPostArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ForumPostIncludeFromForumPost'


class FindManyForumPostArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ForumPostOrderByInput', List['ForumPostOrderByInput']]
    where: 'ForumPostWhereInput'
    cursor: 'ForumPostWhereUniqueInput'
    distinct: List['ForumPostScalarFieldKeys']
    include: 'ForumPostIncludeFromForumPost'


class ForumReactionIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']
    post: Union[bool, 'ForumPostArgsFromTeamManager']
    comment: Union[bool, 'ForumCommentArgsFromTeamManager']


class ForumReactionArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ForumReactionIncludeFromForumReaction'


class FindManyForumReactionArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ForumReactionOrderByInput', List['ForumReactionOrderByInput']]
    where: 'ForumReactionWhereInput'
    cursor: 'ForumReactionWhereUniqueInput'
    distinct: List['ForumReactionScalarFieldKeys']
    include: 'ForumReactionIncludeFromForumReaction'


class ForumFollowerIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']
    post: Union[bool, 'ForumPostArgsFromTeamManager']


class ForumFollowerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ForumFollowerIncludeFromForumFollower'


class FindManyForumFollowerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ForumFollowerOrderByInput', List['ForumFollowerOrderByInput']]
    where: 'ForumFollowerWhereInput'
    cursor: 'ForumFollowerWhereUniqueInput'
    distinct: List['ForumFollowerScalarFieldKeys']
    include: 'ForumFollowerIncludeFromForumFollower'


class ForumPostSubscriptionIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']
    post: Union[bool, 'ForumPostArgsFromTeamManager']


class ForumPostSubscriptionArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class FindManyForumPostSubscriptionArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ForumPostSubscriptionOrderByInput', List['ForumPostSubscriptionOrderByInput']]
    where: 'ForumPostSubscriptionWhereInput'
    cursor: 'ForumPostSubscriptionWhereUniqueInput'
    distinct: List['ForumPostSubscriptionScalarFieldKeys']
    include: 'ForumPostSubscriptionIncludeFromForumPostSubscription'


class ForumCommentIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    author: Union[bool, 'UserArgsFromTeamManager']
    post: Union[bool, 'ForumPostArgsFromTeamManager']
    quotedComment: Union[bool, 'ForumCommentArgsFromTeamManager']
    quotedBy: Union[bool, 'FindManyForumCommentArgsFromTeamManager']
    reactions: Union[bool, 'FindManyForumReactionArgsFromTeamManager']


class ForumCommentArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'ForumCommentIncludeFromForumComment'


class FindManyForumCommentArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['ForumCommentOrderByInput', List['ForumCommentOrderByInput']]
    where: 'ForumCommentWhereInput'
    cursor: 'ForumCommentWhereUniqueInput'
    distinct: List['ForumCommentScalarFieldKeys']
    include: 'ForumCommentIncludeFromForumComment'


class TeamManagerIncludeFromTeamManager(TypedDict, total=False):
    """Relational arguments for TeamManager"""
    user: Union[bool, 'UserArgsFromTeamManager']
    team: Union[bool, 'TeamArgsFromTeamManager']


class TeamManagerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    include: 'TeamManagerIncludeFromTeamManager'


class FindManyTeamManagerArgsFromTeamManager(TypedDict, total=False):
    """Arguments for TeamManager"""
    take: int
    skip: int
    order_by: Union['TeamManagerOrderByInput', List['TeamManagerOrderByInput']]
    where: 'TeamManagerWhereInput'
    cursor: 'TeamManagerWhereUniqueInput'
    distinct: List['TeamManagerScalarFieldKeys']
    include: 'TeamManagerIncludeFromTeamManager'




FindManyTeamManagerArgs = FindManyTeamManagerArgsFromTeamManager
FindFirstTeamManagerArgs = FindManyTeamManagerArgsFromTeamManager


class TeamManagerWhereInput(TypedDict, total=False):
    """TeamManager arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    role: 'enums.TeamManagementRole'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    team: 'TeamRelationFilter'

    # should be noted that AND and NOT should be Union['TeamManagerWhereInput', List['TeamManagerWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TeamManagerWhereInput']
    OR: List['TeamManagerWhereInput']
    NOT: List['TeamManagerWhereInput']



# aggregate TeamManager types


class TeamManagerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TeamManager arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.TeamManagementRole'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TeamManagerScalarWhereWithAggregatesInput']
    OR: List['TeamManagerScalarWhereWithAggregatesInput']
    NOT: List['TeamManagerScalarWhereWithAggregatesInput']



class TeamManagerGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    teamId: _str
    role: 'enums.TeamManagementRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'TeamManagerSumAggregateOutput'
    _avg: 'TeamManagerAvgAggregateOutput'
    _min: 'TeamManagerMinAggregateOutput'
    _max: 'TeamManagerMaxAggregateOutput'
    _count: 'TeamManagerCountAggregateOutput'


class TeamManagerAvgAggregateOutput(TypedDict, total=False):
    """TeamManager output for aggregating averages"""


class TeamManagerSumAggregateOutput(TypedDict, total=False):
    """TeamManager output for aggregating sums"""


class TeamManagerScalarAggregateOutput(TypedDict, total=False):
    """TeamManager output including scalar fields"""
    id: _str
    userId: _str
    teamId: _str
    role: 'enums.TeamManagementRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


TeamManagerMinAggregateOutput = TeamManagerScalarAggregateOutput
TeamManagerMaxAggregateOutput = TeamManagerScalarAggregateOutput


class TeamManagerMaxAggregateInput(TypedDict, total=False):
    """TeamManager input for aggregating by max"""
    id: bool
    userId: bool
    teamId: bool
    role: bool
    createdAt: bool
    updatedAt: bool


class TeamManagerMinAggregateInput(TypedDict, total=False):
    """TeamManager input for aggregating by min"""
    id: bool
    userId: bool
    teamId: bool
    role: bool
    createdAt: bool
    updatedAt: bool


class TeamManagerNumberAggregateInput(TypedDict, total=False):
    """TeamManager input for aggregating numbers"""


TeamManagerAvgAggregateInput = TeamManagerNumberAggregateInput
TeamManagerSumAggregateInput = TeamManagerNumberAggregateInput


TeamManagerCountAggregateInput = TypedDict(
    'TeamManagerCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'teamId': bool,
        'role': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

TeamManagerCountAggregateOutput = TypedDict(
    'TeamManagerCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'teamId': int,
        'role': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


TeamManagerKeys = Literal[
    'id',
    'userId',
    'teamId',
    'role',
    'createdAt',
    'updatedAt',
    'user',
    'team',
]
TeamManagerScalarFieldKeys = Literal[
    'id',
    'userId',
    'teamId',
    'role',
    'createdAt',
    'updatedAt',
]
TeamManagerScalarFieldKeysT = TypeVar('TeamManagerScalarFieldKeysT', bound=TeamManagerScalarFieldKeys)

TeamManagerRelationalFieldKeys = Literal[
        'user',
        'team',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields