# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    email: _str
    username: _str
    password: _str
    name: Optional[_str] = None
    avatarUrl: Optional[_str] = None
    isAdmin: _bool
    resetToken: Optional[_str] = None
    resetTokenExpiresAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: Optional['models.Player'] = None
    notifications: Optional[List['models.Notification']] = None
    forumPosts: Optional[List['models.ForumPost']] = None
    forumComments: Optional[List['models.ForumComment']] = None
    forumReactions: Optional[List['models.ForumReaction']] = None
    forumFollowing: Optional[List['models.ForumFollower']] = None
    forumSubscriptions: Optional[List['models.ForumPostSubscription']] = None
    teamManagement: Optional[List['models.TeamManager']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Player(bases.BasePlayer):
    """Represents a Player record"""

    id: _str
    ea_id: _str
    name: _str
    activeSystem: 'enums.System'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None
    gamertags: Optional[List['models.GamertagHistory']] = None
    seasons: Optional[List['models.PlayerSeason']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlayerKeys']] = None,
        exclude: Optional[Iterable['types.PlayerKeys']] = None,
        required: Optional[Iterable['types.PlayerKeys']] = None,
        optional: Optional[Iterable['types.PlayerKeys']] = None,
        relations: Optional[Mapping['types.PlayerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlayerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Player_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Player_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Player_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Player_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Player_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Player_relational_fields:
                        raise errors.UnknownRelationalFieldError('Player', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Player / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Player',
            }
        )
        _created_partial_types.add(name)


class GamertagHistory(bases.BaseGamertagHistory):
    """Represents a GamertagHistory record"""

    playerId: _str
    system: 'enums.System'
    gamertag: _str
    createdAt: datetime.datetime
    player: Optional['models.Player'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GamertagHistoryKeys']] = None,
        exclude: Optional[Iterable['types.GamertagHistoryKeys']] = None,
        required: Optional[Iterable['types.GamertagHistoryKeys']] = None,
        optional: Optional[Iterable['types.GamertagHistoryKeys']] = None,
        relations: Optional[Mapping['types.GamertagHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GamertagHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _GamertagHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _GamertagHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _GamertagHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _GamertagHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _GamertagHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _GamertagHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('GamertagHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid GamertagHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'GamertagHistory',
            }
        )
        _created_partial_types.add(name)


class Season(bases.BaseSeason):
    """Represents a Season record"""

    id: _str
    seasonId: _str
    isLatest: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tiers: Optional[List['models.Tier']] = None
    players: Optional[List['models.PlayerSeason']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SeasonKeys']] = None,
        exclude: Optional[Iterable['types.SeasonKeys']] = None,
        required: Optional[Iterable['types.SeasonKeys']] = None,
        optional: Optional[Iterable['types.SeasonKeys']] = None,
        relations: Optional[Mapping['types.SeasonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SeasonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Season_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Season_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Season_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Season_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Season_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Season_relational_fields:
                        raise errors.UnknownRelationalFieldError('Season', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Season / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Season',
            }
        )
        _created_partial_types.add(name)


class Tier(bases.BaseTier):
    """Represents a Tier record"""

    id: _str
    seasonId: _str
    leagueLevel: _int
    name: _str
    salaryCap: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    season: Optional['models.Season'] = None
    teams: Optional[List['models.TeamSeason']] = None
    playerHistory: Optional[List['models.PlayerTierHistory']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TierKeys']] = None,
        exclude: Optional[Iterable['types.TierKeys']] = None,
        required: Optional[Iterable['types.TierKeys']] = None,
        optional: Optional[Iterable['types.TierKeys']] = None,
        relations: Optional[Mapping['types.TierRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TierKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Tier_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Tier_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Tier_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Tier_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Tier_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Tier_relational_fields:
                        raise errors.UnknownRelationalFieldError('Tier', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Tier / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Tier',
            }
        )
        _created_partial_types.add(name)


class Team(bases.BaseTeam):
    """Represents a Team record"""

    id: _str
    eaClubId: _str
    eaClubName: _str
    officialName: _str
    teamIdentifier: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    seasons: Optional[List['models.TeamSeason']] = None
    managers: Optional[List['models.TeamManager']] = None
    nhlAffiliateId: Optional[_str] = None
    ahlAffiliateId: Optional[_str] = None
    nhlAffiliate: Optional['models.Team'] = None
    ahlAffiliate: Optional['models.Team'] = None
    ahlAffiliates: Optional[List['models.Team']] = None
    echlAffiliates: Optional[List['models.Team']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamKeys']] = None,
        exclude: Optional[Iterable['types.TeamKeys']] = None,
        required: Optional[Iterable['types.TeamKeys']] = None,
        optional: Optional[Iterable['types.TeamKeys']] = None,
        relations: Optional[Mapping['types.TeamRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Team_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Team_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Team_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Team_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Team_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Team_relational_fields:
                        raise errors.UnknownRelationalFieldError('Team', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Team / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Team',
            }
        )
        _created_partial_types.add(name)


class TeamSeason(bases.BaseTeamSeason):
    """Represents a TeamSeason record"""

    id: _str
    teamId: _str
    tierId: _str
    forwardCount: _int
    defenseCount: _int
    goalieCount: _int
    wins: _int
    losses: _int
    otLosses: _int
    goalsAgainst: _int
    goalsFor: _int
    matchesPlayed: _int
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    team: Optional['models.Team'] = None
    tier: Optional['models.Tier'] = None
    matches: Optional[List['models.Match']] = None
    players: Optional[List['models.PlayerTeamSeason']] = None
    bids: Optional[List['models.Bid']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamSeasonKeys']] = None,
        exclude: Optional[Iterable['types.TeamSeasonKeys']] = None,
        required: Optional[Iterable['types.TeamSeasonKeys']] = None,
        optional: Optional[Iterable['types.TeamSeasonKeys']] = None,
        relations: Optional[Mapping['types.TeamSeasonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamSeasonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TeamSeason_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TeamSeason_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TeamSeason_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TeamSeason_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TeamSeason_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TeamSeason_relational_fields:
                        raise errors.UnknownRelationalFieldError('TeamSeason', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TeamSeason / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TeamSeason',
            }
        )
        _created_partial_types.add(name)


class PlayerSeason(bases.BasePlayerSeason):
    """Represents a PlayerSeason record"""

    id: _str
    playerId: _str
    seasonId: _str
    contractId: _str
    position: _str
    gamesPlayed: Optional[_int] = None
    goals: Optional[_int] = None
    assists: Optional[_int] = None
    plusMinus: Optional[_int] = None
    shots: Optional[_int] = None
    hits: Optional[_int] = None
    takeaways: Optional[_int] = None
    giveaways: Optional[_int] = None
    penaltyMinutes: Optional[_int] = None
    saves: Optional[_int] = None
    goalsAgainst: Optional[_int] = None
    isInBidding: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    player: Optional['models.Player'] = None
    season: Optional['models.Season'] = None
    contract: Optional['models.Contract'] = None
    teamSeasons: Optional[List['models.PlayerTeamSeason']] = None
    tierHistory: Optional[List['models.PlayerTierHistory']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlayerSeasonKeys']] = None,
        exclude: Optional[Iterable['types.PlayerSeasonKeys']] = None,
        required: Optional[Iterable['types.PlayerSeasonKeys']] = None,
        optional: Optional[Iterable['types.PlayerSeasonKeys']] = None,
        relations: Optional[Mapping['types.PlayerSeasonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlayerSeasonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PlayerSeason_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PlayerSeason_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PlayerSeason_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PlayerSeason_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PlayerSeason_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PlayerSeason_relational_fields:
                        raise errors.UnknownRelationalFieldError('PlayerSeason', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PlayerSeason / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PlayerSeason',
            }
        )
        _created_partial_types.add(name)


class PlayerTierHistory(bases.BasePlayerTierHistory):
    """Represents a PlayerTierHistory record"""

    id: _str
    playerSeasonId: _str
    tierId: _str
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: Optional['models.PlayerSeason'] = None
    tier: Optional['models.Tier'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlayerTierHistoryKeys']] = None,
        exclude: Optional[Iterable['types.PlayerTierHistoryKeys']] = None,
        required: Optional[Iterable['types.PlayerTierHistoryKeys']] = None,
        optional: Optional[Iterable['types.PlayerTierHistoryKeys']] = None,
        relations: Optional[Mapping['types.PlayerTierHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlayerTierHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PlayerTierHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PlayerTierHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PlayerTierHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PlayerTierHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PlayerTierHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PlayerTierHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('PlayerTierHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PlayerTierHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PlayerTierHistory',
            }
        )
        _created_partial_types.add(name)


class PlayerTeamSeason(bases.BasePlayerTeamSeason):
    """Represents a PlayerTeamSeason record"""

    id: _str
    playerSeasonId: _str
    teamSeasonId: _str
    assists: _int
    gamesPlayed: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    shots: _int
    takeaways: _int
    saves: Optional[_int] = None
    goalsAgainst: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: Optional['models.PlayerSeason'] = None
    teamSeason: Optional['models.TeamSeason'] = None
    matches: Optional[List['models.PlayerMatch']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlayerTeamSeasonKeys']] = None,
        exclude: Optional[Iterable['types.PlayerTeamSeasonKeys']] = None,
        required: Optional[Iterable['types.PlayerTeamSeasonKeys']] = None,
        optional: Optional[Iterable['types.PlayerTeamSeasonKeys']] = None,
        relations: Optional[Mapping['types.PlayerTeamSeasonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlayerTeamSeasonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PlayerTeamSeason_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PlayerTeamSeason_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PlayerTeamSeason_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PlayerTeamSeason_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PlayerTeamSeason_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PlayerTeamSeason_relational_fields:
                        raise errors.UnknownRelationalFieldError('PlayerTeamSeason', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PlayerTeamSeason / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PlayerTeamSeason',
            }
        )
        _created_partial_types.add(name)


class Contract(bases.BaseContract):
    """Represents a Contract record"""

    id: _str
    amount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    playerSeason: Optional['models.PlayerSeason'] = None
    bids: Optional[List['models.Bid']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ContractKeys']] = None,
        exclude: Optional[Iterable['types.ContractKeys']] = None,
        required: Optional[Iterable['types.ContractKeys']] = None,
        optional: Optional[Iterable['types.ContractKeys']] = None,
        relations: Optional[Mapping['types.ContractRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ContractKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Contract_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Contract_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Contract_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Contract_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Contract_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Contract_relational_fields:
                        raise errors.UnknownRelationalFieldError('Contract', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Contract / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Contract',
            }
        )
        _created_partial_types.add(name)


class Bid(bases.BaseBid):
    """Represents a Bid record"""

    id: _str
    contract: Optional['models.Contract'] = None
    contractId: _str
    teamSeason: Optional['models.TeamSeason'] = None
    teamSeasonId: _str
    amount: _int
    status: 'enums.BidStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BidKeys']] = None,
        exclude: Optional[Iterable['types.BidKeys']] = None,
        required: Optional[Iterable['types.BidKeys']] = None,
        optional: Optional[Iterable['types.BidKeys']] = None,
        relations: Optional[Mapping['types.BidRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BidKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Bid_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Bid_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Bid_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Bid_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Bid_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Bid_relational_fields:
                        raise errors.UnknownRelationalFieldError('Bid', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Bid / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Bid',
            }
        )
        _created_partial_types.add(name)


class Match(bases.BaseMatch):
    """Represents a Match record"""

    id: _str
    teamSeasonId: _str
    eaMatchId: _str
    goalsAgainst: _int
    goalsFor: _int
    opponentClubId: _str
    opponentTeamId: _str
    penaltyKillGoalsAgainst: _int
    penaltyKillOpportunities: _int
    powerplayGoals: _int
    powerplayOpportunities: _int
    shots: _int
    shotsAgainst: _int
    timeOnAttack: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    teamSeason: Optional['models.TeamSeason'] = None
    playerStats: Optional[List['models.PlayerMatch']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MatchKeys']] = None,
        exclude: Optional[Iterable['types.MatchKeys']] = None,
        required: Optional[Iterable['types.MatchKeys']] = None,
        optional: Optional[Iterable['types.MatchKeys']] = None,
        relations: Optional[Mapping['types.MatchRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MatchKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Match_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Match_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Match_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Match_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Match_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Match_relational_fields:
                        raise errors.UnknownRelationalFieldError('Match', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Match / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Match',
            }
        )
        _created_partial_types.add(name)


class PlayerMatch(bases.BasePlayerMatch):
    """Represents a PlayerMatch record"""

    id: _str
    matchId: _str
    playerTeamSeasonId: _str
    assists: _int
    giveaways: _int
    goals: _int
    hits: _int
    penaltyMinutes: _int
    plusMinus: _int
    ratingDefense: _float
    ratingOffense: _float
    ratingTeamplay: _float
    shots: _int
    takeaways: _int
    timeOnIce: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    match: Optional['models.Match'] = None
    playerTeamSeason: Optional['models.PlayerTeamSeason'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlayerMatchKeys']] = None,
        exclude: Optional[Iterable['types.PlayerMatchKeys']] = None,
        required: Optional[Iterable['types.PlayerMatchKeys']] = None,
        optional: Optional[Iterable['types.PlayerMatchKeys']] = None,
        relations: Optional[Mapping['types.PlayerMatchRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlayerMatchKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PlayerMatch_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PlayerMatch_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PlayerMatch_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PlayerMatch_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PlayerMatch_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PlayerMatch_relational_fields:
                        raise errors.UnknownRelationalFieldError('PlayerMatch', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PlayerMatch / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PlayerMatch',
            }
        )
        _created_partial_types.add(name)


class Notification(bases.BaseNotification):
    """Represents a Notification record"""

    id: _str
    userId: _str
    type: 'enums.NotificationType'
    title: _str
    message: _str
    status: 'enums.NotificationStatus'
    link: Optional[_str] = None
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NotificationKeys']] = None,
        exclude: Optional[Iterable['types.NotificationKeys']] = None,
        required: Optional[Iterable['types.NotificationKeys']] = None,
        optional: Optional[Iterable['types.NotificationKeys']] = None,
        relations: Optional[Mapping['types.NotificationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Notification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Notification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Notification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Notification_relational_fields:
                        raise errors.UnknownRelationalFieldError('Notification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Notification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Notification',
            }
        )
        _created_partial_types.add(name)


class ForumPost(bases.BaseForumPost):
    """Represents a ForumPost record"""

    id: _str
    title: _str
    content: _str
    status: 'enums.ForumPostStatus'
    authorId: _str
    leagueId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: Optional['models.User'] = None
    comments: Optional[List['models.ForumComment']] = None
    reactions: Optional[List['models.ForumReaction']] = None
    followers: Optional[List['models.ForumFollower']] = None
    subscribers: Optional[List['models.ForumPostSubscription']] = None
    gif: Optional['fields.Json'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ForumPostKeys']] = None,
        exclude: Optional[Iterable['types.ForumPostKeys']] = None,
        required: Optional[Iterable['types.ForumPostKeys']] = None,
        optional: Optional[Iterable['types.ForumPostKeys']] = None,
        relations: Optional[Mapping['types.ForumPostRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ForumPostKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ForumPost_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ForumPost_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ForumPost_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ForumPost_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ForumPost_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ForumPost_relational_fields:
                        raise errors.UnknownRelationalFieldError('ForumPost', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ForumPost / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ForumPost',
            }
        )
        _created_partial_types.add(name)


class ForumReaction(bases.BaseForumReaction):
    """Represents a ForumReaction record"""

    id: _str
    type: 'enums.ReactionType'
    userId: _str
    postId: Optional[_str] = None
    commentId: Optional[_str] = None
    createdAt: datetime.datetime
    user: Optional['models.User'] = None
    post: Optional['models.ForumPost'] = None
    comment: Optional['models.ForumComment'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ForumReactionKeys']] = None,
        exclude: Optional[Iterable['types.ForumReactionKeys']] = None,
        required: Optional[Iterable['types.ForumReactionKeys']] = None,
        optional: Optional[Iterable['types.ForumReactionKeys']] = None,
        relations: Optional[Mapping['types.ForumReactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ForumReactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ForumReaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ForumReaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ForumReaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ForumReaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ForumReaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ForumReaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('ForumReaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ForumReaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ForumReaction',
            }
        )
        _created_partial_types.add(name)


class ForumFollower(bases.BaseForumFollower):
    """Represents a ForumFollower record"""

    id: _str
    userId: _str
    postId: _str
    createdAt: datetime.datetime
    user: Optional['models.User'] = None
    post: Optional['models.ForumPost'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ForumFollowerKeys']] = None,
        exclude: Optional[Iterable['types.ForumFollowerKeys']] = None,
        required: Optional[Iterable['types.ForumFollowerKeys']] = None,
        optional: Optional[Iterable['types.ForumFollowerKeys']] = None,
        relations: Optional[Mapping['types.ForumFollowerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ForumFollowerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ForumFollower_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ForumFollower_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ForumFollower_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ForumFollower_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ForumFollower_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ForumFollower_relational_fields:
                        raise errors.UnknownRelationalFieldError('ForumFollower', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ForumFollower / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ForumFollower',
            }
        )
        _created_partial_types.add(name)


class ForumPostSubscription(bases.BaseForumPostSubscription):
    """Represents a ForumPostSubscription record"""

    id: _str
    user: Optional['models.User'] = None
    userId: _str
    post: Optional['models.ForumPost'] = None
    postId: _str
    createdAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ForumPostSubscriptionKeys']] = None,
        exclude: Optional[Iterable['types.ForumPostSubscriptionKeys']] = None,
        required: Optional[Iterable['types.ForumPostSubscriptionKeys']] = None,
        optional: Optional[Iterable['types.ForumPostSubscriptionKeys']] = None,
        relations: Optional[Mapping['types.ForumPostSubscriptionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ForumPostSubscriptionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ForumPostSubscription_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ForumPostSubscription_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ForumPostSubscription_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ForumPostSubscription_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ForumPostSubscription_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ForumPostSubscription_relational_fields:
                        raise errors.UnknownRelationalFieldError('ForumPostSubscription', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ForumPostSubscription / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ForumPostSubscription',
            }
        )
        _created_partial_types.add(name)


class ForumComment(bases.BaseForumComment):
    """Represents a ForumComment record"""

    id: _str
    content: _str
    status: 'enums.ForumPostStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    author: Optional['models.User'] = None
    authorId: _str
    post: Optional['models.ForumPost'] = None
    postId: _str
    quotedComment: Optional['models.ForumComment'] = None
    quotedCommentId: Optional[_str] = None
    quotedBy: Optional[List['models.ForumComment']] = None
    reactions: Optional[List['models.ForumReaction']] = None
    gif: Optional['fields.Json'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ForumCommentKeys']] = None,
        exclude: Optional[Iterable['types.ForumCommentKeys']] = None,
        required: Optional[Iterable['types.ForumCommentKeys']] = None,
        optional: Optional[Iterable['types.ForumCommentKeys']] = None,
        relations: Optional[Mapping['types.ForumCommentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ForumCommentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ForumComment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ForumComment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ForumComment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ForumComment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ForumComment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ForumComment_relational_fields:
                        raise errors.UnknownRelationalFieldError('ForumComment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ForumComment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ForumComment',
            }
        )
        _created_partial_types.add(name)


class TeamManager(bases.BaseTeamManager):
    """Represents a TeamManager record"""

    id: _str
    userId: _str
    teamId: _str
    role: 'enums.TeamManagementRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None
    team: Optional['models.Team'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamManagerKeys']] = None,
        exclude: Optional[Iterable['types.TeamManagerKeys']] = None,
        required: Optional[Iterable['types.TeamManagerKeys']] = None,
        optional: Optional[Iterable['types.TeamManagerKeys']] = None,
        relations: Optional[Mapping['types.TeamManagerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamManagerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TeamManager_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TeamManager_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TeamManager_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TeamManager_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TeamManager_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TeamManager_relational_fields:
                        raise errors.UnknownRelationalFieldError('TeamManager', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TeamManager / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TeamManager',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'player',
        'notifications',
        'forumPosts',
        'forumComments',
        'forumReactions',
        'forumFollowing',
        'forumSubscriptions',
        'teamManagement',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('avatarUrl', {
            'name': 'avatarUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isAdmin', {
            'name': 'isAdmin',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('resetToken', {
            'name': 'resetToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resetTokenExpiresAt', {
            'name': 'resetTokenExpiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('player', {
            'name': 'player',
            'is_list': False,
            'optional': True,
            'type': 'models.Player',
            'is_relational': True,
            'documentation': None,
        }),
        ('notifications', {
            'name': 'notifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Notification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('forumPosts', {
            'name': 'forumPosts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumPost\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('forumComments', {
            'name': 'forumComments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumComment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('forumReactions', {
            'name': 'forumReactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumReaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('forumFollowing', {
            'name': 'forumFollowing',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumFollower\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('forumSubscriptions', {
            'name': 'forumSubscriptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumPostSubscription\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamManagement', {
            'name': 'teamManagement',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamManager\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Player_relational_fields: Set[str] = {
        'user',
        'gamertags',
        'seasons',
    }
_Player_fields: Dict['types.PlayerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ea_id', {
            'name': 'ea_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('activeSystem', {
            'name': 'activeSystem',
            'is_list': False,
            'optional': False,
            'type': 'enums.System',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('gamertags', {
            'name': 'gamertags',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.GamertagHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('seasons', {
            'name': 'seasons',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_GamertagHistory_relational_fields: Set[str] = {
        'player',
    }
_GamertagHistory_fields: Dict['types.GamertagHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('playerId', {
            'name': 'playerId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('system', {
            'name': 'system',
            'is_list': False,
            'optional': False,
            'type': 'enums.System',
            'is_relational': False,
            'documentation': None,
        }),
        ('gamertag', {
            'name': 'gamertag',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('player', {
            'name': 'player',
            'is_list': False,
            'optional': True,
            'type': 'models.Player',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Season_relational_fields: Set[str] = {
        'tiers',
        'players',
    }
_Season_fields: Dict['types.SeasonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('seasonId', {
            'name': 'seasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isLatest', {
            'name': 'isLatest',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('tiers', {
            'name': 'tiers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Tier\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('players', {
            'name': 'players',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Tier_relational_fields: Set[str] = {
        'season',
        'teams',
        'playerHistory',
    }
_Tier_fields: Dict['types.TierKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('seasonId', {
            'name': 'seasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('leagueLevel', {
            'name': 'leagueLevel',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('salaryCap', {
            'name': 'salaryCap',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('season', {
            'name': 'season',
            'is_list': False,
            'optional': True,
            'type': 'models.Season',
            'is_relational': True,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('playerHistory', {
            'name': 'playerHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerTierHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Team_relational_fields: Set[str] = {
        'seasons',
        'managers',
        'nhlAffiliate',
        'ahlAffiliate',
        'ahlAffiliates',
        'echlAffiliates',
    }
_Team_fields: Dict['types.TeamKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('eaClubId', {
            'name': 'eaClubId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('eaClubName', {
            'name': 'eaClubName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('officialName', {
            'name': 'officialName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamIdentifier', {
            'name': 'teamIdentifier',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('seasons', {
            'name': 'seasons',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('managers', {
            'name': 'managers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamManager\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('nhlAffiliateId', {
            'name': 'nhlAffiliateId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ahlAffiliateId', {
            'name': 'ahlAffiliateId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nhlAffiliate', {
            'name': 'nhlAffiliate',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('ahlAffiliate', {
            'name': 'ahlAffiliate',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('ahlAffiliates', {
            'name': 'ahlAffiliates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Team\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('echlAffiliates', {
            'name': 'echlAffiliates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Team\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TeamSeason_relational_fields: Set[str] = {
        'team',
        'tier',
        'matches',
        'players',
        'bids',
    }
_TeamSeason_fields: Dict['types.TeamSeasonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamId', {
            'name': 'teamId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tierId', {
            'name': 'tierId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('forwardCount', {
            'name': 'forwardCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('defenseCount', {
            'name': 'defenseCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalieCount', {
            'name': 'goalieCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('wins', {
            'name': 'wins',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('losses', {
            'name': 'losses',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('otLosses', {
            'name': 'otLosses',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsAgainst', {
            'name': 'goalsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsFor', {
            'name': 'goalsFor',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('matchesPlayed', {
            'name': 'matchesPlayed',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyKillGoalsAgainst', {
            'name': 'penaltyKillGoalsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyKillOpportunities', {
            'name': 'penaltyKillOpportunities',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('powerplayGoals', {
            'name': 'powerplayGoals',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('powerplayOpportunities', {
            'name': 'powerplayOpportunities',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shots', {
            'name': 'shots',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shotsAgainst', {
            'name': 'shotsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timeOnAttack', {
            'name': 'timeOnAttack',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('team', {
            'name': 'team',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('tier', {
            'name': 'tier',
            'is_list': False,
            'optional': True,
            'type': 'models.Tier',
            'is_relational': True,
            'documentation': None,
        }),
        ('matches', {
            'name': 'matches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('players', {
            'name': 'players',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerTeamSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('bids', {
            'name': 'bids',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Bid\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PlayerSeason_relational_fields: Set[str] = {
        'player',
        'season',
        'contract',
        'teamSeasons',
        'tierHistory',
    }
_PlayerSeason_fields: Dict['types.PlayerSeasonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerId', {
            'name': 'playerId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('seasonId', {
            'name': 'seasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contractId', {
            'name': 'contractId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('position', {
            'name': 'position',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gamesPlayed', {
            'name': 'gamesPlayed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goals', {
            'name': 'goals',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('assists', {
            'name': 'assists',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('plusMinus', {
            'name': 'plusMinus',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shots', {
            'name': 'shots',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hits', {
            'name': 'hits',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('takeaways', {
            'name': 'takeaways',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('giveaways', {
            'name': 'giveaways',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyMinutes', {
            'name': 'penaltyMinutes',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('saves', {
            'name': 'saves',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsAgainst', {
            'name': 'goalsAgainst',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isInBidding', {
            'name': 'isInBidding',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('player', {
            'name': 'player',
            'is_list': False,
            'optional': True,
            'type': 'models.Player',
            'is_relational': True,
            'documentation': None,
        }),
        ('season', {
            'name': 'season',
            'is_list': False,
            'optional': True,
            'type': 'models.Season',
            'is_relational': True,
            'documentation': None,
        }),
        ('contract', {
            'name': 'contract',
            'is_list': False,
            'optional': True,
            'type': 'models.Contract',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamSeasons', {
            'name': 'teamSeasons',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerTeamSeason\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tierHistory', {
            'name': 'tierHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerTierHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PlayerTierHistory_relational_fields: Set[str] = {
        'playerSeason',
        'tier',
    }
_PlayerTierHistory_fields: Dict['types.PlayerTierHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerSeasonId', {
            'name': 'playerSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tierId', {
            'name': 'tierId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startDate', {
            'name': 'startDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endDate', {
            'name': 'endDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerSeason', {
            'name': 'playerSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.PlayerSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('tier', {
            'name': 'tier',
            'is_list': False,
            'optional': True,
            'type': 'models.Tier',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PlayerTeamSeason_relational_fields: Set[str] = {
        'playerSeason',
        'teamSeason',
        'matches',
    }
_PlayerTeamSeason_fields: Dict['types.PlayerTeamSeasonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerSeasonId', {
            'name': 'playerSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamSeasonId', {
            'name': 'teamSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assists', {
            'name': 'assists',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('gamesPlayed', {
            'name': 'gamesPlayed',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('giveaways', {
            'name': 'giveaways',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goals', {
            'name': 'goals',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hits', {
            'name': 'hits',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyMinutes', {
            'name': 'penaltyMinutes',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('plusMinus', {
            'name': 'plusMinus',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shots', {
            'name': 'shots',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('takeaways', {
            'name': 'takeaways',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('saves', {
            'name': 'saves',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsAgainst', {
            'name': 'goalsAgainst',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerSeason', {
            'name': 'playerSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.PlayerSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamSeason', {
            'name': 'teamSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.TeamSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('matches', {
            'name': 'matches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerMatch\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Contract_relational_fields: Set[str] = {
        'playerSeason',
        'bids',
    }
_Contract_fields: Dict['types.ContractKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerSeason', {
            'name': 'playerSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.PlayerSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('bids', {
            'name': 'bids',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Bid\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Bid_relational_fields: Set[str] = {
        'contract',
        'teamSeason',
    }
_Bid_fields: Dict['types.BidKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contract', {
            'name': 'contract',
            'is_list': False,
            'optional': True,
            'type': 'models.Contract',
            'is_relational': True,
            'documentation': None,
        }),
        ('contractId', {
            'name': 'contractId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamSeason', {
            'name': 'teamSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.TeamSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamSeasonId', {
            'name': 'teamSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.BidStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Match_relational_fields: Set[str] = {
        'teamSeason',
        'playerStats',
    }
_Match_fields: Dict['types.MatchKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamSeasonId', {
            'name': 'teamSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('eaMatchId', {
            'name': 'eaMatchId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsAgainst', {
            'name': 'goalsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goalsFor', {
            'name': 'goalsFor',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('opponentClubId', {
            'name': 'opponentClubId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('opponentTeamId', {
            'name': 'opponentTeamId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyKillGoalsAgainst', {
            'name': 'penaltyKillGoalsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyKillOpportunities', {
            'name': 'penaltyKillOpportunities',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('powerplayGoals', {
            'name': 'powerplayGoals',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('powerplayOpportunities', {
            'name': 'powerplayOpportunities',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shots', {
            'name': 'shots',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('shotsAgainst', {
            'name': 'shotsAgainst',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timeOnAttack', {
            'name': 'timeOnAttack',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamSeason', {
            'name': 'teamSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.TeamSeason',
            'is_relational': True,
            'documentation': None,
        }),
        ('playerStats', {
            'name': 'playerStats',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PlayerMatch\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PlayerMatch_relational_fields: Set[str] = {
        'match',
        'playerTeamSeason',
    }
_PlayerMatch_fields: Dict['types.PlayerMatchKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('matchId', {
            'name': 'matchId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('playerTeamSeasonId', {
            'name': 'playerTeamSeasonId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assists', {
            'name': 'assists',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('giveaways', {
            'name': 'giveaways',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('goals', {
            'name': 'goals',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hits', {
            'name': 'hits',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('penaltyMinutes', {
            'name': 'penaltyMinutes',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('plusMinus', {
            'name': 'plusMinus',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ratingDefense', {
            'name': 'ratingDefense',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('ratingOffense', {
            'name': 'ratingOffense',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('ratingTeamplay', {
            'name': 'ratingTeamplay',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('shots', {
            'name': 'shots',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('takeaways', {
            'name': 'takeaways',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timeOnIce', {
            'name': 'timeOnIce',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('match', {
            'name': 'match',
            'is_list': False,
            'optional': True,
            'type': 'models.Match',
            'is_relational': True,
            'documentation': None,
        }),
        ('playerTeamSeason', {
            'name': 'playerTeamSeason',
            'is_list': False,
            'optional': True,
            'type': 'models.PlayerTeamSeason',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Notification_relational_fields: Set[str] = {
        'user',
    }
_Notification_fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.NotificationType',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.NotificationStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('link', {
            'name': 'link',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ForumPost_relational_fields: Set[str] = {
        'author',
        'comments',
        'reactions',
        'followers',
        'subscribers',
    }
_ForumPost_fields: Dict['types.ForumPostKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ForumPostStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('authorId', {
            'name': 'authorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('leagueId', {
            'name': 'leagueId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('comments', {
            'name': 'comments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumComment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reactions', {
            'name': 'reactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumReaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('followers', {
            'name': 'followers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumFollower\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('subscribers', {
            'name': 'subscribers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumPostSubscription\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('gif', {
            'name': 'gif',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ForumReaction_relational_fields: Set[str] = {
        'user',
        'post',
        'comment',
    }
_ForumReaction_fields: Dict['types.ForumReactionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.ReactionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('commentId', {
            'name': 'commentId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumPost',
            'is_relational': True,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumComment',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ForumFollower_relational_fields: Set[str] = {
        'user',
        'post',
    }
_ForumFollower_fields: Dict['types.ForumFollowerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumPost',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ForumPostSubscription_relational_fields: Set[str] = {
        'user',
        'post',
    }
_ForumPostSubscription_fields: Dict['types.ForumPostSubscriptionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumPost',
            'is_relational': True,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ForumComment_relational_fields: Set[str] = {
        'author',
        'post',
        'quotedComment',
        'quotedBy',
        'reactions',
    }
_ForumComment_fields: Dict['types.ForumCommentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ForumPostStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('authorId', {
            'name': 'authorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumPost',
            'is_relational': True,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quotedComment', {
            'name': 'quotedComment',
            'is_list': False,
            'optional': True,
            'type': 'models.ForumComment',
            'is_relational': True,
            'documentation': None,
        }),
        ('quotedCommentId', {
            'name': 'quotedCommentId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quotedBy', {
            'name': 'quotedBy',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumComment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reactions', {
            'name': 'reactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ForumReaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('gif', {
            'name': 'gif',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_TeamManager_relational_fields: Set[str] = {
        'user',
        'team',
    }
_TeamManager_fields: Dict['types.TeamManagerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamId', {
            'name': 'teamId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.TeamManagementRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('team', {
            'name': 'team',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Player)
model_rebuild(GamertagHistory)
model_rebuild(Season)
model_rebuild(Tier)
model_rebuild(Team)
model_rebuild(TeamSeason)
model_rebuild(PlayerSeason)
model_rebuild(PlayerTierHistory)
model_rebuild(PlayerTeamSeason)
model_rebuild(Contract)
model_rebuild(Bid)
model_rebuild(Match)
model_rebuild(PlayerMatch)
model_rebuild(Notification)
model_rebuild(ForumPost)
model_rebuild(ForumReaction)
model_rebuild(ForumFollower)
model_rebuild(ForumPostSubscription)
model_rebuild(ForumComment)
model_rebuild(TeamManager)
